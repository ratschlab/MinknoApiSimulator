# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/device.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class FlowCellConnectorType(betterproto.Enum):
    """
    Describes the type of flow cell connection.

     This means that this determines what flow cells can be inserted.

     Since 4.1
    """

    FCCON_NOT_SET = 0
    """
    This is the default value when this enum is used in requests, and can be used to indicate
     that the caller doesn't care about flow cell connection types.
    
     It should not be returned by any RPCs (if you do see it returned, you may be using
     minknow_api from 4.1+ to call RPCs on MinKNOW Core 4.0).
    """

    FCCON_PROMETHION = 1
    """The flow cell position accepts PromethION-style flow cells."""

    FCCON_MINION_MK1 = 2
    """
    The flow cell position accepts MinION flow cells. MinION Mk1, Mk1B and Mk1C all accept these
     flow cells, as well as the GridION X5.
    
     Note that if a Flongle adapter is inserted, FCCON_FLONGLE will be returned instead.
    """

    FCCON_FLONGLE = 3
    """
    The flow cell position accepts Flongle flow cells.
    
     Currently, this means a MinION or GridION with a Flongle adapter inserted.
    """

    FCCON_PEBBLE = 4
    """
    The flow cell position accepts Pebble-style flow-cells.
     This should be treated as experimental and subject to change
    """


class InsertionScriptStatus(betterproto.Enum):
    NOT_RUN = 0
    """
    An insertion script has not been run for a flow-cell. Not all
     platforms use an insertion script.
    """

    FAILED = 1
    """
    An insertion script has been run and has failed to complete
     successfully. This can indicate a faulty flow-cell or that the flow-cell
     has not been inserted correctly.
    """

    SUCCEEDED = 2
    """Script run successfully, hardware ready to use."""


class SelectedWell(betterproto.Enum):
    WELL_NONE = 0
    WELL_1 = 1
    WELL_2 = 2
    WELL_3 = 3
    WELL_4 = 4
    WELL_OTHER = 5


class GetDeviceInfoResponseDeviceType(betterproto.Enum):
    """
    The `PEBBLE` device type should be treated as experimental and subject to change
    """

    MINION = 0
    GRIDION = 2
    PROMETHION = 3
    MINION_MK1C = 4
    P2_SOLO = 6
    MINION_MK1D = 7
    P2_INTEGRATED = 8
    PEBBLE = 9


class GetDeviceStateResponseDeviceState(betterproto.Enum):
    DEVICE_DISCONNECTED = 0
    DEVICE_READY = 1


class SetTemperatureResponseSetTemperatureResult(betterproto.Enum):
    TARGET_TEMPERATURE_SET = 0
    """
    The specified target temperature was set
     This result will be returned if the request did not specify `wait_for_temperature`
    """

    REACHED_TEMPERATURE = 1
    """
    The target temperature was set successfully, and the requested temperature was reached
     while waiting for temperature
    """

    TIMED_OUT_WAITING_FOR_TEMPERATURE = 2
    """
    The `wait_for_temperature` timeout expired while waiting for the target temperature to
     be reached.
    
     If this result is returned, then `timed_out_waiting_for_temperature` will be set to
     true
    """

    SECONDARY_TEMPERATURE_LIMITS_EXCEEDED = 3
    """
    The secondary temperature limits were exceeded while waiting for the target temperature
     to be reached
     The temperature control state has been reset to the state it was in before the call to
      `set_temperature()`
    """


@dataclass(eq=False, repr=False)
class ChannelConfiguration(betterproto.Message):
    """
    Describes the configuration of a channel on the device.

     Note that this is a lossy representation. The device-specific APIs provide more precise
     information. This only describes common configurations, and omits anything that doesn't impact
     the received signal.
    """

    well: int = betterproto.uint32_field(1)
    """
    The currently-connected well.
    
     Wells are counted from 1. 0 indicates that no well is connected. 5 indicates some non-generic configuration
     such as ground for a minion or connecting all wells on promethion
    
     Note that MinKNOW can return channel configurations where the well number is larger than the
     ``max_well_count`` value returned by :meth:`DeviceService.get_device_info`. This indicates
     that some other connection has been made (for example, PromethIONs can simultaneously
     connect all wells, and MinIONs can connect to ground).
    """

    test_current: bool = betterproto.bool_field(2)
    """
    Whether the test current is connected to the integrator (measurement circuit).
    
     The signal will be a steady test current produced on the device. This can be used for
     calibration or to test the device integration circuits.
    """


@dataclass(eq=False, repr=False)
class ReturnedChannelConfiguration(betterproto.Message):
    """
    Describes the configuration of a channel on the device.

     Note that this is a lossy representation. The device-specific APIs provide more precise
     information. This only describes common configurations, and omits anything that doesn't impact
     the received signal.
    """

    well: int = betterproto.uint32_field(1)
    """
    The currently-connected well.
    
     Wells are counted from 1. 0 indicates that no well is connected. 5 indicates some non-generic configuration
     such as ground for a minion or connecting all wells on promethion
    
     Note that MinKNOW can return channel configurations where the well number is larger than the
     ``max_well_count`` value returned by :meth:`DeviceService.get_device_info`. This indicates
     that some other connection has been made (for example, PromethIONs can simultaneously
     connect all wells, and MinIONs can connect to ground).
    """

    test_current: bool = betterproto.bool_field(2)
    """
    Whether the test current is connected to the integrator (measurement circuit).
    
     The signal will be a steady test current produced on the device. This can be used for
     calibration or to test the device integration circuits.
    """

    unblock: bool = betterproto.bool_field(4)
    """
    Whether the unblock voltage is connected to the integrator (measurement circuit).
    
     Provides a reverse potential across the connected well. This can be used to drive molecules
     back out of the well.
    """


@dataclass(eq=False, repr=False)
class GetDeviceInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetDeviceInfoResponse(betterproto.Message):
    device_id: str = betterproto.string_field(1)
    """
    A unique identifier for the device.
    
     This is the identifier of the device MinKNOW was started for. It will only communicate
     with this device.
    
     Note that simulated device IDs are only unique for this host, not globally.
    
     This value will be set even if the device is not currently connected (assuming MinKNOW
     was started by the manager service).
    """

    device_type: "GetDeviceInfoResponseDeviceType" = betterproto.enum_field(2)
    """The type of the device."""

    is_simulated: bool = betterproto.bool_field(3)
    """
    Whether the device is simulated.
    
     If this is true, there is no physical device - MinKNOW is simulating it. If it is false,
     MinKNOW will be acquiring data from a real device.
    """

    max_channel_count: int = betterproto.uint32_field(4)
    """
    The maximum number of channels supported by the device.
    
     Each channel provides a signal from the device. For example, a MinION supports up to 512
     channels, and so can provide 512 simultaneous streams of data.
    
     This value is fixed for a given device type. Note, however, that a flow cell might be attached
     that has a smaller number of channels.
    """

    max_wells_per_channel: int = betterproto.uint32_field(5)
    """
    The maximum number of wells connected to each channel.
    
     A well is a discrete location on the device where sensing can take place. Normally, each well
     should have a single nanopore in it.
    
     For example, a MinION supports up to 4 wells per channel, allowing for 2048 wells in total.
     So the value of this for a MinION will be 4.
    
     This value is fixed for a given device type. Note, however, that a flow cell might be attached
     that has a smaller number of wells on each channel.
    """

    can_set_temperature: bool = betterproto.bool_field(6)
    """
    Whether the set_temperature() method can be expected to work.
    
     On some systems, not all connected devices have the ability to control their own temperature,
     as temperature controls are managed in groups. If this field is true, this device can control
     its own temperature. If it it false, it cannot, and the temperature will be maintained at a
     pre-determined temperature.
    """

    digitisation: int = betterproto.uint32_field(7)
    """
    The range of uncalibrated data values.
    
     This is the number of distinct signal values that can be produced by the device's analog to
     digital converter (ADC).
    """

    firmware_version: List["GetDeviceInfoResponseComponentVersion"] = (
        betterproto.message_field(10)
    )


@dataclass(eq=False, repr=False)
class GetDeviceInfoResponseComponentVersion(betterproto.Message):
    """
    Firmware versions and serial-numbers of components associated with this device

     Depending on the hardware, there may be several components associated with
     this device, each with their own firmware version and serial-number. Not all
     components have serial-numbers.
    """

    component: str = betterproto.string_field(1)
    """Description of the component that has firmware"""

    version: str = betterproto.string_field(2)
    """
    The firmware version, if this cannot be determined for a component where
     the firmware version would usually be available, this will contain
     "Unknown"
    """

    serial_number: str = betterproto.string_field(3)
    """
    The serial-number of a component. If this in not applicable to the
     type of component or cannot be read at the current time, then this
     field will be blank.
    """


@dataclass(eq=False, repr=False)
class GetDeviceStateRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetDeviceStateResponse(betterproto.Message):
    device_state: "GetDeviceStateResponseDeviceState" = betterproto.enum_field(1)
    """
    Whether the physical hardware is present.
    
     This is really only relevant to MinIONs, which could be unplugged by the user at any time.
    """

    flow_cell_connector: "FlowCellConnectorType" = betterproto.enum_field(2)
    """
    Indicates what sort of flow cell can be inserted.
    
     For example, if the user needs to set or override the flow cell product code, this can be
     used to limit the list of possible flow cell product codes to choose from.
    
     Since 4.1
    """


@dataclass(eq=False, repr=False)
class StreamDeviceStateRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetFlowCellInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetFlowCellInfoResponse(betterproto.Message):
    has_flow_cell: bool = betterproto.bool_field(1)
    """
    Whether there is a flow cell present.
    
     If both this and has_adapter are false, none of the other fields will contain useful
     information.
    """

    channel_count: int = betterproto.uint32_field(2)
    """
    The number of channels currently supported by the device.
    
     This may be smaller than the ``max_channel_count`` value returned by get_device_info(),
     depending on the attached flow cell.
    """

    wells_per_channel: int = betterproto.uint32_field(3)
    """
    The number of wells currently supported by the device.
    
     This may be smaller than the ``max_wells_per_channel`` value returned by get_device_info(),
     depending on the attached flow cell.
    """

    flow_cell_id: str = betterproto.string_field(4)
    """
    The unique identifier for the flow cell.
    
     This should be same as the value printed onto the flow cell casing. Not all flow cells will
     have the flow cell ID recorded in a way that MinKNOW can read. In those cases, this will be an
     empty string, even though the user may be able to see a printed identifier on the flow cell.
    """

    asic_id_str: str = betterproto.string_field(13)
    """
    The unique identifier for the ASIC (formatted as string).
    
     This is a value uniquely identifying the ASIC embedded in the flow cell. It will
     always be set when a flow cell is present.
    
     The intended use for this is to track the identity of the asic in the flow cell, eg. for
     displaying to users during production of chips.
    
     Caveats:
    
     * This value will not mean anything to a customer.
     * There is no guarantee that this field will contain the same identifier across
       MinKNOW versions, even with the same flow cell.
     * An ASIC can be recycled into a new flow cell, so this identifier may be re-used in the
       future (although it can be considered unique for the duration of a protocol run).
    """

    product_code: str = betterproto.string_field(6)
    """
    The product code for the flow cell.
    
     This should be the code displayed in the shop where the flow cell was bought. Not all
     flow cells will have the product code recorded in a way that MinKNOW can read. In those cases,
     this will be an empty string.
    """

    user_specified_flow_cell_id: str = betterproto.string_field(7)
    """
    A unique identifier for the flow cell, which the user can specify.
    
     In the event a flow cell does not have an eeprom, this field contains data input by the user
     using set_flow_cell_info to record required data.
    
     Only alphanumeric, space, dash and underscore characters are allowed in this field.
    
     Since 1.12
    """

    user_specified_product_code: str = betterproto.string_field(8)
    """
    A product code for the flow cell, which the user can specify.
    
     This should be the code displayed in the shop where the flow cell was bought. Not all
     flow cells have an eeprom, in the event they don't, the user can specify using this id using
     set_flow_cell_info.
    
     Since 1.12
    """

    has_adapter: bool = betterproto.bool_field(9)
    """
    Whether there is a flongle adapter.
    
     If this is true, the adapter_id, channel_count and wells_per_channel fields should all
     provide useful information, even if has_flow_cell is false.
    """

    adapter_id: str = betterproto.string_field(10)
    """
    The unique identifier of an attached flongle adapter.
    
     This should be same as the value printed onto the adapter casing.
    """

    temperature_offset: float = betterproto.float_field(
        11, group="temperature_offset_nullable"
    )
    """
    The temperature offset for the flow cell, returned as an offset in degrees Celsius.
    
     This offset specifies a correction to be applied to ASIC temperature.
     If multiple ASIC temperatures are available from the device, applies to the mean temperature.
    
     Since 1.14
    """

    asic_version: str = betterproto.string_field(12)
    """
    The version of the ASIC contained in the flow cell (if specified by the hardware).
    
     This can be used to determine if the hardware should support certain features
     added to only newer ASICs.
    
     Possible values include: "IA02C", "IA02D", or if the value is not readable on the
     current hardware an empty string is returned.
    
     Since 1.14
    """

    insertion_script_status: "InsertionScriptStatus" = betterproto.enum_field(14)
    """
    If the configuration specifies a script to run when a flow-cell is inserted,
     this shows if it completed successfully.
    
     Since 5.0
    """

    use_count: int = betterproto.uint32_field(15)
    """
    The use count for this flow cell.
    
     Since 5.6
    """

    use_count_limit: int = betterproto.uint32_field(16)
    """
    The advised flow-cell use_count_limit from the configuration.
     This limit will not be enforced by MinKNOW-Core.
    
     Since 5.6
    """

    barcode_kit: str = betterproto.string_field(17)
    """
    The flow cell barcode kit identity
    
     Since 5.6
    """

    barcodes: List[int] = betterproto.uint32_field(18)
    """
    The unique barcodes (as represented by indices between 1 to 384) that have been
     set by calls to register_flow_cell_barcodes() on this flow cell.
     Since 5.6
    """

    flow_cell_partner: str = betterproto.string_field(19)
    """
    The partner the flow cell was produced for.
    
     Some partner companies have flow cells produced specifically for them. If
     so, it will be indicated by this field. Most flow cells will have this
     either unset or set to "ONT".
    
     If this field is set, it will be exactly three characters.
    
     Since 6.0
    """

    is_ctc: bool = betterproto.bool_field(20)
    """
    True if the flow cell is a Configuration Test Cell (CTC).
    
     Note that this is currently set if and only if the cell's
     product ID starts with 'CTC'.
     Detection of CTCs constructed from repurposed standard flow cells
     will be implemented later.
    
     False negatives are to be expected- that is, for all cases where
     this field is 'true', the flow cell is definitely a CTC.
     In cases where it is 'false', the flow cell _may_ be a CTC.
    
     Since 6.0
    """

    incompatible_flow_cell_partner: bool = betterproto.bool_field(21)
    """
    Set to true if the flow cell partner is incompatible with this installation of MinKNOW.
    
     Note that it is possible for this field to be true and for flow_cell_partner to be empty (if
     the installation requires a specific flow cell partner value).
    
     Since 5.6 (China IVD and Q)
    
     NB: this does not appear in the 5.6 OND release, or in RUO releases 5.7, 5.8, 5.9 or 6.0. It
     is available in all 6.2 releases onwards.
    """


@dataclass(eq=False, repr=False)
class StreamFlowCellInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetUserSpecifiedFlowCellIdRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    A unique identifier for the flow cell, which the user can specify.
    
     In the event a flow cell does not have an eeprom, this field can be used by the user
     to record their flow_cell_id.
    
     Since 1.12
    """


@dataclass(eq=False, repr=False)
class SetUserSpecifiedFlowCellIdResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetUserSpecifiedProductCodeRequest(betterproto.Message):
    code: str = betterproto.string_field(1)
    """
    A product code for the flow cell, which the user can specify.
    
     In the event a flow cell does not have an eeprom, the user can specify product code here.
    
     Since 1.12
    """


@dataclass(eq=False, repr=False)
class SetUserSpecifiedProductCodeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetChannelsLayoutRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetChannelsLayoutResponse(betterproto.Message):
    channel_records: List["ChannelRecord"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ChannelRecord(betterproto.Message):
    id: int = betterproto.uint32_field(1)
    name: str = betterproto.string_field(2)
    mux_records: List["ChannelRecordMuxRecord"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ChannelRecordMuxRecord(betterproto.Message):
    id: int = betterproto.uint32_field(1)
    phys_x: int = betterproto.uint32_field(2)
    phys_y: int = betterproto.uint32_field(3)


@dataclass(eq=False, repr=False)
class ResetDeviceSettingsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ResetDeviceSettingsResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetCalibrationRequest(betterproto.Message):
    first_channel: int = betterproto.uint32_field(1)
    """
    The first channel included in calibration data.
    
     This must always be 1. This is required in order to make sure the client and MinKNOW agree on
     what data is being provided.
    """

    last_channel: int = betterproto.uint32_field(2)
    """
    The last channel included in calibration data.
    
     This must always be the same as the channel count returned by
     :meth:`get_flow_cell_info`. This is required in order to make
     sure the client and MinKNOW agree on what data is being provided.
    """

    offsets: List[float] = betterproto.float_field(3)
    """
    The ADC value adjustment to reach 0pA on each channel.
    
     This is ``-x``, where ``x`` is the (mean) ADC value at 0pA.
    """

    pa_ranges: List[float] = betterproto.float_field(4)
    """The range of possible pA values that can be produced by the device."""


@dataclass(eq=False, repr=False)
class SetCalibrationResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ClearCalibrationRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ClearCalibrationResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetCalibrationRequest(betterproto.Message):
    first_channel: int = betterproto.uint32_field(1)
    """
    The first channel to get calibration data for.
    
     This should normally be 1.
    """

    last_channel: int = betterproto.uint32_field(2)
    """
    The last channel included in calibration data.
    
     This should normally be the channel count returned by
     :meth:`get_flow_cell_info`.
    """


@dataclass(eq=False, repr=False)
class GetCalibrationResponse(betterproto.Message):
    digitisation: int = betterproto.uint32_field(1)
    """
    The range of possible ADC values that can be produced by the device.
    
     This is the same as the digitisation value returned by the
     :meth:`DeviceService.get_device_info` RPC. It is included here for convenience.
    """

    offsets: List[float] = betterproto.float_field(2)
    """
    The ADC value adjustment to reach 0pA on each channel.
    
     This is ``-x``, where ``x`` is the (mean) ADC value at 0pA.
    """

    pa_ranges: List[float] = betterproto.float_field(3)
    """
    The range of possible pA values that can be produced on each channel.
    
     The change in pA represented by a change of 1 ADC can be calculated by dividing the
     digitisation by this value.
    """

    has_calibration: bool = betterproto.bool_field(4)
    """
    Find if there is a stored calibration, or if the returned response is empty.
    
     Since 1.12
    """


@dataclass(eq=False, repr=False)
class SetTemperatureRequest(betterproto.Message):
    temperature: float = betterproto.float_field(1)
    """
    The desired temperature in degrees Celsius.
    
     If temperature control is supported and enabled, the device will attempt to keep its
     primary temperature at this value. The reading used as the "primary" temperature depends
     on the device:
     - For MinIONs, the primary temperature is the heatsink temperature
     - For PromethIONs, the primary temperature is the flow cell temperature
    
     (If temperature control is not supported or is not enabled, the call to `set_temperature`
     will fail with `FAILED_PRECONDITION`)
    """

    wait_for_temperature: "SetTemperatureRequestWaitForTemperatureSettings" = (
        betterproto.message_field(2)
    )
    """
    Settings which can be specified in order to wait for the temperature to be reached.
    
     If this is not set at all, no waiting will be done. If it is set (even to an empty
     WaitForTemperatureSettings object), the call will not return until either:
     - The target temperature was reached, or
     - The timeout was reached, or
     - The secondary temperature limits were exceeded
    
     If `wait_for_temperature` is supplied then, on MinIONs and GridIONs, the ASIC power will be
     enabled if it was not already. See `acquisition.StopRequest.keep_power_on` for more details
     about the implications of this.
    
     Since 1.15
    """

    secondary_temperature_limits: "SetTemperatureRequestSecondaryTemperatureLimits" = (
        betterproto.message_field(3)
    )
    """
    Specify "secondary" temperature limits
    
     This field allows limits to be placed on the "secondary" temperature, while waiting for
     the primary temperature to reach its target value (as specified in the `temperature` field,
     above).
    
     The meaning of the "secondary" temperature depends on the device in question:
     - For MinIONs, this is the ASIC temperature (i.e. flow cell or flow cell adapter
       temperature)
     - For PromethIONs, this is the "chamber" temperature (which is derived from the measurements
       of the ASIC temperature)
    
     These limits are intended to act as a safeguard against the case where the flow cell does
     not have good thermal contact with temperature control hardware (e.g. if the flow cell was
     not fully seated when it was inserted into the device). In such cases, the flow cell
     temperature may rise high enough to damage the flow cell; these limits may be used to
     mitigate the risk of the flow cell temperature rising high enough to cause damage to the
     flow cell.
    
     If the secondary temperature exceeds the specified limits while waiting for the target
     temperature to be reached, then all temperature control settings are reset to the values
     they had prior to the call to `set_temperature()` being made.
    
     NB - These limits apply ONLY when waiting for the target temperature to be reached; once the
     call to `set_temperature()` returns, these limits are no longer checked.
    
     Since 5.5
    """


@dataclass(eq=False, repr=False)
class SetTemperatureRequestWaitForTemperatureSettings(betterproto.Message):
    timeout: int = betterproto.uint32_field(1)
    """
    Maximum duration (in seconds) to wait for the device to reach temperature.
    
     Not specifying a value will wait for a maximum of 5 minutes.
    """

    min_stable_duration: int = betterproto.uint32_field(3)
    """
    Minimum duration (in seconds) that the reported temperature must be
     continually within the target temperature range, before the device is
     considered to have reached temperature.
    
     A value of zero means that the device will be considered to have reached temperature
     as soon as the reported temperature is equal to the target temperature.
    
     Not specifying a value is equivalent to specifying a value of zero.
    
     The min_stable_duration must be less than or equal to the timeout duration
     (if it were greater, then the temperature would never be read as 'stable' before
     the time-out occurred).
    
     Since 3.4
    """

    tolerance: float = betterproto.float_field(2)
    """
    Specify an optional tolerance to apply to the wait.
    
     For example, if the target temperature is 35, and the tolerance is 1
     any temperature in the range 34 - 36 will cause the request to return.
    
     Default is 0.5 degree tolerance.
    """


@dataclass(eq=False, repr=False)
class SetTemperatureRequestSecondaryTemperatureLimits(betterproto.Message):
    min: float = betterproto.float_field(1)
    """The minimum permissible "secondary" temperature"""

    max: float = betterproto.float_field(2)
    """The maximum permissible "secondary" temperature"""


@dataclass(eq=False, repr=False)
class SetTemperatureResponse(betterproto.Message):
    timed_out_waiting_for_temperature: bool = betterproto.bool_field(1)
    """
    Find if we hit a timeout waiting for the temperature to be hit.
    
     Deprecated since 5.5; in favour of the `TIMED_OUT_WAITING_FOR_TEMPERATURE` result code.
    """

    result: "SetTemperatureResponseSetTemperatureResult" = betterproto.enum_field(2)
    """
    The result of setting the temperature
    
     Since 5.5
    
     NB - before 5.5, checking this field will always return a value of `TARGET_TEMPERATURE_SET`
     The "real" value may be inferred as follows:
      - If `wait_for_temperature` was NOT specified, the "real" result is
        `TARGET_TEMPERATURE_SET`
      - If `wait_for_temperature` was specified, and `timed_out_waiting_for_temperature` is
        false, the "real" result is `REACHED_TEMPERATURE`
      - If `wait_for_temperature` was specified, and `timed_out_waiting_for_temperature` is
        true, the "real" result is `TIMED_OUT_WAITING_FOR_TEMPERATURE`
      - Versions prior to 5.5 do not support setting the secondary temperature limit, and so (for
        these versions) the "real" value can never be `SECONDARY_TEMPERATURE_LIMITS_EXCEEDED`
    """


@dataclass(eq=False, repr=False)
class GetTemperatureRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetTemperatureResponse(betterproto.Message):
    minion: "GetTemperatureResponseMinIonTemperature" = betterproto.message_field(
        1, group="temperature"
    )
    promethion: "GetTemperatureResponsePromethIonTemperature" = (
        betterproto.message_field(2, group="temperature")
    )
    pebble: "GetTemperatureResponsePebbleTemperature" = betterproto.message_field(
        6, group="temperature"
    )
    target_temperature: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_FLOAT
    )
    """
    Return the temperature target the device is aiming to reach.
    
     Since 1.15
    """

    minion_starting_temperature: Optional[float] = betterproto.message_field(
        4, wraps=betterproto.TYPE_FLOAT, group="starting_temperature"
    )
    promethion_starting_temperature: Optional[float] = betterproto.message_field(
        5, wraps=betterproto.TYPE_FLOAT, group="starting_temperature"
    )
    pebble_starting_temperature: Optional[float] = betterproto.message_field(
        7, wraps=betterproto.TYPE_FLOAT, group="starting_temperature"
    )


@dataclass(eq=False, repr=False)
class GetTemperatureResponseMinIonTemperature(betterproto.Message):
    """Packet of temperatures appropriate for a MinION."""

    asic_temperature: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_FLOAT
    )
    """
    Temperature as measured by the probe inside the asic.
     This is the "secondary" temperature
    """

    heatsink_temperature: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_FLOAT
    )
    """
    Temperature as measured by the probe in the minion heatsink.
     This is the "primary" temperature
    """


@dataclass(eq=False, repr=False)
class GetTemperatureResponsePromethIonTemperature(betterproto.Message):
    """Packet of temperatures appropriate for a PromethION."""

    flowcell_temperature: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_FLOAT
    )
    """
    Temperature as measured by thermistor TH2 on the P-Chip.
     This is the "primary" temperature
    """

    chamber_temperature: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_FLOAT
    )
    """
    Mean of 12 pixel-blocks temperatures measured with sensors in the ASIC.
     This is the "secondary" temperature
    """


@dataclass(eq=False, repr=False)
class GetTemperatureResponsePebbleTemperature(betterproto.Message):
    """Packet of temperatures appropriate for a Pebble"""

    asic_temperature: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_FLOAT
    )
    """
    Temperature as measured by a sensor in the ASIC silicon.
     This is the "primary" temperature.
    """

    instrument_temperature: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_FLOAT
    )
    """
    Temperature as measured by temperature-sensor on the PCB inside the
     instrument, but not on the P-Chip.
     This is the "secondary" temperature.
    """

    pchip_temperature: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_FLOAT
    )
    """
    Temperature as measured by a temperature-sensor on the P-Chip.
     Likely to be removed in future revisions.
    """


@dataclass(eq=False, repr=False)
class StreamTemperatureRequest(betterproto.Message):
    period_seconds: int = betterproto.uint32_field(1)
    """
    How often temperature updates should be sent
     Defaults to a period of 1 second, if not specified, or set to 0
    """


@dataclass(eq=False, repr=False)
class UnblockRequest(betterproto.Message):
    channels: List[int] = betterproto.uint32_field(1)
    """List of channels indexed from 1."""

    duration_in_seconds: int = betterproto.uint32_field(2, group="duration")
    duration_in_milliseconds: int = betterproto.uint32_field(3, group="duration")


@dataclass(eq=False, repr=False)
class UnblockResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CancelUnblocksRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CancelUnblocksResponse(betterproto.Message):
    cancelled_unblocks: int = betterproto.uint32_field(1)
    """
    The number of unblocks which have been cancelled as part of this request.
    
     Should return the total number of unblock operations which have been cancelled.
    """


@dataclass(eq=False, repr=False)
class GetChannelConfigurationRequest(betterproto.Message):
    channels: List[int] = betterproto.uint32_field(1)
    """
    A list of channel names (1-indexed) to specify what channels to get channel configs for
    
     Will return an error if any of the channel names are below 1, or above the channel count value
     returned from :meth:`get_flow_cell_info`
    """


@dataclass(eq=False, repr=False)
class GetChannelConfigurationResponse(betterproto.Message):
    channel_configurations: List["ReturnedChannelConfiguration"] = (
        betterproto.message_field(1)
    )
    """
    A list of channel configurations
    
     The order of channel configurations matches the channel order specified by :attribute:`channels`
     in the request message
    """


@dataclass(eq=False, repr=False)
class SetChannelConfigurationRequest(betterproto.Message):
    channel_configurations: Dict[int, "ChannelConfiguration"] = betterproto.map_field(
        1, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    """
    A map between <channel name, config to set>
    
     Will return an error if any of the key values (representing channel names) are below 1, or
     above the channel count value returned from :meth:`get_flow_cell_info`
    
     The selected well cannot be set to WELL_OTHER, and will error if it tries to do so
    
     DEPRECATED: Note that the type to set may change from 4.0 to enforce the fact that
     unblock cannot be set through this call
    """


@dataclass(eq=False, repr=False)
class SetChannelConfigurationResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetChannelConfigurationAllRequest(betterproto.Message):
    channel_configuration: "ChannelConfiguration" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SetChannelConfigurationAllResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SaturationConfig(betterproto.Message):
    thresholds: "SaturationConfigThresholds" = betterproto.message_field(1)
    """
    Settings for saturation count thresholds, this controls how long a
     saturated value must be over limit before the channel is turned off.
    
     If not specified, the previous thresholds are kept.
    """

    software_saturation: "SaturationConfigSoftwareSaturation" = (
        betterproto.message_field(2)
    )
    """
    Settings for software saturation, specified in adc units of the device.
    
     If not specified, the previous thresholds are kept.
    """

    user_threshold_saturation: "SaturationConfigUserThresholdSaturation" = (
        betterproto.message_field(3)
    )
    """
    Settings for user threshold saturation, specified in pA.
    
     If not specified, the previous thresholds are kept.
    """


@dataclass(eq=False, repr=False)
class SaturationConfigThresholds(betterproto.Message):
    """
    The thresholds define how many over limit samples
     are required to trigger saturation on the device.

     Each packet of frames minknow receive is delivered to the saturation
     check (in approx 64 frame chunks), only the first frame of each packet is inspected.
     The thresholds control how many _packets_ must be outside the valid range.
     ie. if general_threshold is set to 10, at least 640 frames are
     required to trigger saturation.

     It is also possible to not define the value to never
     trigger saturation in this config.
    """

    general_threshold: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT32
    )
    """Threshold for software saturation on all non-unblock muxes"""

    unblock_threshold: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )
    """Threshold for software saturation on unblock muxes"""

    user_general_threshold: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_UINT32
    )
    """Threshold for user threshold  saturation on all non-unblock muxes"""

    user_unblock_threshold: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_UINT32
    )
    """Threshold for user threshold saturation on unblock muxes"""


@dataclass(eq=False, repr=False)
class SaturationConfigSoftwareSaturation(betterproto.Message):
    """
    The ranges specify the actual pA or ADC ranges which will trigger saturation.
     This range is checked against the first sample in each delivered packet.

     software saturation is specified in adc units
    """

    enabled: bool = betterproto.bool_field(1)
    """Set to enable or disable software saturation."""

    software_min_adc: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    """
    The minimum adc value that is not a saturation.
    
     If this value is not specified, the previous value is kept.
    """

    software_max_adc: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    """
    The maximum adc value that is not a saturation.
    
     If this value is not specified, the previous value is kept.
    """


@dataclass(eq=False, repr=False)
class SaturationConfigUserThresholdSaturation(betterproto.Message):
    """User threshold is specified in pico amps"""

    enabled: bool = betterproto.bool_field(1)
    """Set to enable or disable software saturation."""

    user_threshold_min_pa: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_FLOAT
    )
    """
    The minimum pA value that is not a saturation.
    
     If this value is not specified, the previous value is kept.
    """

    user_threshold_max_pa: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_FLOAT
    )
    """
    The maximum pA value that is not a saturation.
    
     If this value is not specified, the previous value is kept.
    """


@dataclass(eq=False, repr=False)
class SetSaturationConfigRequest(betterproto.Message):
    settings: "SaturationConfig" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SetSaturationConfigResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetSaturationConfigRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetSaturationConfigResponse(betterproto.Message):
    settings: "SaturationConfig" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GetSampleRateRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetSampleRateResponse(betterproto.Message):
    sample_rate: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class SetSampleRateRequest(betterproto.Message):
    sample_rate: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class SetSampleRateResponse(betterproto.Message):
    real_sample_rate: int = betterproto.uint32_field(1)
    """
    The real sample rate is the actual sample rate that is set on the device, which
     may be different from the actual value passed into the rpc.
    
     For example on promethion, when it is given a sample rate, it will round to the nearest
     1000. So 1499 becomes 1000 and 1500 becomes 2000 real sample rate
    
     For a minion, the actual sample rate is determined via 3 separate values; clock speed,
     integration time and clock divider, and so not all values are possible. e.g. setting 3000
     will return 3012 real sample rate. See 'sampling_frequency' in MinionDeviceService for a
     slightly more in depth explanation
    """


@dataclass(eq=False, repr=False)
class GetBiasVoltageRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetBiasVoltageResponse(betterproto.Message):
    bias_voltage: float = betterproto.double_field(1)


@dataclass(eq=False, repr=False)
class SetBiasVoltageRequest(betterproto.Message):
    bias_voltage: float = betterproto.double_field(1)


@dataclass(eq=False, repr=False)
class SetBiasVoltageResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DumpStateRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DumpStateResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class IncrementFlowCellUseCountRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class IncrementFlowCellUseCountResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetFlowCellBarcodeKitRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    """The Barcode Kit ID can be up to 8 characters long"""


@dataclass(eq=False, repr=False)
class SetFlowCellBarcodeKitResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RegisterFlowCellBarcodesRequest(betterproto.Message):
    barcodes: List[int] = betterproto.uint32_field(1)
    """
    List of unique barcodes that have been used with the flow-cell
     Where a barcode is represented by an index in the range of 1 to 384 only.
    """


@dataclass(eq=False, repr=False)
class RegisterFlowCellBarcodesResponse(betterproto.Message):
    pass


class DeviceServiceStub(betterproto.ServiceStub):
    async def get_device_info(
        self,
        get_device_info_request: "GetDeviceInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDeviceInfoResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_device_info",
            get_device_info_request,
            GetDeviceInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_device_state(
        self,
        get_device_state_request: "GetDeviceStateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDeviceStateResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_device_state",
            get_device_state_request,
            GetDeviceStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_device_state(
        self,
        stream_device_state_request: "StreamDeviceStateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetDeviceStateResponse]:
        async for response in self._unary_stream(
            "/minknow_api.device.DeviceService/stream_device_state",
            stream_device_state_request,
            GetDeviceStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_flow_cell_info(
        self,
        get_flow_cell_info_request: "GetFlowCellInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetFlowCellInfoResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_flow_cell_info",
            get_flow_cell_info_request,
            GetFlowCellInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_flow_cell_info(
        self,
        stream_flow_cell_info_request: "StreamFlowCellInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetFlowCellInfoResponse]:
        async for response in self._unary_stream(
            "/minknow_api.device.DeviceService/stream_flow_cell_info",
            stream_flow_cell_info_request,
            GetFlowCellInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set_user_specified_flow_cell_id(
        self,
        set_user_specified_flow_cell_id_request: "SetUserSpecifiedFlowCellIdRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetUserSpecifiedFlowCellIdResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_user_specified_flow_cell_id",
            set_user_specified_flow_cell_id_request,
            SetUserSpecifiedFlowCellIdResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_user_specified_product_code(
        self,
        set_user_specified_product_code_request: "SetUserSpecifiedProductCodeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetUserSpecifiedProductCodeResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_user_specified_product_code",
            set_user_specified_product_code_request,
            SetUserSpecifiedProductCodeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_channels_layout(
        self,
        get_channels_layout_request: "GetChannelsLayoutRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetChannelsLayoutResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_channels_layout",
            get_channels_layout_request,
            GetChannelsLayoutResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def reset_device_settings(
        self,
        reset_device_settings_request: "ResetDeviceSettingsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ResetDeviceSettingsResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/reset_device_settings",
            reset_device_settings_request,
            ResetDeviceSettingsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_calibration(
        self,
        set_calibration_request: "SetCalibrationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetCalibrationResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_calibration",
            set_calibration_request,
            SetCalibrationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def clear_calibration(
        self,
        clear_calibration_request: "ClearCalibrationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ClearCalibrationResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/clear_calibration",
            clear_calibration_request,
            ClearCalibrationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_calibration(
        self,
        get_calibration_request: "GetCalibrationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetCalibrationResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_calibration",
            get_calibration_request,
            GetCalibrationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_temperature(
        self,
        set_temperature_request: "SetTemperatureRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetTemperatureResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_temperature",
            set_temperature_request,
            SetTemperatureResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_temperature(
        self,
        get_temperature_request: "GetTemperatureRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetTemperatureResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_temperature",
            get_temperature_request,
            GetTemperatureResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_temperature(
        self,
        stream_temperature_request: "StreamTemperatureRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetTemperatureResponse]:
        async for response in self._unary_stream(
            "/minknow_api.device.DeviceService/stream_temperature",
            stream_temperature_request,
            GetTemperatureResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def unblock(
        self,
        unblock_request: "UnblockRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UnblockResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/unblock",
            unblock_request,
            UnblockResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel_unblocks(
        self,
        cancel_unblocks_request: "CancelUnblocksRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CancelUnblocksResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/cancel_unblocks",
            cancel_unblocks_request,
            CancelUnblocksResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_channel_configuration(
        self,
        get_channel_configuration_request: "GetChannelConfigurationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetChannelConfigurationResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_channel_configuration",
            get_channel_configuration_request,
            GetChannelConfigurationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_channel_configuration(
        self,
        set_channel_configuration_request: "SetChannelConfigurationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetChannelConfigurationResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_channel_configuration",
            set_channel_configuration_request,
            SetChannelConfigurationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_channel_configuration_all(
        self,
        set_channel_configuration_all_request: "SetChannelConfigurationAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetChannelConfigurationAllResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_channel_configuration_all",
            set_channel_configuration_all_request,
            SetChannelConfigurationAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_saturation_config(
        self,
        set_saturation_config_request: "SetSaturationConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetSaturationConfigResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_saturation_config",
            set_saturation_config_request,
            SetSaturationConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_saturation_config(
        self,
        get_saturation_config_request: "GetSaturationConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetSaturationConfigResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_saturation_config",
            get_saturation_config_request,
            GetSaturationConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_sample_rate(
        self,
        get_sample_rate_request: "GetSampleRateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetSampleRateResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_sample_rate",
            get_sample_rate_request,
            GetSampleRateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_sample_rate(
        self,
        set_sample_rate_request: "SetSampleRateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetSampleRateResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_sample_rate",
            set_sample_rate_request,
            SetSampleRateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_bias_voltage(
        self,
        get_bias_voltage_request: "GetBiasVoltageRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetBiasVoltageResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/get_bias_voltage",
            get_bias_voltage_request,
            GetBiasVoltageResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_bias_voltage(
        self,
        set_bias_voltage_request: "SetBiasVoltageRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetBiasVoltageResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_bias_voltage",
            set_bias_voltage_request,
            SetBiasVoltageResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def dump_state(
        self,
        dump_state_request: "DumpStateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DumpStateResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/dump_state",
            dump_state_request,
            DumpStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def increment_flow_cell_use_count(
        self,
        increment_flow_cell_use_count_request: "IncrementFlowCellUseCountRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "IncrementFlowCellUseCountResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/increment_flow_cell_use_count",
            increment_flow_cell_use_count_request,
            IncrementFlowCellUseCountResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_flow_cell_barcode_kit(
        self,
        set_flow_cell_barcode_kit_request: "SetFlowCellBarcodeKitRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetFlowCellBarcodeKitResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/set_flow_cell_barcode_kit",
            set_flow_cell_barcode_kit_request,
            SetFlowCellBarcodeKitResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def register_flow_cell_barcodes(
        self,
        register_flow_cell_barcodes_request: "RegisterFlowCellBarcodesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RegisterFlowCellBarcodesResponse":
        return await self._unary_unary(
            "/minknow_api.device.DeviceService/register_flow_cell_barcodes",
            register_flow_cell_barcodes_request,
            RegisterFlowCellBarcodesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class DeviceServiceBase(ServiceBase):

    async def get_device_info(
        self, get_device_info_request: "GetDeviceInfoRequest"
    ) -> "GetDeviceInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_device_state(
        self, get_device_state_request: "GetDeviceStateRequest"
    ) -> "GetDeviceStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_device_state(
        self, stream_device_state_request: "StreamDeviceStateRequest"
    ) -> AsyncIterator[GetDeviceStateResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetDeviceStateResponse()

    async def get_flow_cell_info(
        self, get_flow_cell_info_request: "GetFlowCellInfoRequest"
    ) -> "GetFlowCellInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_flow_cell_info(
        self, stream_flow_cell_info_request: "StreamFlowCellInfoRequest"
    ) -> AsyncIterator[GetFlowCellInfoResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetFlowCellInfoResponse()

    async def set_user_specified_flow_cell_id(
        self,
        set_user_specified_flow_cell_id_request: "SetUserSpecifiedFlowCellIdRequest",
    ) -> "SetUserSpecifiedFlowCellIdResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_user_specified_product_code(
        self,
        set_user_specified_product_code_request: "SetUserSpecifiedProductCodeRequest",
    ) -> "SetUserSpecifiedProductCodeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_channels_layout(
        self, get_channels_layout_request: "GetChannelsLayoutRequest"
    ) -> "GetChannelsLayoutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def reset_device_settings(
        self, reset_device_settings_request: "ResetDeviceSettingsRequest"
    ) -> "ResetDeviceSettingsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_calibration(
        self, set_calibration_request: "SetCalibrationRequest"
    ) -> "SetCalibrationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def clear_calibration(
        self, clear_calibration_request: "ClearCalibrationRequest"
    ) -> "ClearCalibrationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_calibration(
        self, get_calibration_request: "GetCalibrationRequest"
    ) -> "GetCalibrationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_temperature(
        self, set_temperature_request: "SetTemperatureRequest"
    ) -> "SetTemperatureResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_temperature(
        self, get_temperature_request: "GetTemperatureRequest"
    ) -> "GetTemperatureResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_temperature(
        self, stream_temperature_request: "StreamTemperatureRequest"
    ) -> AsyncIterator[GetTemperatureResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetTemperatureResponse()

    async def unblock(self, unblock_request: "UnblockRequest") -> "UnblockResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_unblocks(
        self, cancel_unblocks_request: "CancelUnblocksRequest"
    ) -> "CancelUnblocksResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_channel_configuration(
        self, get_channel_configuration_request: "GetChannelConfigurationRequest"
    ) -> "GetChannelConfigurationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_channel_configuration(
        self, set_channel_configuration_request: "SetChannelConfigurationRequest"
    ) -> "SetChannelConfigurationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_channel_configuration_all(
        self, set_channel_configuration_all_request: "SetChannelConfigurationAllRequest"
    ) -> "SetChannelConfigurationAllResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_saturation_config(
        self, set_saturation_config_request: "SetSaturationConfigRequest"
    ) -> "SetSaturationConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_saturation_config(
        self, get_saturation_config_request: "GetSaturationConfigRequest"
    ) -> "GetSaturationConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_sample_rate(
        self, get_sample_rate_request: "GetSampleRateRequest"
    ) -> "GetSampleRateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_sample_rate(
        self, set_sample_rate_request: "SetSampleRateRequest"
    ) -> "SetSampleRateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_bias_voltage(
        self, get_bias_voltage_request: "GetBiasVoltageRequest"
    ) -> "GetBiasVoltageResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_bias_voltage(
        self, set_bias_voltage_request: "SetBiasVoltageRequest"
    ) -> "SetBiasVoltageResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def dump_state(
        self, dump_state_request: "DumpStateRequest"
    ) -> "DumpStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def increment_flow_cell_use_count(
        self, increment_flow_cell_use_count_request: "IncrementFlowCellUseCountRequest"
    ) -> "IncrementFlowCellUseCountResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_flow_cell_barcode_kit(
        self, set_flow_cell_barcode_kit_request: "SetFlowCellBarcodeKitRequest"
    ) -> "SetFlowCellBarcodeKitResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def register_flow_cell_barcodes(
        self, register_flow_cell_barcodes_request: "RegisterFlowCellBarcodesRequest"
    ) -> "RegisterFlowCellBarcodesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_device_info(
        self,
        stream: "grpclib.server.Stream[GetDeviceInfoRequest, GetDeviceInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_device_info(request)
        await stream.send_message(response)

    async def __rpc_get_device_state(
        self,
        stream: "grpclib.server.Stream[GetDeviceStateRequest, GetDeviceStateResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_device_state(request)
        await stream.send_message(response)

    async def __rpc_stream_device_state(
        self,
        stream: "grpclib.server.Stream[StreamDeviceStateRequest, GetDeviceStateResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_device_state,
            stream,
            request,
        )

    async def __rpc_get_flow_cell_info(
        self,
        stream: "grpclib.server.Stream[GetFlowCellInfoRequest, GetFlowCellInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_flow_cell_info(request)
        await stream.send_message(response)

    async def __rpc_stream_flow_cell_info(
        self,
        stream: "grpclib.server.Stream[StreamFlowCellInfoRequest, GetFlowCellInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_flow_cell_info,
            stream,
            request,
        )

    async def __rpc_set_user_specified_flow_cell_id(
        self,
        stream: "grpclib.server.Stream[SetUserSpecifiedFlowCellIdRequest, SetUserSpecifiedFlowCellIdResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_user_specified_flow_cell_id(request)
        await stream.send_message(response)

    async def __rpc_set_user_specified_product_code(
        self,
        stream: "grpclib.server.Stream[SetUserSpecifiedProductCodeRequest, SetUserSpecifiedProductCodeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_user_specified_product_code(request)
        await stream.send_message(response)

    async def __rpc_get_channels_layout(
        self,
        stream: "grpclib.server.Stream[GetChannelsLayoutRequest, GetChannelsLayoutResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_channels_layout(request)
        await stream.send_message(response)

    async def __rpc_reset_device_settings(
        self,
        stream: "grpclib.server.Stream[ResetDeviceSettingsRequest, ResetDeviceSettingsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.reset_device_settings(request)
        await stream.send_message(response)

    async def __rpc_set_calibration(
        self,
        stream: "grpclib.server.Stream[SetCalibrationRequest, SetCalibrationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_calibration(request)
        await stream.send_message(response)

    async def __rpc_clear_calibration(
        self,
        stream: "grpclib.server.Stream[ClearCalibrationRequest, ClearCalibrationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.clear_calibration(request)
        await stream.send_message(response)

    async def __rpc_get_calibration(
        self,
        stream: "grpclib.server.Stream[GetCalibrationRequest, GetCalibrationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_calibration(request)
        await stream.send_message(response)

    async def __rpc_set_temperature(
        self,
        stream: "grpclib.server.Stream[SetTemperatureRequest, SetTemperatureResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_temperature(request)
        await stream.send_message(response)

    async def __rpc_get_temperature(
        self,
        stream: "grpclib.server.Stream[GetTemperatureRequest, GetTemperatureResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_temperature(request)
        await stream.send_message(response)

    async def __rpc_stream_temperature(
        self,
        stream: "grpclib.server.Stream[StreamTemperatureRequest, GetTemperatureResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_temperature,
            stream,
            request,
        )

    async def __rpc_unblock(
        self, stream: "grpclib.server.Stream[UnblockRequest, UnblockResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.unblock(request)
        await stream.send_message(response)

    async def __rpc_cancel_unblocks(
        self,
        stream: "grpclib.server.Stream[CancelUnblocksRequest, CancelUnblocksResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel_unblocks(request)
        await stream.send_message(response)

    async def __rpc_get_channel_configuration(
        self,
        stream: "grpclib.server.Stream[GetChannelConfigurationRequest, GetChannelConfigurationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_channel_configuration(request)
        await stream.send_message(response)

    async def __rpc_set_channel_configuration(
        self,
        stream: "grpclib.server.Stream[SetChannelConfigurationRequest, SetChannelConfigurationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_channel_configuration(request)
        await stream.send_message(response)

    async def __rpc_set_channel_configuration_all(
        self,
        stream: "grpclib.server.Stream[SetChannelConfigurationAllRequest, SetChannelConfigurationAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_channel_configuration_all(request)
        await stream.send_message(response)

    async def __rpc_set_saturation_config(
        self,
        stream: "grpclib.server.Stream[SetSaturationConfigRequest, SetSaturationConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_saturation_config(request)
        await stream.send_message(response)

    async def __rpc_get_saturation_config(
        self,
        stream: "grpclib.server.Stream[GetSaturationConfigRequest, GetSaturationConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_saturation_config(request)
        await stream.send_message(response)

    async def __rpc_get_sample_rate(
        self,
        stream: "grpclib.server.Stream[GetSampleRateRequest, GetSampleRateResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_sample_rate(request)
        await stream.send_message(response)

    async def __rpc_set_sample_rate(
        self,
        stream: "grpclib.server.Stream[SetSampleRateRequest, SetSampleRateResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_sample_rate(request)
        await stream.send_message(response)

    async def __rpc_get_bias_voltage(
        self,
        stream: "grpclib.server.Stream[GetBiasVoltageRequest, GetBiasVoltageResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_bias_voltage(request)
        await stream.send_message(response)

    async def __rpc_set_bias_voltage(
        self,
        stream: "grpclib.server.Stream[SetBiasVoltageRequest, SetBiasVoltageResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_bias_voltage(request)
        await stream.send_message(response)

    async def __rpc_dump_state(
        self, stream: "grpclib.server.Stream[DumpStateRequest, DumpStateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.dump_state(request)
        await stream.send_message(response)

    async def __rpc_increment_flow_cell_use_count(
        self,
        stream: "grpclib.server.Stream[IncrementFlowCellUseCountRequest, IncrementFlowCellUseCountResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.increment_flow_cell_use_count(request)
        await stream.send_message(response)

    async def __rpc_set_flow_cell_barcode_kit(
        self,
        stream: "grpclib.server.Stream[SetFlowCellBarcodeKitRequest, SetFlowCellBarcodeKitResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_flow_cell_barcode_kit(request)
        await stream.send_message(response)

    async def __rpc_register_flow_cell_barcodes(
        self,
        stream: "grpclib.server.Stream[RegisterFlowCellBarcodesRequest, RegisterFlowCellBarcodesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.register_flow_cell_barcodes(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.device.DeviceService/get_device_info": grpclib.const.Handler(
                self.__rpc_get_device_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDeviceInfoRequest,
                GetDeviceInfoResponse,
            ),
            "/minknow_api.device.DeviceService/get_device_state": grpclib.const.Handler(
                self.__rpc_get_device_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDeviceStateRequest,
                GetDeviceStateResponse,
            ),
            "/minknow_api.device.DeviceService/stream_device_state": grpclib.const.Handler(
                self.__rpc_stream_device_state,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamDeviceStateRequest,
                GetDeviceStateResponse,
            ),
            "/minknow_api.device.DeviceService/get_flow_cell_info": grpclib.const.Handler(
                self.__rpc_get_flow_cell_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetFlowCellInfoRequest,
                GetFlowCellInfoResponse,
            ),
            "/minknow_api.device.DeviceService/stream_flow_cell_info": grpclib.const.Handler(
                self.__rpc_stream_flow_cell_info,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamFlowCellInfoRequest,
                GetFlowCellInfoResponse,
            ),
            "/minknow_api.device.DeviceService/set_user_specified_flow_cell_id": grpclib.const.Handler(
                self.__rpc_set_user_specified_flow_cell_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetUserSpecifiedFlowCellIdRequest,
                SetUserSpecifiedFlowCellIdResponse,
            ),
            "/minknow_api.device.DeviceService/set_user_specified_product_code": grpclib.const.Handler(
                self.__rpc_set_user_specified_product_code,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetUserSpecifiedProductCodeRequest,
                SetUserSpecifiedProductCodeResponse,
            ),
            "/minknow_api.device.DeviceService/get_channels_layout": grpclib.const.Handler(
                self.__rpc_get_channels_layout,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetChannelsLayoutRequest,
                GetChannelsLayoutResponse,
            ),
            "/minknow_api.device.DeviceService/reset_device_settings": grpclib.const.Handler(
                self.__rpc_reset_device_settings,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResetDeviceSettingsRequest,
                ResetDeviceSettingsResponse,
            ),
            "/minknow_api.device.DeviceService/set_calibration": grpclib.const.Handler(
                self.__rpc_set_calibration,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetCalibrationRequest,
                SetCalibrationResponse,
            ),
            "/minknow_api.device.DeviceService/clear_calibration": grpclib.const.Handler(
                self.__rpc_clear_calibration,
                grpclib.const.Cardinality.UNARY_UNARY,
                ClearCalibrationRequest,
                ClearCalibrationResponse,
            ),
            "/minknow_api.device.DeviceService/get_calibration": grpclib.const.Handler(
                self.__rpc_get_calibration,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetCalibrationRequest,
                GetCalibrationResponse,
            ),
            "/minknow_api.device.DeviceService/set_temperature": grpclib.const.Handler(
                self.__rpc_set_temperature,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetTemperatureRequest,
                SetTemperatureResponse,
            ),
            "/minknow_api.device.DeviceService/get_temperature": grpclib.const.Handler(
                self.__rpc_get_temperature,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetTemperatureRequest,
                GetTemperatureResponse,
            ),
            "/minknow_api.device.DeviceService/stream_temperature": grpclib.const.Handler(
                self.__rpc_stream_temperature,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamTemperatureRequest,
                GetTemperatureResponse,
            ),
            "/minknow_api.device.DeviceService/unblock": grpclib.const.Handler(
                self.__rpc_unblock,
                grpclib.const.Cardinality.UNARY_UNARY,
                UnblockRequest,
                UnblockResponse,
            ),
            "/minknow_api.device.DeviceService/cancel_unblocks": grpclib.const.Handler(
                self.__rpc_cancel_unblocks,
                grpclib.const.Cardinality.UNARY_UNARY,
                CancelUnblocksRequest,
                CancelUnblocksResponse,
            ),
            "/minknow_api.device.DeviceService/get_channel_configuration": grpclib.const.Handler(
                self.__rpc_get_channel_configuration,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetChannelConfigurationRequest,
                GetChannelConfigurationResponse,
            ),
            "/minknow_api.device.DeviceService/set_channel_configuration": grpclib.const.Handler(
                self.__rpc_set_channel_configuration,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetChannelConfigurationRequest,
                SetChannelConfigurationResponse,
            ),
            "/minknow_api.device.DeviceService/set_channel_configuration_all": grpclib.const.Handler(
                self.__rpc_set_channel_configuration_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetChannelConfigurationAllRequest,
                SetChannelConfigurationAllResponse,
            ),
            "/minknow_api.device.DeviceService/set_saturation_config": grpclib.const.Handler(
                self.__rpc_set_saturation_config,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetSaturationConfigRequest,
                SetSaturationConfigResponse,
            ),
            "/minknow_api.device.DeviceService/get_saturation_config": grpclib.const.Handler(
                self.__rpc_get_saturation_config,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSaturationConfigRequest,
                GetSaturationConfigResponse,
            ),
            "/minknow_api.device.DeviceService/get_sample_rate": grpclib.const.Handler(
                self.__rpc_get_sample_rate,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSampleRateRequest,
                GetSampleRateResponse,
            ),
            "/minknow_api.device.DeviceService/set_sample_rate": grpclib.const.Handler(
                self.__rpc_set_sample_rate,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetSampleRateRequest,
                SetSampleRateResponse,
            ),
            "/minknow_api.device.DeviceService/get_bias_voltage": grpclib.const.Handler(
                self.__rpc_get_bias_voltage,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetBiasVoltageRequest,
                GetBiasVoltageResponse,
            ),
            "/minknow_api.device.DeviceService/set_bias_voltage": grpclib.const.Handler(
                self.__rpc_set_bias_voltage,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetBiasVoltageRequest,
                SetBiasVoltageResponse,
            ),
            "/minknow_api.device.DeviceService/dump_state": grpclib.const.Handler(
                self.__rpc_dump_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                DumpStateRequest,
                DumpStateResponse,
            ),
            "/minknow_api.device.DeviceService/increment_flow_cell_use_count": grpclib.const.Handler(
                self.__rpc_increment_flow_cell_use_count,
                grpclib.const.Cardinality.UNARY_UNARY,
                IncrementFlowCellUseCountRequest,
                IncrementFlowCellUseCountResponse,
            ),
            "/minknow_api.device.DeviceService/set_flow_cell_barcode_kit": grpclib.const.Handler(
                self.__rpc_set_flow_cell_barcode_kit,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetFlowCellBarcodeKitRequest,
                SetFlowCellBarcodeKitResponse,
            ),
            "/minknow_api.device.DeviceService/register_flow_cell_barcodes": grpclib.const.Handler(
                self.__rpc_register_flow_cell_barcodes,
                grpclib.const.Cardinality.UNARY_UNARY,
                RegisterFlowCellBarcodesRequest,
                RegisterFlowCellBarcodesResponse,
            ),
        }
