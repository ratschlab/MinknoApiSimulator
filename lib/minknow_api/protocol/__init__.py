# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/protocol.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    acquisition as _acquisition__,
    analysis_workflows as _analysis_workflows__,
    basecaller as _basecaller__,
    device as _device__,
    protocol_settings as _protocol_settings__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ProtocolState(betterproto.Enum):
    PROTOCOL_RUNNING = 0
    """The protocol is still running."""

    PROTOCOL_WAITING_FOR_TEMPERATURE = 4
    """
    The protocol is waiting for the device to reach temperature
    
     Since 1.15
    """

    PROTOCOL_WAITING_FOR_ACQUISITION = 5
    """
    Occurs when data protocol has stopped (either from a explicit rpc request or the script naturally ended)
     and data is still being processed (basecalling is still in catchup and processing reads).
    """

    PROTOCOL_COMPLETED = 1
    """
    The protocol finished on its own and did not report an error.
    
     This is determined by the protocol process exiting with a zero exit code.
    """

    PROTOCOL_STOPPED_BY_USER = 2
    """The protocol was terminated by the user."""

    PROTOCOL_FINISHED_WITH_ERROR = 3
    """
    The protocol finished on its own and reported an error.
    
     This is determined by the protocol process exiting with a non-zero exit code or because of a
     signal. Often, this will be because an exception was raised in the Python code and not
     caught, but could also indicate that the Python process crashed or was killed by some
     mechanism other than by MinKNOW.
    """

    PROTOCOL_FINISHED_WITH_DEVICE_ERROR = 6
    """
    The protocol was terminated because the sequencing device encountered an error.
    """

    PROTOCOL_FINISHED_UNABLE_TO_SEND_TELEMETRY = 7
    """
    The protocol was terminated because MinKNOW could not send telemetry to start acquisition.
    """

    PROTOCOL_FINISHED_WITH_FLOW_CELL_DISCONNECT = 8
    """The protocol was terminated because the flow cell was disconnected"""

    PROTOCOL_FINISHED_WITH_DEVICE_DISCONNECT = 9
    """The protocol was terminated because the device was disconnected"""

    PROTOCOL_FINISHED_WITH_ERROR_CALIBRATION = 20
    """The protocol has reported an error during calibration"""

    PROTOCOL_FINISHED_WITH_ERROR_BASECALL_SETTINGS = 21
    """Setting basecall settings failed (Bad config etc)"""

    PROTOCOL_FINISHED_WITH_ERROR_TEMPERATURE_REQUIRED = 22
    """OND requires us to reach temperature and fail if not"""

    PROTOCOL_FINISHED_WITH_ERROR_NO_DISK_SPACE = 23
    """The protocol was terminated due to insufficient disk space"""

    PROTOCOL_FINISHED_WITH_ERROR_TEMPERATURE_HIGH = 25
    """
    The protocol was terminated due to a high temperature issue
     Since 5.9
    """

    PROTOCOL_FINISHED_WITH_ERROR_BASECALLER_COMMUNICATION = 26
    """
    The protocol was terminated due to an issue with
     communications with the basecaller
     Since 5.9
    """

    PROTOCOL_FINISHED_WITH_NO_FLOWCELL_FOR_ACQUISITION = 27
    """
    There is no flowecll available to run acquisition.
     Since 6.0
    """

    PROTOCOL_FINISHED_WITH_ERROR_BASECALLER_UNAVAILABLE = 28
    """
    The basecaller did not respond to a request before timeout.
     Since 6.0
    """


class ProtocolPhase(betterproto.Enum):
    PHASE_UNKNOWN = 0
    """The protocol has not reported what phase it is in."""

    PHASE_INITIALISING = 1
    """
    The protocol is calibrating, or performing other initialisation tasks.
    """

    PHASE_SEQUENCING = 2
    """The protocol is sequencing."""

    PHASE_PREPARING_FOR_MUX_SCAN = 3
    """The protocol is setting up to perform a mux scan."""

    PHASE_MUX_SCAN = 4
    """
    The protocol is performing a mux scan. This checks whether to switch channels to different
     wells (muxes) in order to improve and maintain sequencing performance.
    """

    PHASE_PAUSED = 5
    """
    The protocol is paused.
    
     When the protocol is resumed, it is likely to enter the PHASE_RESUMING state before moving to
     another state (such as PHASE_SEQUENCING).
    """

    PHASE_PAUSING = 6
    """
    The protocol is in the process of pausing.
    
     It should move into PHASE_PAUSED within a short time.
    """

    PHASE_BAD_TEMPERATURE_AUTOMATIC_PAUSE = 8
    """
    The protocol is paused due to high temperature
    
     The user will have to confirm if they want to proceed with sequencing before resuming
    """

    PHASE_RESUMING = 7
    """
    The protocol is in the process of resuming from a paused state.
    
     It should move into another phase, such as PHASE_SEQUENCING or PHASE_PREPARING_FOR_MUX_SCAN,
     in a short time.
    """

    PHASE_COMPLETED = 9
    """When the protocol is completed"""


class Action(betterproto.Enum):
    NONE = 0
    """No action is requested."""

    PAUSE = 1
    """
    The protocol should pause.
    
     This will only be sent if the can_pause capability has been set to true by a request
     in the current call to protocol_phase_management().
    
     If the protocol is already pausing or paused, this message should be ignored.
     Otherwise, the protocol should immediately respond with a ProtocolPhaseManagementRequest
     that sets the phase to PHASE_PAUSING or PHASE_PAUSED.
    """

    RESUME = 2
    """
    The protocol should resume.
    
     This will only be sent if the can_pause capability has been set to true by a request
     in the current call to protocol_phase_management().
    
     If the protocol is not pausing or paused, this message should be ignored.
     Otherwise, the protocol should immediately respond with a ProtocolPhaseManagementRequest
     that sets the phase appropriated (eg: to PHASE_RESUMING).
    """

    TRIGGER_MUX_SCAN = 3
    """
    The protocol should trigger a mux scan.
    
     This will only be sent if the can_trigger_mux_scan capability has been set to true by a
     request in the current call to protocol_phase_management().
    
     If the protocol is already performing (or preparing for) a mux scan, this message should be
     ignored. Otherwise, the protocol should immediately respond with a
     ProtocolPhaseManagementRequest that sets the phase to PHASE_PREPARING_FOR_MUX_SCAN or
     PHASE_MUX_SCAN.
    """


class BarcodeUserDataSampleType(betterproto.Enum):
    test_sample = 0
    """The barcode sample is a real sample being tested."""

    positive_control = 1
    """
    The barcode sample is a control which is expected to result in positive identification.
    """

    negative_control = 2
    """
    The barcode sample is a control which is expected to result in negative identification.
    """

    no_template_control = 3
    """
    Intended to show that a result has not occurred due to contamination.
    """

    positive_control_1 = 4
    """Separate positive controls for when kits expect 2."""

    positive_control_2 = 5
    """Separate positive controls for when kits expect 2."""


class AnalysisWorkflowRequestWhen(betterproto.Enum):
    PROTOCOL_END = 0
    """Start the analysis workflow at the end of the protocol"""


class WaitForFinishedRequestNotificationState(betterproto.Enum):
    NOTIFY_ON_TERMINATION = 0
    """
    Request return just after the protocol has terminated, including any acquisition periods completing.
    """

    NOTIFY_BEFORE_TERMINATION = 1
    """
    Request return prior to the script being terminated.
     note: will try to return 5s before killing the protocol script.
    """

    NOTIFY_ON_SCRIPT_TERMINATION = 2
    """
    Notify as the protocol script finishes, not waiting for any in progress acquisition to complete.
    """


class AssociatedPostProcessingAnalysisState(betterproto.Enum):
    QUEUED = 0
    """Analysis request queued for starting later"""

    STARTED = 1
    """Workflow successfully started"""

    FAILED_TO_START = 2
    """Trying to start the workflow resulted in an error"""


class HardwareCheckResultHardwareCheckStatus(betterproto.Enum):
    None_ = 0
    """Not a hardware check protocol"""

    Started = 1
    """Hardware check has been started, but has not yet completed"""

    Succeeded = 2
    """Hardware check succeeded"""

    Failed = 3
    """
    Hardware check failed
     See HardwareCheckFailureReason for the reason
    """


class HardwareCheckResultHardwareCheckFailureReason(betterproto.Enum):
    NoError = 0
    """
    Not a hardware check protocol, or
     Hardware check has not failed
    """

    Unknown = 1
    """Hardware check failed for a reason that is not otherwise specified"""

    ScriptError = 2
    """
    The hardware check script failed, and was unable to set the HardwareCheckFailureReason
     to a more specific value
    """


class GetVersionInfoResponseDistributionStatus(betterproto.Enum):
    UNKNOWN = 0
    STABLE = 1
    UNSTABLE = 2
    """it was distributed."""

    MODIFIED = 3
    """
    been fully tested, but has not been modified from how it
     was distributed.
    """


class GetVersionInfoResponseInstallationType(betterproto.Enum):
    ONT = 0
    """For internal release. production.proto will be enabled for this type"""

    NC = 1
    """For customer releases"""

    PROD = 2
    """
    For production release. production.proto will be enabled for this type
    """

    Q_RELEASE = 3
    """For Q releases (nanopore long term support release)"""

    OND_RELEASE = 4
    """Oxford Nanopore Diagnostic"""


class AnalysisWorkflowInfoStatus(betterproto.Enum):
    UNKNOWN = 0
    """
    The default state if nothing has been set. Typically will never be set
    """

    QUEUED = 6
    """
    When a workflow is waiting to start
    
     This can be due to waiting for sequencing (including basecalling) to
     finish or waiting for more resources on the system to free up so that the
     workflow can run without issues
    """

    RUNNING = 1
    """When the analysis workflow has been started and is currently running"""

    COMPLETED = 2
    """
    The workflow has completed successfully
    
     NB: This just means that the workflow ran to completion, and doesn't reflect the
     final result of the workflow
    """

    STOPPED_BY_USER = 3
    """The workflow was stopped prematurely by the user"""

    STOPPED_WITH_ERROR = 4
    """
    The workflow was stopped due to an error that the workflow could not recover from
    """

    FAILED_TO_START = 5
    """
    The workflow failed to start entirely
    
     This can happen if MinKNOW fails to make a connection to the analysis workflow server
    """


@dataclass(eq=False, repr=False)
class BarcodeUserData(betterproto.Message):
    barcode_name: str = betterproto.string_field(1)
    """
    Barcode name the user data applies to, eg: "barcode02".
    
     Acts as the external barcode name `barcode_name_internal` is
     also set for dual barcoding
    """

    barcode_name_internal: str = betterproto.string_field(5)
    """The internal barcode name if using dual barcode"""

    lamp_barcode_id: str = betterproto.string_field(2)
    """
    Lamp barcode id the user data applies to, eg: "FIP04"
    
     DEPRECATED 6.0: Lamp support has been removed and this value will always be empty.
    """

    alias: str = betterproto.string_field(3)
    """User defined string alias for the barcode."""

    type: "BarcodeUserDataSampleType" = betterproto.enum_field(4)
    """Sample type grouping for the barcode."""

    passenger_info: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """Extra context per barcode"""


@dataclass(eq=False, repr=False)
class KitInfo(betterproto.Message):
    sequencing_kit: str = betterproto.string_field(1)
    """The sequencing kit used to select the protocol e.g. "SQK-LSK108"""

    barcode_expansion_kits: List[str] = betterproto.string_field(2)
    """
    The expansion barcoding kits that the protocol supports e.g. "EXP-NBD104"
    """


@dataclass(eq=False, repr=False)
class ProtocolRunUserInfo(betterproto.Message):
    protocol_group_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    The group which the experiment should be held in.
    
     note: This value could be unset if a user did not specify a group_id when starting the protocol.
    """

    sample_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """sample_id created by the user"""

    barcode_user_info: List["BarcodeUserData"] = betterproto.message_field(3)
    """User supplied info for barcodes"""

    user_specified_flow_cell_id: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """user_specified_flow_cell_id created by the user"""

    user_specified_product_code: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """user_specified_product_code created by the user"""

    kit_info: "KitInfo" = betterproto.message_field(6)
    """Kit information the user requested"""


@dataclass(eq=False, repr=False)
class OffloadLocationInfo(betterproto.Message):
    offload_location_ids: List[str] = betterproto.string_field(1)
    """
    Data offload locations to use to store protocol data, specified using their `location_id`.
    
     Valid `location_id`s can be retrieved using mooneye.offload_manager.list_offload_locations()
    
     If any `offload_location_ids` are specified, then:
       - Data is not stored locally
       - `offload_location_path` must NOT be set (or must be set to an empty value)
          - The `offload_location_ids` indicate that data should be offloaded, rather than
            stored locally; the `offload_location_path` is used to set a local storage location.
          - If both are set, an error is returned
    
     This requires a running instance of Mooneye
    
     Since 5.0.
    """

    offload_location_path: str = betterproto.string_field(2)
    """
    Local, e.g., internal / external drive, paths to where the protocol output will be stored.
    
     This setting overrides the default output locations (as set through configuration files
     and/or the instance service).
    
     If `offload_location_path` is set to a non-empty value, then:
      -  `offload_location_ids` MUST be empty
          - The `offload_location_ids` indicate that data should be offloaded, rather than
            stored locally; the `offload_location_path` is used to set a local storage location.
          - If both are set, an error is returned
    
     This does not require a running instance of Mooneye
    
     Since 5.0
    """


@dataclass(eq=False, repr=False)
class AnalysisWorkflowRequest(betterproto.Message):
    proxy_request: "_analysis_workflows__.ProxyRequest" = betterproto.message_field(1)
    """The workflow request to start"""

    when: "AnalysisWorkflowRequestWhen" = betterproto.enum_field(2)
    """When to start the request"""


@dataclass(eq=False, repr=False)
class StartProtocolRequest(betterproto.Message):
    identifier: str = betterproto.string_field(1)
    """The identifier of the protocol, as provided by list_protocols()."""

    args: List[str] = betterproto.string_field(2)
    """The arguments to pass to the protocol."""

    user_info: "ProtocolRunUserInfo" = betterproto.message_field(3)
    """User input describing the protocol."""

    offload_location_info: "OffloadLocationInfo" = betterproto.message_field(4)
    """
    Information about data offload locations to use to store data
    
     Since 5.0.
    """

    target_run_until_criteria: "_acquisition__.TargetRunUntilCriteria" = (
        betterproto.message_field(5)
    )
    """
    Initial Target Run-Until Criteria to use when starting an acquisition for this protocol.
     These can be updated during the acquisition using the Run-Until API.
    
     Since 5.3
    """

    analysis_workflow_request: "AnalysisWorkflowRequest" = betterproto.message_field(7)
    """
    Workflow request that should be started when the protocol is started
    
     EXPERIMENTAL: This field may change or be removed between minor versions without warning
    """


@dataclass(eq=False, repr=False)
class StartProtocolResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    UUID generated when the protocol is started, to uniquely represent this protocol instance
    """


@dataclass(eq=False, repr=False)
class StopProtocolRequest(betterproto.Message):
    data_action_on_stop: "_acquisition__.StopRequestDataAction" = (
        betterproto.enum_field(1)
    )
    """
    Specify how any running acquisition should
     be handled when stopping the protocol.
    
     Protocol state will enter PROTOCOL_WAITING_FOR_ACQUISITION whilst any running
     acquisition is finished.
    
     If a script ends on its own any analysis that was started is stopped, and it
     is allowed to catchup. If the caller wants to end catchup they can call stop_protocol
     to end catchup.
    
     Since 1.15
    """


@dataclass(eq=False, repr=False)
class StopProtocolResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class PauseProtocolRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class PauseProtocolResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ResumeProtocolRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ResumeProtocolResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class TriggerMuxScanRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class TriggerMuxScanResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListProtocolsRequest(betterproto.Message):
    force_reload: bool = betterproto.bool_field(1)
    """
    If this is false, then will try to use the cached value of the protocol list where possible
     (still subject to changes in flow cell).
     If this is true, then will force a reload of the protocol list
    
     Defaults to false
    """


@dataclass(eq=False, repr=False)
class ProtocolInfo(betterproto.Message):
    identifier: str = betterproto.string_field(1)
    tags: Dict[str, "ProtocolInfoTagValue"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    name: str = betterproto.string_field(3)
    tag_extraction_result: "ProtocolInfoTagExtractionResult" = (
        betterproto.message_field(4)
    )


@dataclass(eq=False, repr=False)
class ProtocolInfoTagValue(betterproto.Message):
    string_value: str = betterproto.string_field(1, group="tag_value")
    bool_value: bool = betterproto.bool_field(2, group="tag_value")
    int_value: int = betterproto.int64_field(3, group="tag_value")
    double_value: float = betterproto.double_field(4, group="tag_value")
    array_value: str = betterproto.string_field(5, group="tag_value")
    object_value: str = betterproto.string_field(6, group="tag_value")


@dataclass(eq=False, repr=False)
class ProtocolInfoTagExtractionResult(betterproto.Message):
    success: bool = betterproto.bool_field(1)
    error_report: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ListProtocolsResponse(betterproto.Message):
    protocols: List["ProtocolInfo"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class WaitForFinishedRequest(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """Only consider a specific protocol run."""

    state: "WaitForFinishedRequestNotificationState" = betterproto.enum_field(2)
    """
    Control what to wait for.
    
     Specifying NOTIFY_BEFORE_TERMINATION allows a caller to be notified the script will be ended _soon_,
     and do final work to end cleanly.
    
     Since 1.11
    """

    timeout: float = betterproto.float_field(3)
    """
    Timeout to wait for finished, if the timeout expires before the protocol is complete (in the state requested)
     then the response returns.
    
     By default the timeout will wait forever.
    
     Since 1.15
    """


@dataclass(eq=False, repr=False)
class GetRunInfoRequest(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """The protocol run to get information about."""


@dataclass(eq=False, repr=False)
class RequestOrigin(betterproto.Message):
    user: "RequestOriginUser" = betterproto.message_field(1, group="origin")
    minknow: "RequestOriginMinKnow" = betterproto.message_field(2, group="origin")
    protocol_phase_management: "RequestOriginProtocolPhaseManagement" = (
        betterproto.message_field(3, group="origin")
    )
    run_until: "RequestOriginRunUntil" = betterproto.message_field(4, group="origin")


@dataclass(eq=False, repr=False)
class RequestOriginUser(betterproto.Message):
    """
    'User' based changes will typically come from calls made by the UI
     such as 'stop_protocol'
    """

    identity: str = betterproto.string_field(1)
    """
    If available then provide any identity information MinKNOW
     has about the client that made the RPC request
    """


@dataclass(eq=False, repr=False)
class RequestOriginMinKnow(betterproto.Message):
    """
    A request from minknow will usually come in the form of something ending
     naturally, or an error occurring where minknow has to take action
    """

    cause: str = betterproto.string_field(1)
    """Optional further details on the cause of the request"""


@dataclass(eq=False, repr=False)
class RequestOriginProtocolPhaseManagement(betterproto.Message):
    """
    The protocol script/bream is mainly responsible for making changes via
     protocol_phase_management
    """

    pass


@dataclass(eq=False, repr=False)
class RequestOriginRunUntil(betterproto.Message):
    """
    A request made by the run until script due to certain criteria being met
    """

    criteria: str = betterproto.string_field(1)
    """What criteria caused the state change"""


@dataclass(eq=False, repr=False)
class ProtocolPhaseSnapshot(betterproto.Message):
    phase: "ProtocolPhase" = betterproto.enum_field(1)
    """The new protocol phase when the phase request happened"""

    timestamp: datetime = betterproto.message_field(2)
    """UTC timestamp of when the protocol phase changed was requested"""

    origin: "RequestOrigin" = betterproto.message_field(3)
    """
    Who requested the phase change
    
     Candidates:
      ProtocolPhaseMangement: Through protocol_phase_management API
      MinKNOW: When the protocol ends and the phase is marked PHASE_COMPLETED
    """


@dataclass(eq=False, repr=False)
class Epi2MeWorkflowReference(betterproto.Message):
    id: int = betterproto.int64_field(1)
    """
    The unique identifier for a workflow ( unique to a specific instance of epi2me )
    """

    url: str = betterproto.string_field(2)
    """
    URL that links to the workflow report. Syntax for a local workflow: file:// otherwise: http(s)://
    """


@dataclass(eq=False, repr=False)
class AssociatedPostProcessingAnalysis(betterproto.Message):
    started_id: str = betterproto.string_field(1)
    """Id of analysis if this has been triggered (otherwise empty)."""

    start_request: "_basecaller__.StartRequest" = betterproto.message_field(2)
    """Start request for analysis"""

    state: "AssociatedPostProcessingAnalysisState" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class PlatformQcResult(betterproto.Message):
    flow_cell_id: str = betterproto.string_field(1)
    """The flow cell id that the pqc was performed for"""

    passed: bool = betterproto.bool_field(2)
    """Whether the flow cell passed the platform qc check"""

    total_pore_count: int = betterproto.uint32_field(3)
    """
    Total number of pores that were found on the flow cell, across all muxes.
    """


@dataclass(eq=False, repr=False)
class HardwareCheckResult(betterproto.Message):
    status: "HardwareCheckResultHardwareCheckStatus" = betterproto.enum_field(1)
    failure_reason: "HardwareCheckResultHardwareCheckFailureReason" = (
        betterproto.enum_field(2)
    )
    """
    `failure_reason` is guaranteed to be:
      - `NoError` if `status` is NOT `Failed`
      - NOT `NoError` if `status` is `Failed`
    """


@dataclass(eq=False, repr=False)
class ExternalOffload(betterproto.Message):
    offload_ids: List[str] = betterproto.string_field(1)
    """
    The `id`s associated with active external data offloads associated with the protocol
     The offload status can be queried using `mooneye.offload_manager.watch_offloads()``
    """


@dataclass(eq=False, repr=False)
class GetVersionInfoResponse(betterproto.Message):
    """
    From instance.proto

     Since 5.6
    """

    minknow: "GetVersionInfoResponseMinknowVersion" = betterproto.message_field(1)
    """
    What minknow version is installed. Split into major, minor and patch versions
     Also includes the full version as a string, which contain the major, minor and patch numbers
     as well as if the version is pre-release version (~pre), whether it is a release candidate (~rc#)
     or whether it is a variant version (i.e. for conferences) (-variant). For non-release builds it also
     includes the hash of the commit it is based on, and whether the working copy is different from that has (-dirty)
    """

    bream: str = betterproto.string_field(2)
    """
    The version of Bream that is installed.
    
     An invalid installation will cause this to return "0.0.0".
    
     Prior to 5.0, this field was called "protocols".
    
     Since 5.0
    """

    distribution_version: str = betterproto.string_field(3)
    """
    Describes the distribution that this MinKNOW installation is part of, usually
     this will be the Metapackage version number/identity, this will be "unknown"
     if the distribution-version hasn't been set. This information is also communicated
     in the Manager's DaemonMessage in daemon.proto
    """

    distribution_status: "GetVersionInfoResponseDistributionStatus" = (
        betterproto.enum_field(4)
    )
    """
    Indicates if the MinKNOW distribution including components such as Bream
     are stable, unstable or have been modified.
    """

    protocol_configuration: str = betterproto.string_field(5)
    """
    The version of the protocol configuration files that is installed.
    
     An invalid installation will cause this to return "0.0.0".
    
     Prior to 5.0, this field was called "configuration".
    
     Since 5.0
    """

    installation_type: "GetVersionInfoResponseInstallationType" = (
        betterproto.enum_field(6)
    )
    """
    The installation type of MinKNOW.
    
     The installation type may affect the available features, or the update process.
    
     Since 4.1
    """

    basecaller_build_version: str = betterproto.string_field(9)
    basecaller_connected_version: str = betterproto.string_field(10)


@dataclass(eq=False, repr=False)
class GetVersionInfoResponseMinknowVersion(betterproto.Message):
    major: int = betterproto.int32_field(1)
    minor: int = betterproto.int32_field(2)
    patch: int = betterproto.int32_field(3)
    full: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class AnalysisWorkflowInfo(betterproto.Message):
    request: "AnalysisWorkflowRequest" = betterproto.message_field(1)
    """The request that started the analysis workflow"""

    workflow_id: str = betterproto.string_field(2)
    """
    The workflow id of the started analysis workflow.
    
     May be empty if the workflow was unable to start
    """

    workflow_name: str = betterproto.string_field(3)
    """Human-readable name of the workflow."""

    workflow_version: str = betterproto.string_field(4)
    """What version the analysis workflow is running"""

    workflow_status: "AnalysisWorkflowInfoStatus" = betterproto.enum_field(5)
    """Current status of the workflow."""

    workflow_stop_reason: str = betterproto.string_field(6)
    """
    If 'workflow_status' is STOPPED_WITH_ERROR, then this field will be populated with
     a human readable error message describing why the workflow was stopped.
    
     For any other status, it is empty.
    """

    report_names: List[str] = betterproto.string_field(7)
    """
    The main report(s) for the analysis workflow
    
     Indicates that the report(s) are able to be retrieved from the Reception server
    """


@dataclass(eq=False, repr=False)
class ProtocolRunInfo(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    The unique identifier assigned to this run.
    
     This is guaranteed to be made of ASCII characters, and at most 40 characters. It is globally
     unique across all protocols runs on all MinKNOW instances.
    """

    protocol_id: str = betterproto.string_field(2)
    """The identifier of the protocol, as passed to start_protocol()."""

    args: List[str] = betterproto.string_field(3)
    """The arguments passed to start_protocol()."""

    settings: Dict[str, "_protocol_settings__.ProtocolSettingProtocolSettingValue"] = (
        betterproto.map_field(25, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    """
    Any settings changed from the defaults specified in the protocol's .toml file.
    
     These settings were passed as part of begin_protocol()
    """

    output_path: str = betterproto.string_field(11)
    """
    Output location for protocol data (eg. reads).
    
     If data offload is being used, this is the offload source directory.  Any files written to
     this location will be output alongside the rest of the experiment data
    
     Since 1.16.
    """

    reported_output_path: Optional[str] = betterproto.string_field(24, optional=True)
    """
    Output location to report to the user
    
     This is the location at which files will eventually be written.
    
     This path will be present, but empty, when writing to user-specified offload locations, as
     there isn't a "local output path" when offload is used.
    
     For backwards compatibility, if this this field is not present, then `output_path` can be
     reported to the user instead.
    
     Since 5.9
    """

    state: "ProtocolState" = betterproto.enum_field(4)
    """Indicates the current state of the protocol run."""

    phase: "ProtocolPhase" = betterproto.enum_field(16)
    """
    The phase of the protocol.
    
     This is the state reported by the protocol. If the protocol has not reported any state, it
     will be PHASE_UNKNOWN. Completed protocols also report PHASE_UNKNOWN.
    
     Note that clients should handle unexpected values of this field gracefully. This can happen
     if new phases are added but the client is still using an older version of the API
     specification.
    
     Since 4.4.
    
     DEPRECATED 6.1: Use phase_history instead
    """

    last_phase_change: datetime = betterproto.message_field(17)
    """
    The last time the phase changed.
    
     This can be used to determine how long the protocol has been in the current phase.
    
     NB: This will not be set if the phase is PHASE_UNKNOWN.
    
     Since 4.4.
    
     DEPRECATED 6.1: Use phase_history instead
    """

    phase_history: List["ProtocolPhaseSnapshot"] = betterproto.message_field(28)
    """
    The phase history of the protocol
    
     Describes all phases that the protocol went through, with timestamps at each stage
     to track how long it had taken between each phase
    
     Since 6.1
    """

    can_pause: bool = betterproto.bool_field(18)
    """
    Whether the protocol can be paused.
    
     Not all protocols can be paused, and cannot be paused in all phases.
    
     Note that if this is true and the phase is PHASE_PAUSING or PHASE_PAUSED, pausing will not
     actually do anything.
    
     Since 4.4.
    """

    can_trigger_mux_scan: bool = betterproto.bool_field(19)
    """
    Whether a mux scan can be triggered for the protocol.
    
     Since 4.4.
    """

    start_time: datetime = betterproto.message_field(5)
    """When the protocol was started (UTC)."""

    script_end_time: datetime = betterproto.message_field(9)
    """
    When the protocol script terminated (UTC).
    
     Unset if the protocol script is still running.
    
     Note that the protocol may still run until final acquisition completes.
    """

    end_time: datetime = betterproto.message_field(6)
    """
    When the protocol terminated (UTC), indicating both the
     protocol script and the final acquisition were completed.
    
     Unset if the protocol is still running.
    """

    stop_origin: "RequestOrigin" = betterproto.message_field(23)
    """
    Who is responsible for stopping the protocol
    
     Candidates:
      MinKNOW:     Any error that causes the protocol to stop
      UI:          Through stop_protocol API
      RunUntil:    Through stop criteria
    """

    acquisition_run_ids: List[str] = betterproto.string_field(7)
    """
    A list of acquisition periods started whilst this protocol was running.
    """

    user_info: "ProtocolRunUserInfo" = betterproto.message_field(8)
    """
    User specified information associated with the protocol at start time.
    
     Since 1.11.
    """

    epi2_me_workflows: List["Epi2MeWorkflowReference"] = betterproto.message_field(10)
    """
    List of workflows from epi2me associated with this protocol
    
     Since 1.15.
    """

    device: "_device__.GetDeviceInfoResponse" = betterproto.message_field(12)
    """
    Information about the device a protocol was started with
    
     Since 3.4
    """

    flow_cell: "_device__.GetFlowCellInfoResponse" = betterproto.message_field(13)
    """
    Information about the flow cell a protocol was started with
    
     Since 3.4
    """

    meta_info: "ProtocolInfo" = betterproto.message_field(14)
    """
    Meta-info about the protocol
    
     Since 3.8
    """

    associated_post_processing_analysis: List["AssociatedPostProcessingAnalysis"] = (
        betterproto.message_field(15)
    )
    """List of scheduled post processing analysis tasks"""

    analysis_workflow: "AnalysisWorkflowInfo" = betterproto.message_field(27)
    """
    The analysis workflow (if any) associated with the protocol
    
     EXPERIMENTAL: This field may change or be removed between minor versions without warning
    """

    pqc_result: "PlatformQcResult" = betterproto.message_field(20)
    """
    Platform QC result. Set by bream by calling `set_platform_qc_result()`.
     Possible to not be set (e.g. not a pqc run)
    """

    hardware_check_result: "HardwareCheckResult" = betterproto.message_field(26)
    """
    Hardware check result.  Set by bream calling `set_hardware_check_result()`.
     Not set if not a hardware check protocol
    """

    external_offload: "ExternalOffload" = betterproto.message_field(21)
    """
    Contains information about external data offloads associated with this protocol
    
     Since 5.0
    """

    software_versions: "GetVersionInfoResponse" = betterproto.message_field(22)
    """
    For storing version numbers to output to run report
    
     Since 5.6
    """


@dataclass(eq=False, repr=False)
class FilteringInfo(betterproto.Message):
    pqc_filter: "FilteringInfoPlatformQcFilter" = betterproto.message_field(1)
    """
    Filter by runs that have platform QC results
    
     Just initialising this message is enough to filter out runs with
     platform QC results from ones that don't
    
     Further filtering on the platform QC results can be applied by using
     the fields within PlatformQcFilter
    """

    hardware_check_filter: "FilteringInfoHardwareCheckFilter" = (
        betterproto.message_field(4)
    )
    """
    Filter by runs that have hardware check results
    
     Initialising this message means that only runs with a hardware check result will be
     returned
    """

    protocol_group_id: Optional[str] = betterproto.string_field(2, optional=True)
    """Filter runs by a specific protocol_group_id"""

    experiment_start_time: "FilteringInfoTimeFilter" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class FilteringInfoPlatformQcFilter(betterproto.Message):
    flow_cell_id: Optional[str] = betterproto.string_field(1, optional=True)


@dataclass(eq=False, repr=False)
class FilteringInfoHardwareCheckFilter(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class FilteringInfoTimeFilter(betterproto.Message):
    start_range: datetime = betterproto.message_field(1)
    end_range: datetime = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ListProtocolRunsRequest(betterproto.Message):
    filter_info: "FilteringInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListProtocolRunsResponse(betterproto.Message):
    run_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetCurrentProtocolRunRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetCurrentProtocolRunResponse(betterproto.Message):
    run_info: "ProtocolRunInfo" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class WatchCurrentProtocolRunRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetContextInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetContextInfoResponse(betterproto.Message):
    context_info: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class SetContextInfoRequest(betterproto.Message):
    context_info: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class SetContextInfoResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetProtocolPurposeRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetProtocolPurposeResponse(betterproto.Message):
    purpose: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class SetProtocolPurposeRequest(betterproto.Message):
    purpose: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class SetProtocolPurposeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class AddEpi2MeWorkflowRequest(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    epi2_me_workflow: "Epi2MeWorkflowReference" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AddEpi2MeWorkflowResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ProtocolGroupIdInfo(betterproto.Message):
    """
    timestamp for the last activity for experiment ordering
     since 5.6
    """

    protocol_group_id: str = betterproto.string_field(1)
    start_time: datetime = betterproto.message_field(2)
    """Most recent start time for the protocol group id"""


@dataclass(eq=False, repr=False)
class ListProtocolGroupIdsRequest(betterproto.Message):
    filter_info: "FilteringInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListProtocolGroupIdsResponse(betterproto.Message):
    protocol_group_ids: List[str] = betterproto.string_field(1)
    """
    A list of protocol group ids used in any
     protocol started on this instance of minknow.
    
     deprecated and replaced by string protocol_group_id
     in message ProtocolGroupIdInfo
    
     string data is guaranteed to be ordered by most recent
     start time, since 5.6
    """

    protocol_group_ids_info: List["ProtocolGroupIdInfo"] = betterproto.message_field(2)
    """
    A list of the most recent start time for each
     protocol group id on this instance of minknow.
    
     guaranteed to be ordered by most recent start time
     since 5.6
    """


@dataclass(eq=False, repr=False)
class BeginHardwareCheckRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class BeginHardwareCheckResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    UUID generated when the protocol is started, to uniquely represent this protocol instance
    """


@dataclass(eq=False, repr=False)
class BeginPlatformQcRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class BeginPlatformQcResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    UUID generated when the protocol is started, to uniquely represent this protocol instance
    """


@dataclass(eq=False, repr=False)
class BeginProtocolRequest(betterproto.Message):
    identifier: str = betterproto.string_field(1, group="protocol_identifier")
    """
    Specify the protocol with a string containing all the protocol's identifying components, eg:
     "sequencing/sequencing_MIN106_DNA:FLO-MIN106:SQK-RPB004"
    """

    components: "_protocol_settings__.ProtocolIdentifierComponents" = (
        betterproto.message_field(2, group="protocol_identifier")
    )
    """
    Specify the protocol providing the identifying components individually, all components are optional.
     Exactly one protocol should match the given components otherwise and error will be returned
    """

    user_info: "ProtocolRunUserInfo" = betterproto.message_field(3)
    """User info options for the protocol"""

    offload_location_info: "OffloadLocationInfo" = betterproto.message_field(5)
    """
    Information about data offload locations to use to store data
    
     Since 5.0.
    """

    target_run_until_criteria: "_acquisition__.TargetRunUntilCriteria" = (
        betterproto.message_field(6)
    )
    """
    Initial Target Run-Until Criteria to use when starting an acquisition for this protocol.
     These can be updated during the acquisition using the Run-Until API.
    
     Since 5.3
    """

    settings: Dict[str, "_protocol_settings__.ProtocolSettingProtocolSettingValue"] = (
        betterproto.map_field(4, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    """
    Any settings changed from the defaults specified in the protocol's .toml file.
    """

    analysis_workflow_request: "AnalysisWorkflowRequest" = betterproto.message_field(8)
    """Workflow request that should be started when the protocol is started"""

    simulation_source: str = betterproto.string_field(9)
    """
    Simulation source for playback device data, either an hdf file or directory for use with arrow playback files.
    
     Since 6.2
    """


@dataclass(eq=False, repr=False)
class BeginProtocolResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    UUID generated when the protocol is started, to uniquely represent this protocol instance
    """


@dataclass(eq=False, repr=False)
class SetPlatformQcResultRequest(betterproto.Message):
    protocol_run_id: str = betterproto.string_field(1)
    """The protocol_run_id that was given when the pqc run was started"""

    pqc_result: "PlatformQcResult" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class SetPlatformQcResultResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetHardwareCheckResultRequest(betterproto.Message):
    protocol_run_id: str = betterproto.string_field(1)
    """
    The protocol_run_id that was given when the hardware check run was started
    """

    result: "HardwareCheckResult" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class SetHardwareCheckResultResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class AssociatePostProcessingAnalysisRequest(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """Protocol id to associate analysis with:"""

    start_request: "_basecaller__.StartRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AssociatePostProcessingAnalysisResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    Id of the basecaller.proto post processing task that was triggered, if the post processing analysis was executed immediately (protocol was finished).
    """


@dataclass(eq=False, repr=False)
class ClearProtocolHistoryDataRequest(betterproto.Message):
    protocol_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ClearProtocolHistoryDataResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ProtocolPhaseManagementRequest(betterproto.Message):
    set_capabilities: "ProtocolPhaseManagementRequestCapabilities" = (
        betterproto.message_field(1)
    )
    """
    Update the set of capabilities (messages that will be responded to by the protocol).
    """

    phase: "ProtocolPhase" = betterproto.enum_field(2)
    """
    Update the protocol phase.
    
     Leave empty (ie: PHASE_UNKNOWN) to keep the previous phase.
    """


@dataclass(eq=False, repr=False)
class ProtocolPhaseManagementRequestCapabilities(betterproto.Message):
    can_pause: bool = betterproto.bool_field(1)
    """
    Indicate that the protocol will respond to pause and resume requests.
    """

    can_trigger_mux_scan: bool = betterproto.bool_field(2)
    """Indicate that the protocol will respond to mux scan requests."""


@dataclass(eq=False, repr=False)
class ProtocolPhaseManagementResponse(betterproto.Message):
    action: "Action" = betterproto.enum_field(1)
    """
    Requests that the protocol changes phase.
    
     The client should never receive an action type (other than possibly ACTION_NONE) that it has
     not explicitly opted into via the `ProtocolPhaseManagementRequest.set_capabilities` field.
    
     If this is set to ACTION_NONE, the message should be ignored (this is for future
     compatibility).
    """


@dataclass(eq=False, repr=False)
class GenerateRunReportRequest(betterproto.Message):
    protocol_run_id: str = betterproto.string_field(1)
    """The protocol_run_id to generate a report for."""

    include_input_data: bool = betterproto.bool_field(2)
    """
    Optionally return the input data used to generate the report. This input data is
     represented as the data seen in report_data.proto
    """


@dataclass(eq=False, repr=False)
class GenerateRunReportResponse(betterproto.Message):
    protocol_run_id: str = betterproto.string_field(1)
    """Protocol ID the run report is for."""

    report_data: str = betterproto.string_field(2)
    """
    A section of the run report data (note the api to return this data may stream back several sections).
    """

    remaining_length: int = betterproto.int32_field(3)
    """
    How many further characters of data remain after this message (excluding of this message).
    """

    input_data: str = betterproto.string_field(4)
    """
    If include_input_data was set, this will be a section of that data
     (note the api to return this data may stream back several sections).
    """

    remaining_input_length: int = betterproto.int32_field(5)
    """
    If include_input_data was set, how many further characters of input data remain
     after this message (excluding of this message).
    """


class ProtocolServiceStub(betterproto.ServiceStub):
    async def start_protocol(
        self,
        start_protocol_request: "StartProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StartProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/start_protocol",
            start_protocol_request,
            StartProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stop_protocol(
        self,
        stop_protocol_request: "StopProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StopProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/stop_protocol",
            stop_protocol_request,
            StopProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def pause_protocol(
        self,
        pause_protocol_request: "PauseProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PauseProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/pause_protocol",
            pause_protocol_request,
            PauseProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def resume_protocol(
        self,
        resume_protocol_request: "ResumeProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ResumeProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/resume_protocol",
            resume_protocol_request,
            ResumeProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def trigger_mux_scan(
        self,
        trigger_mux_scan_request: "TriggerMuxScanRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TriggerMuxScanResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/trigger_mux_scan",
            trigger_mux_scan_request,
            TriggerMuxScanResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def wait_for_finished(
        self,
        wait_for_finished_request: "WaitForFinishedRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ProtocolRunInfo":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/wait_for_finished",
            wait_for_finished_request,
            ProtocolRunInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_run_info(
        self,
        get_run_info_request: "GetRunInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ProtocolRunInfo":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/get_run_info",
            get_run_info_request,
            ProtocolRunInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_protocol_runs(
        self,
        list_protocol_runs_request: "ListProtocolRunsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListProtocolRunsResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/list_protocol_runs",
            list_protocol_runs_request,
            ListProtocolRunsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_current_protocol_run(
        self,
        get_current_protocol_run_request: "GetCurrentProtocolRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ProtocolRunInfo":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/get_current_protocol_run",
            get_current_protocol_run_request,
            ProtocolRunInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def watch_current_protocol_run(
        self,
        watch_current_protocol_run_request: "WatchCurrentProtocolRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[ProtocolRunInfo]:
        async for response in self._unary_stream(
            "/minknow_api.protocol.ProtocolService/watch_current_protocol_run",
            watch_current_protocol_run_request,
            ProtocolRunInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def list_protocols(
        self,
        list_protocols_request: "ListProtocolsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListProtocolsResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/list_protocols",
            list_protocols_request,
            ListProtocolsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_context_info(
        self,
        get_context_info_request: "GetContextInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetContextInfoResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/get_context_info",
            get_context_info_request,
            GetContextInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_context_info(
        self,
        set_context_info_request: "SetContextInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetContextInfoResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/set_context_info",
            set_context_info_request,
            SetContextInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_protocol_purpose(
        self,
        get_protocol_purpose_request: "GetProtocolPurposeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetProtocolPurposeResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/get_protocol_purpose",
            get_protocol_purpose_request,
            GetProtocolPurposeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_protocol_purpose(
        self,
        set_protocol_purpose_request: "SetProtocolPurposeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetProtocolPurposeResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/set_protocol_purpose",
            set_protocol_purpose_request,
            SetProtocolPurposeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def add_epi2_me_workflow(
        self,
        add_epi2_me_workflow_request: "AddEpi2MeWorkflowRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AddEpi2MeWorkflowResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/add_epi2me_workflow",
            add_epi2_me_workflow_request,
            AddEpi2MeWorkflowResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_protocol_group_ids(
        self,
        list_protocol_group_ids_request: "ListProtocolGroupIdsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListProtocolGroupIdsResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/list_protocol_group_ids",
            list_protocol_group_ids_request,
            ListProtocolGroupIdsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def begin_hardware_check(
        self,
        begin_hardware_check_request: "BeginHardwareCheckRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BeginHardwareCheckResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/begin_hardware_check",
            begin_hardware_check_request,
            BeginHardwareCheckResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def begin_platform_qc(
        self,
        begin_platform_qc_request: "BeginPlatformQcRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BeginPlatformQcResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/begin_platform_qc",
            begin_platform_qc_request,
            BeginPlatformQcResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def begin_protocol(
        self,
        begin_protocol_request: "BeginProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BeginProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/begin_protocol",
            begin_protocol_request,
            BeginProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_platform_qc_result(
        self,
        set_platform_qc_result_request: "SetPlatformQcResultRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetPlatformQcResultResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/set_platform_qc_result",
            set_platform_qc_result_request,
            SetPlatformQcResultResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_hardware_check_result(
        self,
        set_hardware_check_result_request: "SetHardwareCheckResultRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetHardwareCheckResultResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/set_hardware_check_result",
            set_hardware_check_result_request,
            SetHardwareCheckResultResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def associate_post_processing_analysis_for_protocol(
        self,
        associate_post_processing_analysis_request: "AssociatePostProcessingAnalysisRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AssociatePostProcessingAnalysisResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/associate_post_processing_analysis_for_protocol",
            associate_post_processing_analysis_request,
            AssociatePostProcessingAnalysisResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def clear_protocol_history_data(
        self,
        clear_protocol_history_data_request: "ClearProtocolHistoryDataRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ClearProtocolHistoryDataResponse":
        return await self._unary_unary(
            "/minknow_api.protocol.ProtocolService/clear_protocol_history_data",
            clear_protocol_history_data_request,
            ClearProtocolHistoryDataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def protocol_phase_management(
        self,
        protocol_phase_management_request_iterator: Union[
            AsyncIterable[ProtocolPhaseManagementRequest],
            Iterable[ProtocolPhaseManagementRequest],
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[ProtocolPhaseManagementResponse]:
        async for response in self._stream_stream(
            "/minknow_api.protocol.ProtocolService/protocol_phase_management",
            protocol_phase_management_request_iterator,
            ProtocolPhaseManagementRequest,
            ProtocolPhaseManagementResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def generate_run_report(
        self,
        generate_run_report_request: "GenerateRunReportRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GenerateRunReportResponse]:
        async for response in self._unary_stream(
            "/minknow_api.protocol.ProtocolService/generate_run_report",
            generate_run_report_request,
            GenerateRunReportResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ProtocolServiceBase(ServiceBase):

    async def start_protocol(
        self, start_protocol_request: "StartProtocolRequest"
    ) -> "StartProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stop_protocol(
        self, stop_protocol_request: "StopProtocolRequest"
    ) -> "StopProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pause_protocol(
        self, pause_protocol_request: "PauseProtocolRequest"
    ) -> "PauseProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def resume_protocol(
        self, resume_protocol_request: "ResumeProtocolRequest"
    ) -> "ResumeProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def trigger_mux_scan(
        self, trigger_mux_scan_request: "TriggerMuxScanRequest"
    ) -> "TriggerMuxScanResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def wait_for_finished(
        self, wait_for_finished_request: "WaitForFinishedRequest"
    ) -> "ProtocolRunInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_run_info(
        self, get_run_info_request: "GetRunInfoRequest"
    ) -> "ProtocolRunInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_protocol_runs(
        self, list_protocol_runs_request: "ListProtocolRunsRequest"
    ) -> "ListProtocolRunsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_current_protocol_run(
        self, get_current_protocol_run_request: "GetCurrentProtocolRunRequest"
    ) -> "ProtocolRunInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def watch_current_protocol_run(
        self, watch_current_protocol_run_request: "WatchCurrentProtocolRunRequest"
    ) -> AsyncIterator[ProtocolRunInfo]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ProtocolRunInfo()

    async def list_protocols(
        self, list_protocols_request: "ListProtocolsRequest"
    ) -> "ListProtocolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_context_info(
        self, get_context_info_request: "GetContextInfoRequest"
    ) -> "GetContextInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_context_info(
        self, set_context_info_request: "SetContextInfoRequest"
    ) -> "SetContextInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_protocol_purpose(
        self, get_protocol_purpose_request: "GetProtocolPurposeRequest"
    ) -> "GetProtocolPurposeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_protocol_purpose(
        self, set_protocol_purpose_request: "SetProtocolPurposeRequest"
    ) -> "SetProtocolPurposeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_epi2_me_workflow(
        self, add_epi2_me_workflow_request: "AddEpi2MeWorkflowRequest"
    ) -> "AddEpi2MeWorkflowResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_protocol_group_ids(
        self, list_protocol_group_ids_request: "ListProtocolGroupIdsRequest"
    ) -> "ListProtocolGroupIdsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def begin_hardware_check(
        self, begin_hardware_check_request: "BeginHardwareCheckRequest"
    ) -> "BeginHardwareCheckResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def begin_platform_qc(
        self, begin_platform_qc_request: "BeginPlatformQcRequest"
    ) -> "BeginPlatformQcResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def begin_protocol(
        self, begin_protocol_request: "BeginProtocolRequest"
    ) -> "BeginProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_platform_qc_result(
        self, set_platform_qc_result_request: "SetPlatformQcResultRequest"
    ) -> "SetPlatformQcResultResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_hardware_check_result(
        self, set_hardware_check_result_request: "SetHardwareCheckResultRequest"
    ) -> "SetHardwareCheckResultResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def associate_post_processing_analysis_for_protocol(
        self,
        associate_post_processing_analysis_request: "AssociatePostProcessingAnalysisRequest",
    ) -> "AssociatePostProcessingAnalysisResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def clear_protocol_history_data(
        self, clear_protocol_history_data_request: "ClearProtocolHistoryDataRequest"
    ) -> "ClearProtocolHistoryDataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def protocol_phase_management(
        self,
        protocol_phase_management_request_iterator: AsyncIterator[
            ProtocolPhaseManagementRequest
        ],
    ) -> AsyncIterator[ProtocolPhaseManagementResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ProtocolPhaseManagementResponse()

    async def generate_run_report(
        self, generate_run_report_request: "GenerateRunReportRequest"
    ) -> AsyncIterator[GenerateRunReportResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GenerateRunReportResponse()

    async def __rpc_start_protocol(
        self,
        stream: "grpclib.server.Stream[StartProtocolRequest, StartProtocolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_protocol(request)
        await stream.send_message(response)

    async def __rpc_stop_protocol(
        self, stream: "grpclib.server.Stream[StopProtocolRequest, StopProtocolResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.stop_protocol(request)
        await stream.send_message(response)

    async def __rpc_pause_protocol(
        self,
        stream: "grpclib.server.Stream[PauseProtocolRequest, PauseProtocolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.pause_protocol(request)
        await stream.send_message(response)

    async def __rpc_resume_protocol(
        self,
        stream: "grpclib.server.Stream[ResumeProtocolRequest, ResumeProtocolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.resume_protocol(request)
        await stream.send_message(response)

    async def __rpc_trigger_mux_scan(
        self,
        stream: "grpclib.server.Stream[TriggerMuxScanRequest, TriggerMuxScanResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.trigger_mux_scan(request)
        await stream.send_message(response)

    async def __rpc_wait_for_finished(
        self, stream: "grpclib.server.Stream[WaitForFinishedRequest, ProtocolRunInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.wait_for_finished(request)
        await stream.send_message(response)

    async def __rpc_get_run_info(
        self, stream: "grpclib.server.Stream[GetRunInfoRequest, ProtocolRunInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_run_info(request)
        await stream.send_message(response)

    async def __rpc_list_protocol_runs(
        self,
        stream: "grpclib.server.Stream[ListProtocolRunsRequest, ListProtocolRunsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_protocol_runs(request)
        await stream.send_message(response)

    async def __rpc_get_current_protocol_run(
        self,
        stream: "grpclib.server.Stream[GetCurrentProtocolRunRequest, ProtocolRunInfo]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_current_protocol_run(request)
        await stream.send_message(response)

    async def __rpc_watch_current_protocol_run(
        self,
        stream: "grpclib.server.Stream[WatchCurrentProtocolRunRequest, ProtocolRunInfo]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.watch_current_protocol_run,
            stream,
            request,
        )

    async def __rpc_list_protocols(
        self,
        stream: "grpclib.server.Stream[ListProtocolsRequest, ListProtocolsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_protocols(request)
        await stream.send_message(response)

    async def __rpc_get_context_info(
        self,
        stream: "grpclib.server.Stream[GetContextInfoRequest, GetContextInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_context_info(request)
        await stream.send_message(response)

    async def __rpc_set_context_info(
        self,
        stream: "grpclib.server.Stream[SetContextInfoRequest, SetContextInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_context_info(request)
        await stream.send_message(response)

    async def __rpc_get_protocol_purpose(
        self,
        stream: "grpclib.server.Stream[GetProtocolPurposeRequest, GetProtocolPurposeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_protocol_purpose(request)
        await stream.send_message(response)

    async def __rpc_set_protocol_purpose(
        self,
        stream: "grpclib.server.Stream[SetProtocolPurposeRequest, SetProtocolPurposeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_protocol_purpose(request)
        await stream.send_message(response)

    async def __rpc_add_epi2_me_workflow(
        self,
        stream: "grpclib.server.Stream[AddEpi2MeWorkflowRequest, AddEpi2MeWorkflowResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_epi2_me_workflow(request)
        await stream.send_message(response)

    async def __rpc_list_protocol_group_ids(
        self,
        stream: "grpclib.server.Stream[ListProtocolGroupIdsRequest, ListProtocolGroupIdsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_protocol_group_ids(request)
        await stream.send_message(response)

    async def __rpc_begin_hardware_check(
        self,
        stream: "grpclib.server.Stream[BeginHardwareCheckRequest, BeginHardwareCheckResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.begin_hardware_check(request)
        await stream.send_message(response)

    async def __rpc_begin_platform_qc(
        self,
        stream: "grpclib.server.Stream[BeginPlatformQcRequest, BeginPlatformQcResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.begin_platform_qc(request)
        await stream.send_message(response)

    async def __rpc_begin_protocol(
        self,
        stream: "grpclib.server.Stream[BeginProtocolRequest, BeginProtocolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.begin_protocol(request)
        await stream.send_message(response)

    async def __rpc_set_platform_qc_result(
        self,
        stream: "grpclib.server.Stream[SetPlatformQcResultRequest, SetPlatformQcResultResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_platform_qc_result(request)
        await stream.send_message(response)

    async def __rpc_set_hardware_check_result(
        self,
        stream: "grpclib.server.Stream[SetHardwareCheckResultRequest, SetHardwareCheckResultResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_hardware_check_result(request)
        await stream.send_message(response)

    async def __rpc_associate_post_processing_analysis_for_protocol(
        self,
        stream: "grpclib.server.Stream[AssociatePostProcessingAnalysisRequest, AssociatePostProcessingAnalysisResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.associate_post_processing_analysis_for_protocol(request)
        await stream.send_message(response)

    async def __rpc_clear_protocol_history_data(
        self,
        stream: "grpclib.server.Stream[ClearProtocolHistoryDataRequest, ClearProtocolHistoryDataResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.clear_protocol_history_data(request)
        await stream.send_message(response)

    async def __rpc_protocol_phase_management(
        self,
        stream: "grpclib.server.Stream[ProtocolPhaseManagementRequest, ProtocolPhaseManagementResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.protocol_phase_management,
            stream,
            request,
        )

    async def __rpc_generate_run_report(
        self,
        stream: "grpclib.server.Stream[GenerateRunReportRequest, GenerateRunReportResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.generate_run_report,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.protocol.ProtocolService/start_protocol": grpclib.const.Handler(
                self.__rpc_start_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartProtocolRequest,
                StartProtocolResponse,
            ),
            "/minknow_api.protocol.ProtocolService/stop_protocol": grpclib.const.Handler(
                self.__rpc_stop_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                StopProtocolRequest,
                StopProtocolResponse,
            ),
            "/minknow_api.protocol.ProtocolService/pause_protocol": grpclib.const.Handler(
                self.__rpc_pause_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                PauseProtocolRequest,
                PauseProtocolResponse,
            ),
            "/minknow_api.protocol.ProtocolService/resume_protocol": grpclib.const.Handler(
                self.__rpc_resume_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResumeProtocolRequest,
                ResumeProtocolResponse,
            ),
            "/minknow_api.protocol.ProtocolService/trigger_mux_scan": grpclib.const.Handler(
                self.__rpc_trigger_mux_scan,
                grpclib.const.Cardinality.UNARY_UNARY,
                TriggerMuxScanRequest,
                TriggerMuxScanResponse,
            ),
            "/minknow_api.protocol.ProtocolService/wait_for_finished": grpclib.const.Handler(
                self.__rpc_wait_for_finished,
                grpclib.const.Cardinality.UNARY_UNARY,
                WaitForFinishedRequest,
                ProtocolRunInfo,
            ),
            "/minknow_api.protocol.ProtocolService/get_run_info": grpclib.const.Handler(
                self.__rpc_get_run_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetRunInfoRequest,
                ProtocolRunInfo,
            ),
            "/minknow_api.protocol.ProtocolService/list_protocol_runs": grpclib.const.Handler(
                self.__rpc_list_protocol_runs,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListProtocolRunsRequest,
                ListProtocolRunsResponse,
            ),
            "/minknow_api.protocol.ProtocolService/get_current_protocol_run": grpclib.const.Handler(
                self.__rpc_get_current_protocol_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetCurrentProtocolRunRequest,
                ProtocolRunInfo,
            ),
            "/minknow_api.protocol.ProtocolService/watch_current_protocol_run": grpclib.const.Handler(
                self.__rpc_watch_current_protocol_run,
                grpclib.const.Cardinality.UNARY_STREAM,
                WatchCurrentProtocolRunRequest,
                ProtocolRunInfo,
            ),
            "/minknow_api.protocol.ProtocolService/list_protocols": grpclib.const.Handler(
                self.__rpc_list_protocols,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListProtocolsRequest,
                ListProtocolsResponse,
            ),
            "/minknow_api.protocol.ProtocolService/get_context_info": grpclib.const.Handler(
                self.__rpc_get_context_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetContextInfoRequest,
                GetContextInfoResponse,
            ),
            "/minknow_api.protocol.ProtocolService/set_context_info": grpclib.const.Handler(
                self.__rpc_set_context_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetContextInfoRequest,
                SetContextInfoResponse,
            ),
            "/minknow_api.protocol.ProtocolService/get_protocol_purpose": grpclib.const.Handler(
                self.__rpc_get_protocol_purpose,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetProtocolPurposeRequest,
                GetProtocolPurposeResponse,
            ),
            "/minknow_api.protocol.ProtocolService/set_protocol_purpose": grpclib.const.Handler(
                self.__rpc_set_protocol_purpose,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetProtocolPurposeRequest,
                SetProtocolPurposeResponse,
            ),
            "/minknow_api.protocol.ProtocolService/add_epi2me_workflow": grpclib.const.Handler(
                self.__rpc_add_epi2_me_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddEpi2MeWorkflowRequest,
                AddEpi2MeWorkflowResponse,
            ),
            "/minknow_api.protocol.ProtocolService/list_protocol_group_ids": grpclib.const.Handler(
                self.__rpc_list_protocol_group_ids,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListProtocolGroupIdsRequest,
                ListProtocolGroupIdsResponse,
            ),
            "/minknow_api.protocol.ProtocolService/begin_hardware_check": grpclib.const.Handler(
                self.__rpc_begin_hardware_check,
                grpclib.const.Cardinality.UNARY_UNARY,
                BeginHardwareCheckRequest,
                BeginHardwareCheckResponse,
            ),
            "/minknow_api.protocol.ProtocolService/begin_platform_qc": grpclib.const.Handler(
                self.__rpc_begin_platform_qc,
                grpclib.const.Cardinality.UNARY_UNARY,
                BeginPlatformQcRequest,
                BeginPlatformQcResponse,
            ),
            "/minknow_api.protocol.ProtocolService/begin_protocol": grpclib.const.Handler(
                self.__rpc_begin_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                BeginProtocolRequest,
                BeginProtocolResponse,
            ),
            "/minknow_api.protocol.ProtocolService/set_platform_qc_result": grpclib.const.Handler(
                self.__rpc_set_platform_qc_result,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetPlatformQcResultRequest,
                SetPlatformQcResultResponse,
            ),
            "/minknow_api.protocol.ProtocolService/set_hardware_check_result": grpclib.const.Handler(
                self.__rpc_set_hardware_check_result,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetHardwareCheckResultRequest,
                SetHardwareCheckResultResponse,
            ),
            "/minknow_api.protocol.ProtocolService/associate_post_processing_analysis_for_protocol": grpclib.const.Handler(
                self.__rpc_associate_post_processing_analysis_for_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssociatePostProcessingAnalysisRequest,
                AssociatePostProcessingAnalysisResponse,
            ),
            "/minknow_api.protocol.ProtocolService/clear_protocol_history_data": grpclib.const.Handler(
                self.__rpc_clear_protocol_history_data,
                grpclib.const.Cardinality.UNARY_UNARY,
                ClearProtocolHistoryDataRequest,
                ClearProtocolHistoryDataResponse,
            ),
            "/minknow_api.protocol.ProtocolService/protocol_phase_management": grpclib.const.Handler(
                self.__rpc_protocol_phase_management,
                grpclib.const.Cardinality.STREAM_STREAM,
                ProtocolPhaseManagementRequest,
                ProtocolPhaseManagementResponse,
            ),
            "/minknow_api.protocol.ProtocolService/generate_run_report": grpclib.const.Handler(
                self.__rpc_generate_run_report,
                grpclib.const.Cardinality.UNARY_STREAM,
                GenerateRunReportRequest,
                GenerateRunReportResponse,
            ),
        }
