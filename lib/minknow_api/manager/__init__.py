# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/manager.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    device as _device__,
    instance as _instance__,
    protocol_settings as _protocol_settings__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class SimpleProtocolState(betterproto.Enum):
    NO_PROTOCOL_STATE = 0
    """
    No protocol has been started on this position (since MinKNOW was started, or the position
     was reset). It may also indicate that the protocol state has been manually cleared by the
     user (although there is currently no API for doing this).
    """

    PROTOCOL_RUNNING = 1
    """A protocol is currently running on this flow cell position."""

    PROTOCOL_FINISHED_SUCCESSFULLY = 2
    """
    No protocol is currently running, and the last protocol finished successfully (it either ran
     to completion or the user manually stopped it).
    """

    PROTOCOL_FINISHED_WITH_ERROR = 3
    """
    No protocol is currently running, and the last protocol finished with an error.
    """


class SimulatedDeviceType(betterproto.Enum):
    SIMULATED_AUTO = 0
    SIMULATED_MINION = 1
    SIMULATED_PROMETHION = 3
    SIMULATED_P2 = 4


class ExperimentType(betterproto.Enum):
    SEQUENCING = 0
    """Must not be hidden, experiment type must be "sequencing"."""

    CONTROL = 1
    """Must not be hidden, experiment type must be "control"."""

    CUSTOM = 2
    """
    Must not be hidden, experiment type must not be "sequencing" or "control", and if the protocol is in the installation directory, it must also not be "CTC", "platform QC" or "flowcell_plugin".
    """

    ALL_EXCEPT_HIDDEN = 3
    """
    "hidden" protocols are not returned, but any other compatible protocols are.
    """

    ALL_INCLUDING_HIDDEN = 4
    """All protocols, including "hidden" protocols, are returned."""


class DescribeHostResponseBasecallingAvailability(betterproto.Enum):
    BASECALLING_AVAILABLE = 0
    """
    Basecalling is available and the underlying services are up and running
    """

    BASECALLING_UNAVAILABLE = 1
    """
    Basecalling is unavailable
    
     This may be due to failing to start or has failed to recover after being restarted
    """

    BASECALLING_UNAVAILABLE_BAD_CONFIGURATION = 2
    """
    Basecalling is unavailable due to bad configuration of the underlying service
     and automatic recovery is not possible
    
     This may be due to hardware configuration or compatibility when GPU basecalling is
     enabled but the server is unable to support or use the GPU
    """

    BASECALLING_UNAVAILABLE_ATTEMPTING_RECOVERY = 3
    """
    Basecalling is temporarily unavailable and the system is attempting to restart
     the underlying service
    
     This may be due to a runtime issue and attempts are being made to recover
    """


class FlowCellPositionState(betterproto.Enum):
    STATE_INITIALISING = 0
    """
    The flow cell position is being initialised. This state should only last for a few
     seconds, before moving to `STATE_RUNNING` or one of the error states.
    """

    STATE_RUNNING = 1
    """
    The flow cell position is in a basic state of operation, and an RPC interface is
     available for it.
    
     `rpc_ports` is guaranteed to be set in this tate. Note that port information may also be
     provided in the hardware error states if the software is still running.
    
     Note that many hardware and software errors are not detectable by the manager, so
     `STATE_RUNNING` may be set even when there is a problem. The interface provided over
     `rpc_ports` should be the canonical source of the state of the flow cell position when in
     `STATE_RUNNING`. In the future, more errors may be tracked properly here.
    """

    STATE_RESETTING = 2
    """
    After calling reset_position(), this state may be entered to indicate the software is in
     the process of being stopped.
    
     Typically, this state will either transition into STATE_INITIALISING or the position will
     be removed entirely (although it could return to one of the hardware error states).
    """

    STATE_HARDWARE_REMOVED = 3
    """
    The hardware corresponding to the flow cell position was removed.
    
     Only set for removable positions (ie: USB MinIONs). This state indicates that the
     hardware was removed, but the software is still running. The software will not be stopped
     automatically to prevent possible data loss. Call reset_position() to stop the software
     and forget about the position.
    """

    STATE_HARDWARE_ERROR = 4
    """
    Communication with the hardware failed.
    
     For integrated positions, this can include when the hardware was not found at all (eg: if
     a PromethION has not had one of its sequencing unit cables attached).
    
     More information may be available in `error_info`.
    """

    STATE_SOFTWARE_ERROR = 5
    """
    The software corresponding to the flow cell position could not be started (or stopped
     unexpectedly).
    
     More information may be available in `error_info`.
    """

    STATE_NEEDS_ASSOCIATION = 6
    """
    The position is not available because it requires association.
    
     See also `DescribeHostResponse.needs_association`. If the `describe_host` RPC result has
     `needs_association` set to false, this position is a pluggable device (likely a MinION
     Mk1B) that individually requires association.
    
     Since 4.4
     DEPRECATED: since 6.2 device or host association is not required or supported.
    """

    STATE_USB_SPEED_TOO_LOW = 7
    """
    The USB connection speed is too low for the device to operate correctly
    
     Ensure that the device is plugged in to a suitable USB port, using the recommended cable
    
     Since 6.1
    """


class GetFeaturesResponseState(betterproto.Enum):
    UNKNOWN = 0
    """MinKNOW shouldn't send this, likely a bug"""

    NO_FILE = 1
    """No saved config was detected, so a default from minknow was provided"""

    ERROR_LOADING_FROM_FILE = 2
    """
    Saved config was detected, but there was an error in processing it
     The values may be different from what the user expects
    """

    LOADED_FROM_FILE = 3
    """A saved config was detected and was loaded successfully"""


@dataclass(eq=False, repr=False)
class DescribeHostRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DescribeHostResponse(betterproto.Message):
    product_code: str = betterproto.string_field(1)
    """
    The product code for the host, if applicable.
    
     If this is an integrated Oxford Nanopore device, this will be the product code of the device,
     or the part of the device that runs MinKNOW (eg: several PromethION models have separate
     product codes for the sequencing unit where the flow cells are inserted and the compute
     unit - this would be the product code for the compute unit).
    
     Some example product codes:
    
     ============  =================
     Product Code  Name
     ============  =================
     GRD-X5B001    GridION X5
     GRD-X5B002    GridION X5
     GRD-X5B003    GridION X5 Mk1
     MIN-101C      MinION Mk1C
     PRO-PRMC01    PromethION Beta
     PRO-PRC024    PromethION 24
     PRO-PRC048    PromethION 48
     ONT-314       PromethION (Production)
    
     If MinKNOW is running on a machine that is not provided by Oxford Nanopore (ie: their own
     laptop or desktop machine with a MinION plugged in), this field will be empty.
    """

    description: str = betterproto.string_field(2)
    """
    A human-readable name for the type of host.
    
     If `product_code` is set, it will be the name of the model of instrument (see the table in
     the `product_code` field). Otherwise it will be empty.
    """

    serial: str = betterproto.string_field(3)
    """
    The serial of Nanopore device.
    
     If `product_code` is empty, this will also be empty.
    
     This uniquely identifies the device.
    
     See also `network_name`.
    """

    network_name: str = betterproto.string_field(4)
    """
    The network name of the host.
    
     This is the name the host system believes it has on the network. This can be useful if an IP
     address was used to connect to the RPC system.
    
     For customer computers, this is the only available identifying information for the system.
    """

    needs_association: bool = betterproto.bool_field(16)
    """
    This device has not been associated with an account.
    
     Association must be completed before using the device.
    
     Note that this will only ever be set for hosts that also have a `product_code` and `serial`.
    
     If this is true, all positions will report as ``STATE_NEEDS_ASSOCIATION`` until the device
     is associated. Even if this is false, however, removable sequencing units (eg: the MinION
     Mk1B) may require their own association (in which case they will individually report as
     ``STATE_NEEDS_ASSOCIATION`` - see the `flow_cell_positions` RPC).
    
     Since 4.4
     DEPRECATED since 6.2 device association is no-longer required, this will always be false.
    """

    can_sequence_offline: bool = betterproto.bool_field(5)
    """
    Whether the device can sequence while offline.
    
     Not all sequencing devices can sequence without an internet connection. This indicates
     whether it is possible for the integrated sequencing positions. Note that this will only be
     set if `needs_association` is true.
    
     Since 4.4
    """

    can_connect_to_usb_device: bool = betterproto.bool_field(17)
    """
    Whether or not the host system can connect to a USB sequencer.
    
     This is true on all systems except iOS where it is true if and only if the driver that is
     shipped with the app has been enabled in system settings.
    
     Since 6.1
    """

    can_basecall: "DescribeHostResponseBasecallingAvailability" = (
        betterproto.enum_field(6)
    )
    """Whether the device can currently provide basecalling"""

    current_basecalling_hardware: "DescribeHostResponseBasecallerSubstrate" = (
        betterproto.message_field(7)
    )
    """
    Information about the hardware being used right now by the basecaller.
    """

    available_basecalling_hardware: List["DescribeHostResponseBasecallerSubstrate"] = (
        betterproto.message_field(8)
    )
    """
    If more than one possible basecalling hardware selection can be made, this field provides the details of those options.
     Typically this will be a list of 'unused' GPUs.
    """


@dataclass(eq=False, repr=False)
class DescribeHostResponseBasecallerSubstrate(betterproto.Message):
    """Details about the hardware on which basecalling may be run."""

    is_gpu: bool = betterproto.bool_field(1)
    """
    If false, this indicates that CPU basecalling is selected.
     In this case, the 'gpus' field should be omitted or empty.
    """

    gpus: List[str] = betterproto.string_field(2)
    """
    Provides human-readable strings describing the GPUs available for use by the basecaller.
     Note that even if 'is_gpu' is true, this may be empty if no further details are available.
     This field being empty _does not_ imply that CPU basecalling is in use.
    """


@dataclass(eq=False, repr=False)
class GetBasecallerFeaturesRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetBasecallerFeaturesResponse(betterproto.Message):
    is_live_basecalling_with_adaptive_sampling_recommended: bool = (
        betterproto.bool_field(1)
    )
    """
    Is live basecalling with adaptive sampling
     recommended on this hardware
     Currently not recommended for Apple or Mk1C
    
     Since 5.9
    """


@dataclass(eq=False, repr=False)
class FlowCellPosition(betterproto.Message):
    name: str = betterproto.string_field(1)
    """
    The name of the position.
    
     For MinIONs, this is the name of the MinION (eg: MN12345). For integrated positions, this is
     the label for the position on the sequencer (eg: X1 for GridION, 1-A1-D1 for PromethION).
    """

    location: "FlowCellPositionLocation" = betterproto.message_field(2)
    """
    For integrated flow cell positions, indicates where it is on the sequencing unit.
    
     This information is not provided for MinIONs (except for the MinION Mk1C, in which case the
     position is always 0, 0).
    """

    state: "FlowCellPositionState" = betterproto.enum_field(3)
    """
    The state of the flow cell position.
    
     If the state is not `STATE_RUNNING` or `STATE_INITIALISING`, the flow cell position can be
     assumed to be unusable, and the `error_info` field should be populated.
    """

    rpc_ports: "FlowCellPositionRpcPorts" = betterproto.message_field(4)
    """
    The ports the APIs for this flow cell position are provided on.
    
     Always provided if `state` is `STATE_RUNNING`. May also be provided when `state` is one of
     the hardware errors if the software is still running.
    """

    error_info: str = betterproto.string_field(5)
    """
    Provides a textual description of error states.
    
     When `state` is not `STATE_INITIALISING`, `STATE_RUNNING` or `STATE_RESETTING`, this provides
     some information (in English) about the error. This will be a textual description of the
     value in `state`, possibly with extra information about the error (if available).
    
     This can be useful for dealing with (new) unknown states.
    """

    shared_hardware_group: "FlowCellPositionSharedHardwareGroup" = (
        betterproto.message_field(6)
    )
    """
    Some positions may share hardware. Positions that share hardware will have the same
     group-id. If positions do share hardware, to reset the hardware you will need to
     reset all positions in the group at the same time.
    """

    is_integrated: bool = betterproto.bool_field(7)
    """
    Indicates that this is an integrated flow cell position.
    
     This is true for the integrated positions on a PromethION, GridION or MinION Mk1C, and false
     for a MinION Mk1B.
    
     Integrated positions are always listed, even if (due to some hardware error) they can't be
     found. They are never in STATE_HARDWARE_REMOVED, and they always report a location.
    
     Since 4.4
    """

    can_sequence_offline: bool = betterproto.bool_field(8)
    """
    Indicates that this position can sequence offline.
    
     For integrated positions, this is the same as the corresponding field returned from the
     describe_host RPC.
    """

    protocol_state: "SimpleProtocolState" = betterproto.enum_field(9)
    """
    Indicates the state of the last or current protocol on the flow cell position.
    
     Since 5.0.
    """

    is_simulated: bool = betterproto.bool_field(10)
    """
    Whether the device is simulated.
    
     If this is true, there is no physical device - MinKNOW is simulating it. If it is false,
     MinKNOW will be acquiring data from a real device.
    
     Since 5.2
    """

    device_type: "_device__.GetDeviceInfoResponseDeviceType" = betterproto.enum_field(
        11
    )
    """
    The type of the device.
    
     Since 5.2
    """

    parent_name: str = betterproto.string_field(12)
    """
    The name of the device this flow cell position is part of.
    
     For an integrated position, this will be the host serial, as returned by describe_host().
    
     For a MinION Mk1B, this will be the same as the `name` field.
    
     For a P2 Solo, this will be the name of the P2 Solo unit.
    
     Since 5.3
    """

    firmware_is_updating: bool = betterproto.bool_field(13)
    """
    Firmware is updating on the device and it should not be unplugged.
    
     If the state is INITIALISING, this flag may be set to true to indicate that the device's
     persistent memory is being reprogrammed with new firmware. When this is the case, the device
     should not be unplugged, as there is a small chance this will cause the device to be rendered
     ununsable.
    
     It is not set for devices that do not come with firmware pre-loaded and have to have it
     loaded every time they are plugged in (like the MinION Mk1B), as unplugging these devices
     during firmware loading is fine.
    """

    has_progress: bool = betterproto.bool_field(14)
    """
    Indicates the progress_percent field is being used. See that field for more information.
    """

    progress_percent: int = betterproto.uint32_field(15)
    """
    Indicates progress through the current state.
    
     This is currently only used for long-running INITIALISING states, such as when firmware is
     being updated. If it is being used, has_progress will be true (which indicates it is
     sensible to display a progress bar even if progress_percent is currently 0).
    
     This field will always have values between 0 and 100 (inclusive), and the value will increase
     over time. It is intended for displaying a progress bar or similar.
    """

    progress_eta_seconds: int = betterproto.uint32_field(16)
    """
    Indicates roughly how much time is remaining in this state.
    
     If has_progress is true and this is non-zero, it will contain an estimate of how much time is
     left in this state. Currently it is only used for long-running INITIALISING states.
    
     If no ETA can be calculated, this will be zero.
    
     Note that it is always an estimate - it is recommended to round larger values, like "about 2
     minutes remaining".
    """


@dataclass(eq=False, repr=False)
class FlowCellPositionLocation(betterproto.Message):
    x: int = betterproto.int32_field(1)
    """
    The column (counting from 0, left-to-right) of the flow cell position on the sequencing
     unit when viewed from above/in front.
    """

    y: int = betterproto.int32_field(2)
    """
    The row (counting from 0, top-to-bottom) of the flow cell position on the sequencing
     unit when viewed from above/in front.
    """


@dataclass(eq=False, repr=False)
class FlowCellPositionRpcPorts(betterproto.Message):
    secure: int = betterproto.uint32_field(1)
    """A port providing the standard gRPC protocol over TLS"""

    secure_grpc_web: int = betterproto.uint32_field(3)
    """A port providing the gRPC-Web protocol over TLS"""


@dataclass(eq=False, repr=False)
class FlowCellPositionSharedHardwareGroup(betterproto.Message):
    group_id: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class FlowCellPositionsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class FlowCellPositionsResponse(betterproto.Message):
    total_count: int = betterproto.int32_field(1)
    """
    How many positions are available in total.
    
     This is the same in every message returned from a single call, and allows the caller to
     easily see how many further positions might be in subsequent messages.
    """

    positions: List["FlowCellPosition"] = betterproto.message_field(2)
    """
    Known flow cell positions.
    
     Note that not all positions listed here are necessarily available. In particular, integrated
     flow cell positions (eg: on GridIONs or PromethIONs) will always be listed.
    """


@dataclass(eq=False, repr=False)
class WatchFlowCellPositionsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class WatchFlowCellPositionsResponse(betterproto.Message):
    """
    Each flow cell position will first be listed in `additions`. After that, it may appear in
     `changes` in zero or more messages. Then, it may appear in `removals` once, after which it will
     either never appear again, or appear in `additions` again (restarting the cycle).

     No position will ever appear in more than one field in the same response message.
    """

    additions: List["FlowCellPosition"] = betterproto.message_field(1)
    """
    Flow cell positions that are new (to this call).
    
     Contains flow cell positions that have not been seen before on this call (or have re-appeared
     after being removed).
    
     Note that a flow cell position being listed here does not mean it is available. In
     particular, integrated flow cell positions (eg: on GridIONs or PromethIONs) will always be
     provided, so that they can be positioned appropriately.
    """

    changes: List["FlowCellPosition"] = betterproto.message_field(2)
    """
    Flow cell positions that have changed state.
    
     Every flow cell position provided in this list will have previously been provided in
     `additions`.
    """

    removals: List[str] = betterproto.string_field(3)
    """
    A flow cell position has been removed.
    
     Note that this can only happen with MinIONs - integrated flow cell positions are never
     removed (if they become unavailable, this will be noted in the `changes` field).
    """


@dataclass(eq=False, repr=False)
class ResetPositionRequest(betterproto.Message):
    positions: List[str] = betterproto.string_field(3)
    """The names of positions to restart."""

    force: bool = betterproto.bool_field(2)
    """
    Force the software to be restarted even when it appears to be in a healthy state (ie:
     STATE_RUNNING).
    """


@dataclass(eq=False, repr=False)
class ResetPositionResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class BasecallerApiRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class BasecallerApiResponse(betterproto.Message):
    secure: int = betterproto.uint32_field(1)
    """
    The port to use to access the minknow_api.basecaller API using the standard gRPC protocol
     over TLS
    """

    secure_grpc_web: int = betterproto.uint32_field(3)
    """
    The port to use to access the minknow_api.basecaller API using the gRPC-Web protocol over TLS
    """


@dataclass(eq=False, repr=False)
class GetGuppyInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetGuppyInfoResponse(betterproto.Message):
    port: int = betterproto.uint32_field(1, group="connection_type")
    """The port the basecaller is listening on."""

    ipc_path: str = betterproto.string_field(3, group="connection_type")
    """
    The path to an ipc file the basecaller is using.
     Use "ipc://<ipc_path>" for a basecaller connection string.
    """

    version: str = betterproto.string_field(2)
    """The basecaller server version."""


@dataclass(eq=False, repr=False)
class GetVersionInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListProtocolOutputDirFilesRequest(betterproto.Message):
    path: str = betterproto.string_field(1)
    """
    Specify the root path to list files from. If the path is left empty, then the base protocol output directory
     will be used.
    
     Note that the path specified HAS to be a descendant of the protocol output directory, otherwise a INVALID_ARGUMENT
     error will be returned
    
     If the path is left empty, and the path specified in the user config doesn't exist, then the NOT_FOUND error code
     will be returned
    """


@dataclass(eq=False, repr=False)
class ListProtocolOutputDirFilesResponse(betterproto.Message):
    directories: List["ListProtocolOutputDirFilesResponseDirectoryInfo"] = (
        betterproto.message_field(1)
    )
    """List of sub-directories in the directory specified"""

    files: List[str] = betterproto.string_field(2)
    """List of files in the directory specified"""

    current_listed_path: str = betterproto.string_field(3)
    """The absolute directory that is being listed within this response"""


@dataclass(eq=False, repr=False)
class ListProtocolOutputDirFilesResponseDirectoryInfo(betterproto.Message):
    name: str = betterproto.string_field(1)
    directory_count: int = betterproto.int32_field(2)
    file_count: int = betterproto.int32_field(3)


@dataclass(eq=False, repr=False)
class CreateDirectoryRequest(betterproto.Message):
    parent_path: str = betterproto.string_field(1)
    """
    The path at which to create the directory.
    
     This must exist, be a directory, and be within the protocol output directory. This can be
     determined via calls to list_protocol_output_dir_files().
    """

    name: str = betterproto.string_field(2)
    """
    The name of the directory to create.
    
     This must be a single path component (ie: it cannot contain '/' or '\'). There may be other
     restrictions on valid characters, depending on the operating system.
    """


@dataclass(eq=False, repr=False)
class CreateDirectoryResponse(betterproto.Message):
    path: str = betterproto.string_field(1)
    """The path to the created directory."""


@dataclass(eq=False, repr=False)
class FilesystemDiskSpaceInfo(betterproto.Message):
    """disk-usage information for one file-system"""

    filesystem_id: str = betterproto.string_field(1)
    """The name of the file-system"""

    bytes_available: int = betterproto.uint64_field(2)
    """How much space is left on the file-system"""

    bytes_capacity: int = betterproto.uint64_field(3)
    """The total capacity of the file-system when empty."""

    file_types_stored: List[str] = betterproto.string_field(4)
    """
    A list of what types of file MinKNOW stores on this file-system, eg:
     reads, logs, intermediate-files, etc.
    """

    bytes_to_stop_cleanly: int = betterproto.uint64_field(5)
    """
    MinKNOW needs this much space to stop experiments. If bytes_available
     goes below this number, data could be lost!
    """

    bytes_when_alert_issued: int = betterproto.uint64_field(6)
    """
    The amount of space left on the file-system when recommend_alert
     was set true.
    """

    recommend_alert: bool = betterproto.bool_field(7)
    """MinKNOW recommends that you alert someone about the disk-usage"""

    recommend_stop: bool = betterproto.bool_field(8)
    """
    MinKNOW recommends that you stop experiments due to disk-usage
     concerns
    """

    bytes_per_second: int = betterproto.int64_field(9)
    """
    Rate of change in bytes_available (per second) +'ve numbers indicate
     that bytes_available is decreasing and space is being used
     A value of 0 can indicate that this has not applicable or not available.
    """


@dataclass(eq=False, repr=False)
class GetDiskSpaceInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class StreamDiskSpaceInfoRequest(betterproto.Message):
    period: int = betterproto.uint32_field(1)
    """
    Disk space information will be streamed with this value determining the
     period in seconds between updates.
     A period of 0 is invalid
    """


@dataclass(eq=False, repr=False)
class GetDiskSpaceInfoResponse(betterproto.Message):
    filesystem_disk_space_info: List["FilesystemDiskSpaceInfo"] = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class GetBarcodeKitInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetBarcodeKitInfoResponse(betterproto.Message):
    barcode_kit_info: Dict[str, "GetBarcodeKitInfoResponseBarcodeKitInfo"] = (
        betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    """Map of barcode kit name to barcode kit info"""


@dataclass(eq=False, repr=False)
class GetBarcodeKitInfoResponseBarcodeKitInfo(betterproto.Message):
    is_dual: bool = betterproto.bool_field(2)
    """
    DEPRECATED 6.0: Dual barcoding support has been removed and this value will always false.
    """

    is_both_ends: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class GetLampKitInfoRequest(betterproto.Message):
    """DEPRECATED 6.0: Lamp support has been removed."""

    pass


@dataclass(eq=False, repr=False)
class GetLampKitInfoResponse(betterproto.Message):
    """
    DEPRECATED 6.0: Lamp support has been removed and this response will always be empty.
    """

    lamp_kits: List[str] = betterproto.string_field(2)
    """Lamp kit names"""


@dataclass(eq=False, repr=False)
class GetBarcodeKeysRequest(betterproto.Message):
    barcode_kit_names: List[str] = betterproto.string_field(1)
    """
    Names of barcode kits to obtain barcode names for
    
     Fails with INVALID_ARGUMENT if any of the requested `barcode_kit_names` are unavailable
    """

    lamp_kit_name: str = betterproto.string_field(2)
    """
    Name of lamp kit to obtain barcode names for.
    
     Fails with INVALID_ARGUMENT if the requested `lamp_kit_name` is unavailable.
    
     DEPRECATED 6.0: Lamp support has been removed and this option will be ignored.
    """


@dataclass(eq=False, repr=False)
class GetBarcodeKeysResponse(betterproto.Message):
    barcode_keys: List[str] = betterproto.string_field(1)
    """Returned barcode keys."""

    lamp_keys: List[str] = betterproto.string_field(2)
    """
    Returned lamp barcode ids.
    
     DEPRECATED 6.0: Lamp support has been removed and this value will always be empty.
    """

    combined_keys: List[str] = betterproto.string_field(3)
    """
    Combined barcode and lamp keys.
    
     Returned keys are joined strings of all requested barcode kits, giving the caller
     a unique string to identify each barcode pair.
    
     eg. if both a lamp kit + barcode kit are specified, NxM barcode keys are returned:
      - barcode01_lamp01
      - barcode01_lamp02
      - barcode01_lamp03
      - barcode02_lamp01
      - barcode02_lamp02
      - barcode02_lamp03
    
     DEPRECATED 6.0: Lamp support has been removed and this value will always be the same
     as barcode_keys.
    """


@dataclass(eq=False, repr=False)
class GetFlowCellTypesRequest(betterproto.Message):
    """Request message for `ManagerService.get_flow_cell_types`."""

    pass


@dataclass(eq=False, repr=False)
class GetFlowCellTypesResponse(betterproto.Message):
    """Response message for `ManagerService.get_flow_cell_types`."""

    types: List["GetFlowCellTypesResponseInfo"] = betterproto.message_field(1)
    """The flow cell types."""


@dataclass(eq=False, repr=False)
class GetFlowCellTypesResponseInfo(betterproto.Message):
    """Information about a flow cell type."""

    product_code: str = betterproto.string_field(1)
    """
    The product code for the flow cell type.
    
     This is the user-visible name for the flow cell type. It is the name used to order flow
     cells, and is also displayed on the packaging.
    
     While most product codes are 10 characters, be aware that longer product codes can exist
     and have been used in the past.
    
     Example: "FLO-MIN106".
    """

    connector_type: "_device__.FlowCellConnectorType" = betterproto.enum_field(2)
    """
    The connector type of this flow cell type.
    
     This determines which flow cell positions it is possible to insert this flow cell into.
     The connector type for a given flow cell position can be determined using
     `minknow_api.device.DeviceService.get_device_state`.
    
     This will never be ``FCCON_NOT_SET``.
    """

    cannot_live_basecall: bool = betterproto.bool_field(3)
    """
    Indicates that live basecalling is not possible on the flow cell.
    
     Note that almost all flow cell types can be basecalled on: that is why this indicates a
     negative (saving some bytes on the wire by allowing the common case of basecalling being
     possible to be omitted entirely).
    """


@dataclass(eq=False, repr=False)
class GetSequencingKitsRequest(betterproto.Message):
    """Request message for `ManagerService.get_sequencing_kits`."""

    flow_cell_product_code: str = betterproto.string_field(1)
    """
    The product code of the flow cell that will be used for sequencing.
    
     Only kits compatible with this flow cell type will be returned (currently, this means that
     there is at least one (sequencing or control) protocol that is compatible with both the kit
     and this flow cell product code).
    
     This may also affect the returned information about the kit. For example, if it isn't
     possible to basecall on the flow cell, none of the kits will claim to be barcoding capable
     (or compatible with any barcoding expansion kits).
    """


@dataclass(eq=False, repr=False)
class GetSequencingKitsResponse(betterproto.Message):
    """Response message for `ManagerService.get_sequencing_kits`."""

    kits: List["GetSequencingKitsResponseKit"] = betterproto.message_field(1)
    """The known sequencing kits."""

    barcoding_expansion_kits: List["GetSequencingKitsResponseBarcodingExpansionKit"] = (
        betterproto.message_field(2)
    )
    """
    The possible barcoding expansion kits.
    
     These are kits that can be used in combination with certain sequencing kits to add (or
     extend) barcoding functionality.
    """


@dataclass(eq=False, repr=False)
class GetSequencingKitsResponseKit(betterproto.Message):
    """Information about a sequencing kit."""

    product_code: str = betterproto.string_field(1)
    """
    The product code for the sequencing kit.
    
     This is the user-visible name for the kit. It is the name used to order kits, and is also
     displayed on the packaging.
    
     While most product codes are 10-15 characters, be aware that longer (or shorter) product
     codes can exist.
    
     Examples: "SQK-LSK109", "OND-SQK-LP0096S".
    """

    barcoding_expansion_kits: List[int] = betterproto.int32_field(2)
    """
    Compatible barcoding expansion kits.
    
     These are indexes into the GetSequencingKitsResponse.barcoding_expansion_kits list. For
     example, 0 would indicate the first kit in that list. The values are guaranteed to be
     unique and valid indexes for that list.
    """

    includes_barcoding: bool = betterproto.bool_field(3)
    """
    Whether barcoding support is part of the sequencing kit.
    
     If this is set, barcoding can be done without any expansion kits (and, in fact, barcoding
     is an integral part of the kit).
    """

    lamp_kit: bool = betterproto.bool_field(16)
    """
    Whether the kit can be used for LamPORE diagnostics.
    
     DEPRECATED 6.0: Lamp support has been removed and this value will always be false.
    """

    has_control_protocol: bool = betterproto.bool_field(4)
    """Whether there is a "control" protocol available for this kit."""

    no_sequencing_protocol: bool = betterproto.bool_field(17)
    """
    Indicates there is no sequencing protocol available for this kit.
    
     This is an unusual situation. If a kit is known about, it should generally have a
     sequencing protocol associated with it, and it would be strange to have a control
     protocol available but no sequencing protocol.
    """

    frequently_used: bool = betterproto.bool_field(18)
    """
    Indicates that the sequencing kit is one of the most commonly used ones.
    
     This can be used to display such kits first, or otherwise highlight them in some way.
    """

    dna: bool = betterproto.bool_field(5)
    """The kit can be used with DNA samples."""

    rna: bool = betterproto.bool_field(6)
    """The kit can be used with RNA samples."""

    pcr: bool = betterproto.bool_field(7)
    """The kit can be used with samples that have had PCR applied to them."""

    pcr_free: bool = betterproto.bool_field(8)
    """The kit can be used without a PCR step."""


@dataclass(eq=False, repr=False)
class GetSequencingKitsResponseBarcodingExpansionKit(betterproto.Message):
    """
    Information about a barcoding expansion kit.

     In the future, this may include compatibility information for dual barcoding, for example.
    """

    product_code: str = betterproto.string_field(1)
    """
    The product code for the barcoding expansion kit.
    
     This is the user-visible name for the kit. It is the name used to order kits, and is also
     displayed on the packaging.
    
     While most product codes are 10 characters, be aware that longer product codes can exist.
    
     Example: "EXP-NBD104".
    """


@dataclass(eq=False, repr=False)
class AddSimulatedDeviceRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    """
    The name of the position, this must be unique and the correct format:
    
     For MinION Mk1B and Mk1C: "MS" followed by five digits, eg: "MS12345".
     For GridION: "GS" followed by five digits, eg: "GS12345".
     For P2 Solo: "P2S_" followed by five digits, and then "-A" or "-B" eg: "P2S_12345-A".
    
     PromethION and P2 Solo position-names have no format restriction, but must be unique. It is
     strongly recommended to follow standard naming conventions:
    
     For PromethION: start with "1A" and then increase the number and/or the letter as you add
     more positions.
     For P2 Solo: use "P2S_00000-A" and "P2S_00000-B" (these fit the format of real P2 Solo devices,
     but do not correspond to any real device).
    
     Future versions might constrain PromethION and P2 Solo device names. Using the above
     suggestions should ensure that your code will continue to work.
    
     Note that MinKNOW Core 5.5 and earlier required the P2 Solo device name to be "P2S" followed
     by four digits. This is no longer recommended.
    """

    type: "SimulatedDeviceType" = betterproto.enum_field(2)
    """
    The type of the simulated device to create.
    
     If left at default (AUTO), then a sensible default device type is selected.
    """


@dataclass(eq=False, repr=False)
class AddSimulatedDeviceResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RemoveSimulatedDeviceRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    """The name of the simulated device to be removed"""


@dataclass(eq=False, repr=False)
class RemoveSimulatedDeviceResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class LocalAuthenticationTokenPathRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class LocalAuthenticationTokenPathResponse(betterproto.Message):
    path: str = betterproto.string_field(1)
    """The full path of the local authentication token"""


@dataclass(eq=False, repr=False)
class GetAlignmentReferenceInformationRequest(betterproto.Message):
    path: str = betterproto.string_field(1)
    """
    The full path of the alignment reference.
    
     Should be a .fasta, or .mmi file.
    """


@dataclass(eq=False, repr=False)
class GetAlignmentReferenceInformationResponse(betterproto.Message):
    estimated_load_time_seconds: float = betterproto.float_field(1)
    """Estimated load time of the reference in seconds."""

    estimated_reference_size_bases: int = betterproto.uint64_field(2)
    """Estimated size of the reference file in bases."""

    recommended_live_usage: bool = betterproto.bool_field(3)
    """
    Does the reference file fit within the recommended live usage memory size?
    
     This uses an estimate of how much memory a reference may use when running in the basecaller
     and compares to the amount of memory in the sequencer. It does not account for
     whether the reference will run in real time.
    """

    recommended_adaptive_sampling_usage: bool = betterproto.bool_field(4)
    """
    True if adaptive sampling is recommended
     based on reference file size in bases, and device type
    
     Since 6.0
    """

    max_recommended_adaptive_sampling_bases: int = betterproto.uint64_field(5)
    """
    The maximum limit for adaptive sampling number of bases
     based on device type
    
     Since 6.0
    """


@dataclass(eq=False, repr=False)
class AssociationDeviceCodeRequest(betterproto.Message):
    """DEPRECATED: since 6.2 device association is no-longer required."""

    position_name: str = betterproto.string_field(1)
    """
    The flow cell position to get the association code/key for.
    
     If this is omitted, the code/key for the sequencing device as a whole is returned.
    
     Note that this cannot be omitted if MinKNOW is installed on a PC (as opposed to a sequencing
     device). It should be omitted if (and only if) the data returned from `describe_host` has
     its ``needs_association`` field set to true.
    
     Passing a integrated flow cell position will return the code/key for the whole sequencing
     device.
    """


@dataclass(eq=False, repr=False)
class AssociationDeviceCodeResponse(betterproto.Message):
    """DEPRECATED: since 6.2 device association is no-longer required."""

    code: str = betterproto.string_field(1)
    """
    The code required to associate the device with an account.
    
     If the request had `offline` set, this code is suitable for use in the customer portal
     offline association page. Otherwise, it is suitable for the online association APIs.
    """


@dataclass(eq=False, repr=False)
class ApplyOfflineAssociationUnlockCodeRequest(betterproto.Message):
    """DEPRECATED: since 6.2 device association is no-longer required."""

    position_name: str = betterproto.string_field(1)
    """
    The flow cell position to unlock.
    
     This should be set (or not set) to match the corresponding call to
     `offline_association_device_code`.
    """

    unlock_code: str = betterproto.string_field(2)
    """
    The unlock code provided by the user.
    
     This the code given by the customer support portal when the corresponding device code is
     entered into the device association page.
    """


@dataclass(eq=False, repr=False)
class ApplyOfflineAssociationUnlockCodeResponse(betterproto.Message):
    """DEPRECATED: since 6.2 device association is no-longer required."""

    associated: bool = betterproto.bool_field(1)
    """
    True if the association was successful (the unlock_code was accepted), false otherwise.
    """


@dataclass(eq=False, repr=False)
class ListDeveloperApiTokensRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListDeveloperApiTokensResponse(betterproto.Message):
    tokens: List["ListDeveloperApiTokensResponseDeveloperApiToken"] = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ListDeveloperApiTokensResponseDeveloperApiToken(betterproto.Message):
    id: str = betterproto.string_field(1)
    """Unique ID assigned to the token."""

    name: str = betterproto.string_field(2)
    """
    User facing name describing the token (guaranteed unique across tokens).
    """

    expiry: datetime = betterproto.message_field(3)
    """Optional expiry of the token."""


@dataclass(eq=False, repr=False)
class CreateDeveloperApiTokenRequest(betterproto.Message):
    name: str = betterproto.string_field(2)
    """User facing name describing the token."""

    expiry: datetime = betterproto.message_field(3)
    """Optional expiry time for the token."""


@dataclass(eq=False, repr=False)
class CreateDeveloperApiTokenResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    Unique ID assigned to the token for identification purposes. Not valid as an authentication token.
    """

    token: str = betterproto.string_field(2)
    """Created token, available to be used with minknow API's immediately."""


@dataclass(eq=False, repr=False)
class RevokeDeveloperApiTokenRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    The id passed back from [CreateDeveloperApiTokenRequest] or [DeveloperApiToken].
    """


@dataclass(eq=False, repr=False)
class RevokeDeveloperApiTokensResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class FindProtocolsRequest(betterproto.Message):
    flow_cell_product_code: str = betterproto.string_field(1)
    """
    Find protocols that are compatible with this flow cell product code.
    
     Set to empty string to find protocols matching all flow cell product codes.
    """

    sequencing_kit: str = betterproto.string_field(2)
    """
    Limit to protocols that are compatible with this sequencing kit.
    
     Set to empty string to find protocols matching all kits.
    """

    experiment_type: "ExperimentType" = betterproto.enum_field(3)
    """Limit response to certain protocol types."""


@dataclass(eq=False, repr=False)
class FindProtocolsResponse(betterproto.Message):
    protocols: List["FindProtocolsResponseProtocol"] = betterproto.message_field(1)
    """Protocols available for starting."""


@dataclass(eq=False, repr=False)
class FindProtocolsResponseProtocol(betterproto.Message):
    identifier: str = betterproto.string_field(1)
    """
    An identifying string for protocol, of the form: LOCATION:relative/path/to/protocol
    
     The identifier uniquely identifies the protocol.
    """

    requires_flow_cell_product_code: bool = betterproto.bool_field(2)
    """
    Whether the protocol requires a flow cell product code in order to start.
    """

    requires_sequencing_kit: bool = betterproto.bool_field(3)
    """Whether the protocol requires a sequencing kit in order to start."""


@dataclass(eq=False, repr=False)
class ListSettingsForProtocolRequest(betterproto.Message):
    identifier: str = betterproto.string_field(1, group="protocol_identifier")
    """
    specify the protocol with a string containing all the protocol's identifying components, eg:
     "sequencing/sequencing_MIN106_DNA:FLO-MIN106:SQK-RPB004"
    """

    components: "_protocol_settings__.ProtocolIdentifierComponents" = (
        betterproto.message_field(2, group="protocol_identifier")
    )
    """
    specify the protocol providing the identifying components individually. All components are optional, if more
     than one protocol matches given strings, information about the first will be returned.
    """

    flow_cell_connector: "_device__.FlowCellConnectorType" = betterproto.enum_field(3)
    """
    The flow-cell connector type identifies the type of hardware and is used
     to identify the correct protocol.
     The flow-cell connector types applicable to the device are listed by
     the get_flow_cell_types rpc in this service and the get_device_state rpc
     in the device service.
    """


@dataclass(eq=False, repr=False)
class ListSettingsForProtocolResponse(betterproto.Message):
    protocol: "_protocol_settings__.ProtocolIdentifierComponents" = (
        betterproto.message_field(1)
    )
    run_options: "ListSettingsForProtocolResponseRunOptions" = (
        betterproto.message_field(2)
    )
    basecalling: "ListSettingsForProtocolResponseBasecalling" = (
        betterproto.message_field(3)
    )
    output: "ListSettingsForProtocolResponseOutput" = betterproto.message_field(4)
    protocol_settings: List["_protocol_settings__.ProtocolSetting"] = (
        betterproto.message_field(5)
    )
    """
    Any protocol settings not covered by the above structures, for example
     those required for custom-scripts.
    """


@dataclass(eq=False, repr=False)
class ListSettingsForProtocolResponseRunOptions(betterproto.Message):
    """Run options"""

    run_length: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(1)
    bias_voltage: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(2)
    read_until_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(3)
    )
    read_until_ref_file: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(4)
    )
    read_until_channels: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(5)
    )
    read_until_bed_file_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(6)
    )
    read_until_bed_file: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(7)
    )
    read_until_enrichment: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(8)
    )
    active_channel_selection: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(9)
    )
    mux_scan_period: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        10
    )
    group_change_period: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(11)
    )


@dataclass(eq=False, repr=False)
class ListSettingsForProtocolResponseBasecalling(betterproto.Message):
    basecalling_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(1)
    )
    barcoding_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(2)
    )
    barcoding_kits: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        3
    )
    basecall_model: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        4
    )
    trim_barcodes_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(5)
    )
    require_barcodes_both_ends: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(6)
    )
    alignment_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(13)
    )
    alignment_ref_file: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(14)
    )
    alignment_bed_file_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(15)
    )
    alignment_bed_file: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(16)
    )


@dataclass(eq=False, repr=False)
class ListSettingsForProtocolResponseOutput(betterproto.Message):
    """Output"""

    output_location: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        1
    )
    fast_q_enabled: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        2
    )
    fast_q_reads_per_file: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(3)
    )
    fast_q_data_compression: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(4)
    )
    fast_5_enabled: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        5
    )
    fast_5_reads_per_file: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(6)
    )
    fast_5_data_trace_table: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(7)
    )
    fast_5_data_move_table: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(8)
    )
    fast_5_data_fast_q: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(9)
    )
    fast_5_data_raw: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        10
    )
    fast_5_data_compression: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(11)
    )
    bam_enabled: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(12)
    read_filtering_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(13)
    )
    read_filtering_min_qscore: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(14)
    )
    read_filtering_min_read_length: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(15)
    )
    read_filtering_max_read_length: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(16)
    )
    bulk_file_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(17)
    )
    bulk_file_raw: "_protocol_settings__.ProtocolSetting" = betterproto.message_field(
        18
    )
    bulk_file_events: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(19)
    )
    bulk_file_read_table: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(20)
    )
    bulk_file_raw_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(21)
    )
    bulk_file_events_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(22)
    )
    bulk_file_read_table_enabled: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(23)
    )
    read_filtering_min_duplex_qscore: "_protocol_settings__.ProtocolSetting" = (
        betterproto.message_field(24)
    )
    """Since 5.8"""


@dataclass(eq=False, repr=False)
class Feature(betterproto.Message):
    enabled: bool = betterproto.bool_field(1)
    """Enable or disable the feature"""


@dataclass(eq=False, repr=False)
class FeatureList(betterproto.Message):
    feature_flags: "Feature" = betterproto.message_field(3)
    """
    feature_flags is a special value
     If false, turns off all other feature flags
     If true, allows individual flags to be enabled and disabled
    """

    enrich_deplete: "Feature" = betterproto.message_field(1)
    barcode_balancing: "Feature" = betterproto.message_field(2)
    data_offload: "Feature" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class GetFeaturesRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetFeaturesResponse(betterproto.Message):
    state: "GetFeaturesResponseState" = betterproto.enum_field(1)
    features: "FeatureList" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class SetFeaturesRequest(betterproto.Message):
    features: "FeatureList" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SetFeaturesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RestartDeviceAdminRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RestartDeviceAdminResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CheckBedFileRequest(betterproto.Message):
    bed_file_path: str = betterproto.string_field(1)
    """The path to the BED file to validate"""

    index_file_path: str = betterproto.string_field(2)
    """
    The path to the index file that the BED file should validate against
    
     Can be a .fasta, .fai or .mmi file
    """

    strict: bool = betterproto.bool_field(3)
    """
    Strictly conforms to the BED file specification and allows both tabs and spaces
     to be used as delimiters between columns
    """

    stranded: bool = betterproto.bool_field(4)
    """Check strand values are allowed"""


@dataclass(eq=False, repr=False)
class CheckBedFileResponse(betterproto.Message):
    passed: bool = betterproto.bool_field(1)


class ManagerServiceStub(betterproto.ServiceStub):
    async def describe_host(
        self,
        describe_host_request: "DescribeHostRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DescribeHostResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/describe_host",
            describe_host_request,
            DescribeHostResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_basecaller_features(
        self,
        get_basecaller_features_request: "GetBasecallerFeaturesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetBasecallerFeaturesResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_basecaller_features",
            get_basecaller_features_request,
            GetBasecallerFeaturesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def flow_cell_positions(
        self,
        flow_cell_positions_request: "FlowCellPositionsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[FlowCellPositionsResponse]:
        async for response in self._unary_stream(
            "/minknow_api.manager.ManagerService/flow_cell_positions",
            flow_cell_positions_request,
            FlowCellPositionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def watch_flow_cell_positions(
        self,
        watch_flow_cell_positions_request: "WatchFlowCellPositionsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[WatchFlowCellPositionsResponse]:
        async for response in self._unary_stream(
            "/minknow_api.manager.ManagerService/watch_flow_cell_positions",
            watch_flow_cell_positions_request,
            WatchFlowCellPositionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def reset_position(
        self,
        reset_position_request: "ResetPositionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ResetPositionResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/reset_position",
            reset_position_request,
            ResetPositionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def basecaller_api(
        self,
        basecaller_api_request: "BasecallerApiRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BasecallerApiResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/basecaller_api",
            basecaller_api_request,
            BasecallerApiResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_guppy_info(
        self,
        get_guppy_info_request: "GetGuppyInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetGuppyInfoResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_guppy_info",
            get_guppy_info_request,
            GetGuppyInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_version_info(
        self,
        get_version_info_request: "GetVersionInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "_instance__.GetVersionInfoResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_version_info",
            get_version_info_request,
            _instance__.GetVersionInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_protocol_output_dir_files(
        self,
        list_protocol_output_dir_files_request: "ListProtocolOutputDirFilesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[ListProtocolOutputDirFilesResponse]:
        async for response in self._unary_stream(
            "/minknow_api.manager.ManagerService/list_protocol_output_dir_files",
            list_protocol_output_dir_files_request,
            ListProtocolOutputDirFilesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def create_directory(
        self,
        create_directory_request: "CreateDirectoryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateDirectoryResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/create_directory",
            create_directory_request,
            CreateDirectoryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_disk_space_info(
        self,
        get_disk_space_info_request: "GetDiskSpaceInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDiskSpaceInfoResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_disk_space_info",
            get_disk_space_info_request,
            GetDiskSpaceInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_default_output_directories(
        self,
        instance_get_default_output_directories_request: "_instance__.GetDefaultOutputDirectoriesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "_instance__.OutputDirectories":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_default_output_directories",
            instance_get_default_output_directories_request,
            _instance__.OutputDirectories,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_disk_space_info(
        self,
        stream_disk_space_info_request: "StreamDiskSpaceInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetDiskSpaceInfoResponse]:
        async for response in self._unary_stream(
            "/minknow_api.manager.ManagerService/stream_disk_space_info",
            stream_disk_space_info_request,
            GetDiskSpaceInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_barcode_kit_info(
        self,
        get_barcode_kit_info_request: "GetBarcodeKitInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetBarcodeKitInfoResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_barcode_kit_info",
            get_barcode_kit_info_request,
            GetBarcodeKitInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_lamp_kit_info(
        self,
        get_lamp_kit_info_request: "GetLampKitInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetLampKitInfoResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_lamp_kit_info",
            get_lamp_kit_info_request,
            GetLampKitInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_barcode_keys(
        self,
        get_barcode_keys_request: "GetBarcodeKeysRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetBarcodeKeysResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_barcode_keys",
            get_barcode_keys_request,
            GetBarcodeKeysResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_flow_cell_types(
        self,
        get_flow_cell_types_request: "GetFlowCellTypesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetFlowCellTypesResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_flow_cell_types",
            get_flow_cell_types_request,
            GetFlowCellTypesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_sequencing_kits(
        self,
        get_sequencing_kits_request: "GetSequencingKitsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetSequencingKitsResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_sequencing_kits",
            get_sequencing_kits_request,
            GetSequencingKitsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def add_simulated_device(
        self,
        add_simulated_device_request: "AddSimulatedDeviceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AddSimulatedDeviceResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/add_simulated_device",
            add_simulated_device_request,
            AddSimulatedDeviceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def remove_simulated_device(
        self,
        remove_simulated_device_request: "RemoveSimulatedDeviceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RemoveSimulatedDeviceResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/remove_simulated_device",
            remove_simulated_device_request,
            RemoveSimulatedDeviceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def local_authentication_token_path(
        self,
        local_authentication_token_path_request: "LocalAuthenticationTokenPathRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "LocalAuthenticationTokenPathResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/local_authentication_token_path",
            local_authentication_token_path_request,
            LocalAuthenticationTokenPathResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_alignment_reference_information(
        self,
        get_alignment_reference_information_request: "GetAlignmentReferenceInformationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetAlignmentReferenceInformationResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_alignment_reference_information",
            get_alignment_reference_information_request,
            GetAlignmentReferenceInformationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def association_device_code(
        self,
        association_device_code_request: "AssociationDeviceCodeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AssociationDeviceCodeResponse":
        warnings.warn(
            "ManagerService.association_device_code is deprecated", DeprecationWarning
        )

        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/association_device_code",
            association_device_code_request,
            AssociationDeviceCodeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def apply_offline_association_unlock_code(
        self,
        apply_offline_association_unlock_code_request: "ApplyOfflineAssociationUnlockCodeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ApplyOfflineAssociationUnlockCodeResponse":
        warnings.warn(
            "ManagerService.apply_offline_association_unlock_code is deprecated",
            DeprecationWarning,
        )

        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/apply_offline_association_unlock_code",
            apply_offline_association_unlock_code_request,
            ApplyOfflineAssociationUnlockCodeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_developer_api_tokens(
        self,
        list_developer_api_tokens_request: "ListDeveloperApiTokensRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListDeveloperApiTokensResponse":
        warnings.warn(
            "ManagerService.list_developer_api_tokens is deprecated", DeprecationWarning
        )

        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/list_developer_api_tokens",
            list_developer_api_tokens_request,
            ListDeveloperApiTokensResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_developer_api_token(
        self,
        create_developer_api_token_request: "CreateDeveloperApiTokenRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateDeveloperApiTokenResponse":
        warnings.warn(
            "ManagerService.create_developer_api_token is deprecated",
            DeprecationWarning,
        )

        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/create_developer_api_token",
            create_developer_api_token_request,
            CreateDeveloperApiTokenResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def revoke_developer_api_token(
        self,
        revoke_developer_api_token_request: "RevokeDeveloperApiTokenRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RevokeDeveloperApiTokensResponse":
        warnings.warn(
            "ManagerService.revoke_developer_api_token is deprecated",
            DeprecationWarning,
        )

        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/revoke_developer_api_token",
            revoke_developer_api_token_request,
            RevokeDeveloperApiTokensResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def find_protocols(
        self,
        find_protocols_request: "FindProtocolsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FindProtocolsResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/find_protocols",
            find_protocols_request,
            FindProtocolsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_settings_for_protocol(
        self,
        list_settings_for_protocol_request: "ListSettingsForProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListSettingsForProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/list_settings_for_protocol",
            list_settings_for_protocol_request,
            ListSettingsForProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_features(
        self,
        get_features_request: "GetFeaturesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetFeaturesResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/get_features",
            get_features_request,
            GetFeaturesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_features(
        self,
        set_features_request: "SetFeaturesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetFeaturesResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/set_features",
            set_features_request,
            SetFeaturesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def restart_device_admin_service(
        self,
        restart_device_admin_request: "RestartDeviceAdminRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RestartDeviceAdminResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/restart_device_admin_service",
            restart_device_admin_request,
            RestartDeviceAdminResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def check_bed_file(
        self,
        check_bed_file_request: "CheckBedFileRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CheckBedFileResponse":
        return await self._unary_unary(
            "/minknow_api.manager.ManagerService/check_bed_file",
            check_bed_file_request,
            CheckBedFileResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ManagerServiceBase(ServiceBase):

    async def describe_host(
        self, describe_host_request: "DescribeHostRequest"
    ) -> "DescribeHostResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_basecaller_features(
        self, get_basecaller_features_request: "GetBasecallerFeaturesRequest"
    ) -> "GetBasecallerFeaturesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def flow_cell_positions(
        self, flow_cell_positions_request: "FlowCellPositionsRequest"
    ) -> AsyncIterator[FlowCellPositionsResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield FlowCellPositionsResponse()

    async def watch_flow_cell_positions(
        self, watch_flow_cell_positions_request: "WatchFlowCellPositionsRequest"
    ) -> AsyncIterator[WatchFlowCellPositionsResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield WatchFlowCellPositionsResponse()

    async def reset_position(
        self, reset_position_request: "ResetPositionRequest"
    ) -> "ResetPositionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def basecaller_api(
        self, basecaller_api_request: "BasecallerApiRequest"
    ) -> "BasecallerApiResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_guppy_info(
        self, get_guppy_info_request: "GetGuppyInfoRequest"
    ) -> "GetGuppyInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_version_info(
        self, get_version_info_request: "GetVersionInfoRequest"
    ) -> "_instance__.GetVersionInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_protocol_output_dir_files(
        self,
        list_protocol_output_dir_files_request: "ListProtocolOutputDirFilesRequest",
    ) -> AsyncIterator[ListProtocolOutputDirFilesResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ListProtocolOutputDirFilesResponse()

    async def create_directory(
        self, create_directory_request: "CreateDirectoryRequest"
    ) -> "CreateDirectoryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_disk_space_info(
        self, get_disk_space_info_request: "GetDiskSpaceInfoRequest"
    ) -> "GetDiskSpaceInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_default_output_directories(
        self,
        instance_get_default_output_directories_request: "_instance__.GetDefaultOutputDirectoriesRequest",
    ) -> "_instance__.OutputDirectories":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_disk_space_info(
        self, stream_disk_space_info_request: "StreamDiskSpaceInfoRequest"
    ) -> AsyncIterator[GetDiskSpaceInfoResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetDiskSpaceInfoResponse()

    async def get_barcode_kit_info(
        self, get_barcode_kit_info_request: "GetBarcodeKitInfoRequest"
    ) -> "GetBarcodeKitInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_lamp_kit_info(
        self, get_lamp_kit_info_request: "GetLampKitInfoRequest"
    ) -> "GetLampKitInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_barcode_keys(
        self, get_barcode_keys_request: "GetBarcodeKeysRequest"
    ) -> "GetBarcodeKeysResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_flow_cell_types(
        self, get_flow_cell_types_request: "GetFlowCellTypesRequest"
    ) -> "GetFlowCellTypesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_sequencing_kits(
        self, get_sequencing_kits_request: "GetSequencingKitsRequest"
    ) -> "GetSequencingKitsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_simulated_device(
        self, add_simulated_device_request: "AddSimulatedDeviceRequest"
    ) -> "AddSimulatedDeviceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def remove_simulated_device(
        self, remove_simulated_device_request: "RemoveSimulatedDeviceRequest"
    ) -> "RemoveSimulatedDeviceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def local_authentication_token_path(
        self,
        local_authentication_token_path_request: "LocalAuthenticationTokenPathRequest",
    ) -> "LocalAuthenticationTokenPathResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_alignment_reference_information(
        self,
        get_alignment_reference_information_request: "GetAlignmentReferenceInformationRequest",
    ) -> "GetAlignmentReferenceInformationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def association_device_code(
        self, association_device_code_request: "AssociationDeviceCodeRequest"
    ) -> "AssociationDeviceCodeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def apply_offline_association_unlock_code(
        self,
        apply_offline_association_unlock_code_request: "ApplyOfflineAssociationUnlockCodeRequest",
    ) -> "ApplyOfflineAssociationUnlockCodeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_developer_api_tokens(
        self, list_developer_api_tokens_request: "ListDeveloperApiTokensRequest"
    ) -> "ListDeveloperApiTokensResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_developer_api_token(
        self, create_developer_api_token_request: "CreateDeveloperApiTokenRequest"
    ) -> "CreateDeveloperApiTokenResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def revoke_developer_api_token(
        self, revoke_developer_api_token_request: "RevokeDeveloperApiTokenRequest"
    ) -> "RevokeDeveloperApiTokensResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def find_protocols(
        self, find_protocols_request: "FindProtocolsRequest"
    ) -> "FindProtocolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_settings_for_protocol(
        self, list_settings_for_protocol_request: "ListSettingsForProtocolRequest"
    ) -> "ListSettingsForProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_features(
        self, get_features_request: "GetFeaturesRequest"
    ) -> "GetFeaturesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_features(
        self, set_features_request: "SetFeaturesRequest"
    ) -> "SetFeaturesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def restart_device_admin_service(
        self, restart_device_admin_request: "RestartDeviceAdminRequest"
    ) -> "RestartDeviceAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def check_bed_file(
        self, check_bed_file_request: "CheckBedFileRequest"
    ) -> "CheckBedFileResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_describe_host(
        self, stream: "grpclib.server.Stream[DescribeHostRequest, DescribeHostResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.describe_host(request)
        await stream.send_message(response)

    async def __rpc_get_basecaller_features(
        self,
        stream: "grpclib.server.Stream[GetBasecallerFeaturesRequest, GetBasecallerFeaturesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_basecaller_features(request)
        await stream.send_message(response)

    async def __rpc_flow_cell_positions(
        self,
        stream: "grpclib.server.Stream[FlowCellPositionsRequest, FlowCellPositionsResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.flow_cell_positions,
            stream,
            request,
        )

    async def __rpc_watch_flow_cell_positions(
        self,
        stream: "grpclib.server.Stream[WatchFlowCellPositionsRequest, WatchFlowCellPositionsResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.watch_flow_cell_positions,
            stream,
            request,
        )

    async def __rpc_reset_position(
        self,
        stream: "grpclib.server.Stream[ResetPositionRequest, ResetPositionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.reset_position(request)
        await stream.send_message(response)

    async def __rpc_basecaller_api(
        self,
        stream: "grpclib.server.Stream[BasecallerApiRequest, BasecallerApiResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.basecaller_api(request)
        await stream.send_message(response)

    async def __rpc_get_guppy_info(
        self, stream: "grpclib.server.Stream[GetGuppyInfoRequest, GetGuppyInfoResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_guppy_info(request)
        await stream.send_message(response)

    async def __rpc_get_version_info(
        self,
        stream: "grpclib.server.Stream[GetVersionInfoRequest, _instance__.GetVersionInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_version_info(request)
        await stream.send_message(response)

    async def __rpc_list_protocol_output_dir_files(
        self,
        stream: "grpclib.server.Stream[ListProtocolOutputDirFilesRequest, ListProtocolOutputDirFilesResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.list_protocol_output_dir_files,
            stream,
            request,
        )

    async def __rpc_create_directory(
        self,
        stream: "grpclib.server.Stream[CreateDirectoryRequest, CreateDirectoryResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_directory(request)
        await stream.send_message(response)

    async def __rpc_get_disk_space_info(
        self,
        stream: "grpclib.server.Stream[GetDiskSpaceInfoRequest, GetDiskSpaceInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_disk_space_info(request)
        await stream.send_message(response)

    async def __rpc_get_default_output_directories(
        self,
        stream: "grpclib.server.Stream[_instance__.GetDefaultOutputDirectoriesRequest, _instance__.OutputDirectories]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_default_output_directories(request)
        await stream.send_message(response)

    async def __rpc_stream_disk_space_info(
        self,
        stream: "grpclib.server.Stream[StreamDiskSpaceInfoRequest, GetDiskSpaceInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_disk_space_info,
            stream,
            request,
        )

    async def __rpc_get_barcode_kit_info(
        self,
        stream: "grpclib.server.Stream[GetBarcodeKitInfoRequest, GetBarcodeKitInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_barcode_kit_info(request)
        await stream.send_message(response)

    async def __rpc_get_lamp_kit_info(
        self,
        stream: "grpclib.server.Stream[GetLampKitInfoRequest, GetLampKitInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_lamp_kit_info(request)
        await stream.send_message(response)

    async def __rpc_get_barcode_keys(
        self,
        stream: "grpclib.server.Stream[GetBarcodeKeysRequest, GetBarcodeKeysResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_barcode_keys(request)
        await stream.send_message(response)

    async def __rpc_get_flow_cell_types(
        self,
        stream: "grpclib.server.Stream[GetFlowCellTypesRequest, GetFlowCellTypesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_flow_cell_types(request)
        await stream.send_message(response)

    async def __rpc_get_sequencing_kits(
        self,
        stream: "grpclib.server.Stream[GetSequencingKitsRequest, GetSequencingKitsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_sequencing_kits(request)
        await stream.send_message(response)

    async def __rpc_add_simulated_device(
        self,
        stream: "grpclib.server.Stream[AddSimulatedDeviceRequest, AddSimulatedDeviceResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_simulated_device(request)
        await stream.send_message(response)

    async def __rpc_remove_simulated_device(
        self,
        stream: "grpclib.server.Stream[RemoveSimulatedDeviceRequest, RemoveSimulatedDeviceResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.remove_simulated_device(request)
        await stream.send_message(response)

    async def __rpc_local_authentication_token_path(
        self,
        stream: "grpclib.server.Stream[LocalAuthenticationTokenPathRequest, LocalAuthenticationTokenPathResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.local_authentication_token_path(request)
        await stream.send_message(response)

    async def __rpc_get_alignment_reference_information(
        self,
        stream: "grpclib.server.Stream[GetAlignmentReferenceInformationRequest, GetAlignmentReferenceInformationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_alignment_reference_information(request)
        await stream.send_message(response)

    async def __rpc_association_device_code(
        self,
        stream: "grpclib.server.Stream[AssociationDeviceCodeRequest, AssociationDeviceCodeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.association_device_code(request)
        await stream.send_message(response)

    async def __rpc_apply_offline_association_unlock_code(
        self,
        stream: "grpclib.server.Stream[ApplyOfflineAssociationUnlockCodeRequest, ApplyOfflineAssociationUnlockCodeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.apply_offline_association_unlock_code(request)
        await stream.send_message(response)

    async def __rpc_list_developer_api_tokens(
        self,
        stream: "grpclib.server.Stream[ListDeveloperApiTokensRequest, ListDeveloperApiTokensResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_developer_api_tokens(request)
        await stream.send_message(response)

    async def __rpc_create_developer_api_token(
        self,
        stream: "grpclib.server.Stream[CreateDeveloperApiTokenRequest, CreateDeveloperApiTokenResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_developer_api_token(request)
        await stream.send_message(response)

    async def __rpc_revoke_developer_api_token(
        self,
        stream: "grpclib.server.Stream[RevokeDeveloperApiTokenRequest, RevokeDeveloperApiTokensResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.revoke_developer_api_token(request)
        await stream.send_message(response)

    async def __rpc_find_protocols(
        self,
        stream: "grpclib.server.Stream[FindProtocolsRequest, FindProtocolsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.find_protocols(request)
        await stream.send_message(response)

    async def __rpc_list_settings_for_protocol(
        self,
        stream: "grpclib.server.Stream[ListSettingsForProtocolRequest, ListSettingsForProtocolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_settings_for_protocol(request)
        await stream.send_message(response)

    async def __rpc_get_features(
        self, stream: "grpclib.server.Stream[GetFeaturesRequest, GetFeaturesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_features(request)
        await stream.send_message(response)

    async def __rpc_set_features(
        self, stream: "grpclib.server.Stream[SetFeaturesRequest, SetFeaturesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_features(request)
        await stream.send_message(response)

    async def __rpc_restart_device_admin_service(
        self,
        stream: "grpclib.server.Stream[RestartDeviceAdminRequest, RestartDeviceAdminResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.restart_device_admin_service(request)
        await stream.send_message(response)

    async def __rpc_check_bed_file(
        self, stream: "grpclib.server.Stream[CheckBedFileRequest, CheckBedFileResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.check_bed_file(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.manager.ManagerService/describe_host": grpclib.const.Handler(
                self.__rpc_describe_host,
                grpclib.const.Cardinality.UNARY_UNARY,
                DescribeHostRequest,
                DescribeHostResponse,
            ),
            "/minknow_api.manager.ManagerService/get_basecaller_features": grpclib.const.Handler(
                self.__rpc_get_basecaller_features,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetBasecallerFeaturesRequest,
                GetBasecallerFeaturesResponse,
            ),
            "/minknow_api.manager.ManagerService/flow_cell_positions": grpclib.const.Handler(
                self.__rpc_flow_cell_positions,
                grpclib.const.Cardinality.UNARY_STREAM,
                FlowCellPositionsRequest,
                FlowCellPositionsResponse,
            ),
            "/minknow_api.manager.ManagerService/watch_flow_cell_positions": grpclib.const.Handler(
                self.__rpc_watch_flow_cell_positions,
                grpclib.const.Cardinality.UNARY_STREAM,
                WatchFlowCellPositionsRequest,
                WatchFlowCellPositionsResponse,
            ),
            "/minknow_api.manager.ManagerService/reset_position": grpclib.const.Handler(
                self.__rpc_reset_position,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResetPositionRequest,
                ResetPositionResponse,
            ),
            "/minknow_api.manager.ManagerService/basecaller_api": grpclib.const.Handler(
                self.__rpc_basecaller_api,
                grpclib.const.Cardinality.UNARY_UNARY,
                BasecallerApiRequest,
                BasecallerApiResponse,
            ),
            "/minknow_api.manager.ManagerService/get_guppy_info": grpclib.const.Handler(
                self.__rpc_get_guppy_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetGuppyInfoRequest,
                GetGuppyInfoResponse,
            ),
            "/minknow_api.manager.ManagerService/get_version_info": grpclib.const.Handler(
                self.__rpc_get_version_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetVersionInfoRequest,
                _instance__.GetVersionInfoResponse,
            ),
            "/minknow_api.manager.ManagerService/list_protocol_output_dir_files": grpclib.const.Handler(
                self.__rpc_list_protocol_output_dir_files,
                grpclib.const.Cardinality.UNARY_STREAM,
                ListProtocolOutputDirFilesRequest,
                ListProtocolOutputDirFilesResponse,
            ),
            "/minknow_api.manager.ManagerService/create_directory": grpclib.const.Handler(
                self.__rpc_create_directory,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateDirectoryRequest,
                CreateDirectoryResponse,
            ),
            "/minknow_api.manager.ManagerService/get_disk_space_info": grpclib.const.Handler(
                self.__rpc_get_disk_space_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDiskSpaceInfoRequest,
                GetDiskSpaceInfoResponse,
            ),
            "/minknow_api.manager.ManagerService/get_default_output_directories": grpclib.const.Handler(
                self.__rpc_get_default_output_directories,
                grpclib.const.Cardinality.UNARY_UNARY,
                _instance__.GetDefaultOutputDirectoriesRequest,
                _instance__.OutputDirectories,
            ),
            "/minknow_api.manager.ManagerService/stream_disk_space_info": grpclib.const.Handler(
                self.__rpc_stream_disk_space_info,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamDiskSpaceInfoRequest,
                GetDiskSpaceInfoResponse,
            ),
            "/minknow_api.manager.ManagerService/get_barcode_kit_info": grpclib.const.Handler(
                self.__rpc_get_barcode_kit_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetBarcodeKitInfoRequest,
                GetBarcodeKitInfoResponse,
            ),
            "/minknow_api.manager.ManagerService/get_lamp_kit_info": grpclib.const.Handler(
                self.__rpc_get_lamp_kit_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetLampKitInfoRequest,
                GetLampKitInfoResponse,
            ),
            "/minknow_api.manager.ManagerService/get_barcode_keys": grpclib.const.Handler(
                self.__rpc_get_barcode_keys,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetBarcodeKeysRequest,
                GetBarcodeKeysResponse,
            ),
            "/minknow_api.manager.ManagerService/get_flow_cell_types": grpclib.const.Handler(
                self.__rpc_get_flow_cell_types,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetFlowCellTypesRequest,
                GetFlowCellTypesResponse,
            ),
            "/minknow_api.manager.ManagerService/get_sequencing_kits": grpclib.const.Handler(
                self.__rpc_get_sequencing_kits,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSequencingKitsRequest,
                GetSequencingKitsResponse,
            ),
            "/minknow_api.manager.ManagerService/add_simulated_device": grpclib.const.Handler(
                self.__rpc_add_simulated_device,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddSimulatedDeviceRequest,
                AddSimulatedDeviceResponse,
            ),
            "/minknow_api.manager.ManagerService/remove_simulated_device": grpclib.const.Handler(
                self.__rpc_remove_simulated_device,
                grpclib.const.Cardinality.UNARY_UNARY,
                RemoveSimulatedDeviceRequest,
                RemoveSimulatedDeviceResponse,
            ),
            "/minknow_api.manager.ManagerService/local_authentication_token_path": grpclib.const.Handler(
                self.__rpc_local_authentication_token_path,
                grpclib.const.Cardinality.UNARY_UNARY,
                LocalAuthenticationTokenPathRequest,
                LocalAuthenticationTokenPathResponse,
            ),
            "/minknow_api.manager.ManagerService/get_alignment_reference_information": grpclib.const.Handler(
                self.__rpc_get_alignment_reference_information,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetAlignmentReferenceInformationRequest,
                GetAlignmentReferenceInformationResponse,
            ),
            "/minknow_api.manager.ManagerService/association_device_code": grpclib.const.Handler(
                self.__rpc_association_device_code,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssociationDeviceCodeRequest,
                AssociationDeviceCodeResponse,
            ),
            "/minknow_api.manager.ManagerService/apply_offline_association_unlock_code": grpclib.const.Handler(
                self.__rpc_apply_offline_association_unlock_code,
                grpclib.const.Cardinality.UNARY_UNARY,
                ApplyOfflineAssociationUnlockCodeRequest,
                ApplyOfflineAssociationUnlockCodeResponse,
            ),
            "/minknow_api.manager.ManagerService/list_developer_api_tokens": grpclib.const.Handler(
                self.__rpc_list_developer_api_tokens,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListDeveloperApiTokensRequest,
                ListDeveloperApiTokensResponse,
            ),
            "/minknow_api.manager.ManagerService/create_developer_api_token": grpclib.const.Handler(
                self.__rpc_create_developer_api_token,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateDeveloperApiTokenRequest,
                CreateDeveloperApiTokenResponse,
            ),
            "/minknow_api.manager.ManagerService/revoke_developer_api_token": grpclib.const.Handler(
                self.__rpc_revoke_developer_api_token,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevokeDeveloperApiTokenRequest,
                RevokeDeveloperApiTokensResponse,
            ),
            "/minknow_api.manager.ManagerService/find_protocols": grpclib.const.Handler(
                self.__rpc_find_protocols,
                grpclib.const.Cardinality.UNARY_UNARY,
                FindProtocolsRequest,
                FindProtocolsResponse,
            ),
            "/minknow_api.manager.ManagerService/list_settings_for_protocol": grpclib.const.Handler(
                self.__rpc_list_settings_for_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListSettingsForProtocolRequest,
                ListSettingsForProtocolResponse,
            ),
            "/minknow_api.manager.ManagerService/get_features": grpclib.const.Handler(
                self.__rpc_get_features,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetFeaturesRequest,
                GetFeaturesResponse,
            ),
            "/minknow_api.manager.ManagerService/set_features": grpclib.const.Handler(
                self.__rpc_set_features,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetFeaturesRequest,
                SetFeaturesResponse,
            ),
            "/minknow_api.manager.ManagerService/restart_device_admin_service": grpclib.const.Handler(
                self.__rpc_restart_device_admin_service,
                grpclib.const.Cardinality.UNARY_UNARY,
                RestartDeviceAdminRequest,
                RestartDeviceAdminResponse,
            ),
            "/minknow_api.manager.ManagerService/check_bed_file": grpclib.const.Handler(
                self.__rpc_check_bed_file,
                grpclib.const.Cardinality.UNARY_UNARY,
                CheckBedFileRequest,
                CheckBedFileResponse,
            ),
        }
