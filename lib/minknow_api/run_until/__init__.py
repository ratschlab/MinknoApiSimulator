# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/run_until.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ActionUpdateAction(betterproto.Enum):
    NoAction = 0
    """No action"""

    Paused = 1
    """
    Run-Until has caused the protocol to be paused
    
     `write_updates()` will return an error if this action is submitted, unless the
     ProtocolRunInfo has the `can_pause` field set to `true``.
    
     Writing this action will have no effect if the protocol is already paused or pausing.
    """

    Resumed = 2
    """
    Run-Until has caused the protocol to be resumed
    
     `write_updates()` will return an error if this action is submitted, unless the
     ProtocolRunInfo has the `can_pause` field set to `true``.
    
     Writing this action will have no effect if the protocol is not paused or pausing.
    """

    Stopped = 3
    """Run-Until has caused the protocol to be stopped"""


@dataclass(eq=False, repr=False)
class CriteriaValues(betterproto.Message):
    """
    A map of criterion name -> value

     This message is deliberately flexible, to allow custom Run-Until Scripts to expand the range
     and types of available criteria.
    """

    criteria: Dict[str, "betterproto_lib_google_protobuf.Any"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class WriteTargetCriteriaRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition to set the Run-Until Criteria for"""

    pause_criteria: "CriteriaValues" = betterproto.message_field(2)
    stop_criteria: "CriteriaValues" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class WriteTargetCriteriaResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class StreamTargetCriteriaRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition to obtain the Run-Until Criteria for"""


@dataclass(eq=False, repr=False)
class StreamTargetCriteriaResponse(betterproto.Message):
    pause_criteria: "CriteriaValues" = betterproto.message_field(1)
    stop_criteria: "CriteriaValues" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EstimatedTimeRemainingUpdate(betterproto.Message):
    """
    Indicates the estimated time remaining

     An estimated time may be provided for each Run-Until Criterion that is specified as
     an end-point.
    """

    pause_estimates: "EstimatedTimeRemainingUpdateEstimatedTimes" = (
        betterproto.message_field(1)
    )
    stop_estimates: "EstimatedTimeRemainingUpdateEstimatedTimes" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class EstimatedTimeRemainingUpdateNotEstimated(betterproto.Message):
    """Indicates that a time is not estimated"""

    pass


@dataclass(eq=False, repr=False)
class EstimatedTimeRemainingUpdateEstimated(betterproto.Message):
    min_time: datetime = betterproto.message_field(1)
    """
    Estimated lower bound on the time at which the condition will occur (UTC)
    """

    max_time: datetime = betterproto.message_field(2)
    """
    Estimated upper bound on the time at which the condition will occur (UTC)
    """


@dataclass(eq=False, repr=False)
class EstimatedTimeRemainingUpdateEstimatedTime(betterproto.Message):
    not_estimated: "EstimatedTimeRemainingUpdateNotEstimated" = (
        betterproto.message_field(1, group="value")
    )
    estimated: "EstimatedTimeRemainingUpdateEstimated" = betterproto.message_field(
        2, group="value"
    )


@dataclass(eq=False, repr=False)
class EstimatedTimeRemainingUpdateEstimatedTimes(betterproto.Message):
    """
    Map of Run-Until Criterion to `EstimatedTime` when the criterion will be fulfilled

     Only criteria for which an update is being provided are contained in the map.
    """

    estimated_times: Dict[str, "EstimatedTimeRemainingUpdateEstimatedTime"] = (
        betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )


@dataclass(eq=False, repr=False)
class ActionUpdate(betterproto.Message):
    """
    Indicates that an action has been performed

     When a request is sent using `write_updates()`, MinKNOW performs the specified action.
    """

    action: "ActionUpdateAction" = betterproto.enum_field(1)
    criteria: str = betterproto.string_field(2)
    """The criteria associated with this action"""


@dataclass(eq=False, repr=False)
class ScriptUpdate(betterproto.Message):
    started: "ScriptUpdateStarted" = betterproto.message_field(1)
    criteria_updated: "ScriptUpdateCriteriaUpdated" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ScriptUpdateStarted(betterproto.Message):
    """Indicates that the run-until script has started and is running"""

    pass


@dataclass(eq=False, repr=False)
class ScriptUpdateCriteriaUpdated(betterproto.Message):
    """
    Indicates the the Run-Until Script has update its criteria in response to receiving a
     `StreamTargetCriteriaResponse` message
    """

    pass


@dataclass(eq=False, repr=False)
class ErrorUpdate(betterproto.Message):
    """
    Indicates that a problem has been encountered by the Run-Until Script
    """

    invalid_criteria: "ErrorUpdateInvalidCriteria" = betterproto.message_field(
        1, group="error"
    )
    other_error: "ErrorUpdateOtherError" = betterproto.message_field(15, group="error")


@dataclass(eq=False, repr=False)
class ErrorUpdateInvalidCriteria(betterproto.Message):
    """
    Indicates that one or more of the supplied target criteria is not recognised by the
      Run-Until Script.  Unrecognised target criteria will not be used to pause or stop the run.
    """

    name: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ErrorUpdateOtherError(betterproto.Message):
    """An error that is not covered by one of the other error types, above."""

    message: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Update(betterproto.Message):
    estimated_time_remaining_update: "EstimatedTimeRemainingUpdate" = (
        betterproto.message_field(1)
    )
    action_update: "ActionUpdate" = betterproto.message_field(2)
    script_update: "ScriptUpdate" = betterproto.message_field(3)
    current_progress_update: "CriteriaValues" = betterproto.message_field(5)
    """
    Gives the current values of the criteria
     (Compare to stream_target_criteria call to see %)
    """

    error_update: "ErrorUpdate" = betterproto.message_field(14)
    other: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(15)
    """Space for custom updates from custom Run-Until scripts"""


@dataclass(eq=False, repr=False)
class WriteUpdatesRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition this Run-Until update applies to"""

    update: "Update" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class WriteUpdatesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class StreamUpdatesRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition to stream Run-Until updates for"""

    start_idx: int = betterproto.int64_field(2)
    """
    The index of the first update to send.
    
     If an index is set that is greater than the current greatest update index, no past updates
     will be sent, but any future updates will be sent.  This may mean that you receive updates
     with an `idx` smaller than `start_idx`.
    
     In order to receive only updates that are sent after the call to `stream_updates()`, and no
     historic updates, set `start_idx` to `int64_max`.
    
     Setting `start_idx` to a negative number will be treated as an offset from the end of the
     updates history. A `start_idx` of `-1` will cause the last update to be sent, and any future
     updates to be streamed.  The negative value is clamped such that a "large" negative number
     will be equivalent to setting a `start_idx` of `0`.
    
     By default, `start_idx` is `0`, which means that all updates from the first update onwards
     will be sent.
    """


@dataclass(eq=False, repr=False)
class StreamUpdatesResponse(betterproto.Message):
    idx: int = betterproto.uint64_field(1)
    """
    The index of this update
    
     The index is incremented after each "interesting" update (i.e. an update that contains
     information besides an `estimated_time_remaining_update` or a `current_progress_update`).
     See `Update History`, above, for further information.
    """

    time: datetime = betterproto.message_field(2)
    """The timestamp of this update (UTC)"""

    update: "Update" = betterproto.message_field(3)
    """The update data itself"""


class RunUntilServiceStub(betterproto.ServiceStub):
    async def write_target_criteria(
        self,
        write_target_criteria_request: "WriteTargetCriteriaRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "WriteTargetCriteriaResponse":
        return await self._unary_unary(
            "/minknow_api.run_until.RunUntilService/write_target_criteria",
            write_target_criteria_request,
            WriteTargetCriteriaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_target_criteria(
        self,
        stream_target_criteria_request: "StreamTargetCriteriaRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamTargetCriteriaResponse]:
        async for response in self._unary_stream(
            "/minknow_api.run_until.RunUntilService/stream_target_criteria",
            stream_target_criteria_request,
            StreamTargetCriteriaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def write_updates(
        self,
        write_updates_request: "WriteUpdatesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "WriteUpdatesResponse":
        return await self._unary_unary(
            "/minknow_api.run_until.RunUntilService/write_updates",
            write_updates_request,
            WriteUpdatesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_updates(
        self,
        stream_updates_request: "StreamUpdatesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamUpdatesResponse]:
        async for response in self._unary_stream(
            "/minknow_api.run_until.RunUntilService/stream_updates",
            stream_updates_request,
            StreamUpdatesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class RunUntilServiceBase(ServiceBase):

    async def write_target_criteria(
        self, write_target_criteria_request: "WriteTargetCriteriaRequest"
    ) -> "WriteTargetCriteriaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_target_criteria(
        self, stream_target_criteria_request: "StreamTargetCriteriaRequest"
    ) -> AsyncIterator[StreamTargetCriteriaResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamTargetCriteriaResponse()

    async def write_updates(
        self, write_updates_request: "WriteUpdatesRequest"
    ) -> "WriteUpdatesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_updates(
        self, stream_updates_request: "StreamUpdatesRequest"
    ) -> AsyncIterator[StreamUpdatesResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamUpdatesResponse()

    async def __rpc_write_target_criteria(
        self,
        stream: "grpclib.server.Stream[WriteTargetCriteriaRequest, WriteTargetCriteriaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.write_target_criteria(request)
        await stream.send_message(response)

    async def __rpc_stream_target_criteria(
        self,
        stream: "grpclib.server.Stream[StreamTargetCriteriaRequest, StreamTargetCriteriaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_target_criteria,
            stream,
            request,
        )

    async def __rpc_write_updates(
        self, stream: "grpclib.server.Stream[WriteUpdatesRequest, WriteUpdatesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.write_updates(request)
        await stream.send_message(response)

    async def __rpc_stream_updates(
        self,
        stream: "grpclib.server.Stream[StreamUpdatesRequest, StreamUpdatesResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_updates,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.run_until.RunUntilService/write_target_criteria": grpclib.const.Handler(
                self.__rpc_write_target_criteria,
                grpclib.const.Cardinality.UNARY_UNARY,
                WriteTargetCriteriaRequest,
                WriteTargetCriteriaResponse,
            ),
            "/minknow_api.run_until.RunUntilService/stream_target_criteria": grpclib.const.Handler(
                self.__rpc_stream_target_criteria,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamTargetCriteriaRequest,
                StreamTargetCriteriaResponse,
            ),
            "/minknow_api.run_until.RunUntilService/write_updates": grpclib.const.Handler(
                self.__rpc_write_updates,
                grpclib.const.Cardinality.UNARY_UNARY,
                WriteUpdatesRequest,
                WriteUpdatesResponse,
            ),
            "/minknow_api.run_until.RunUntilService/stream_updates": grpclib.const.Handler(
                self.__rpc_stream_updates,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamUpdatesRequest,
                StreamUpdatesResponse,
            ),
        }
