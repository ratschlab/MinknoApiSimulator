# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/basecaller.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    analysis_configuration as _analysis_configuration__,
    analysis_workflows as _analysis_workflows__,
    protocol_settings as _protocol_settings__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class State(betterproto.Enum):
    RUNNING = 0
    """Basecalling is running."""

    SUCCESS = 1
    """Basecalling has finished with no errors."""

    ERROR = 2
    """
    Basecalling has stopped due to errors.
    
     Note that not being able to basecall a read is not necessarily considered an error (eg: if it
     could not be basecalled because of poor data quality).
    """

    CANCELLED = 3
    """Basecalling was cancelled via a call to cancel()."""


class SelectionPreset(betterproto.Enum):
    PRESET_ALL_RUNNING = 0
    """Return all currently-running basecall runs."""

    PRESET_MOST_RECENTLY_STARTED = 1
    """Return only the most recently-started run."""

    PRESET_ALL = 2
    """Return all basecall runs."""


class PostProcessingProvider(betterproto.Enum):
    SCRIPT = 0
    """A local script."""

    EPI2ME = 1
    """An EPI2ME workflow."""


class StartBarcodingRequestOutputFormat(betterproto.Enum):
    BAM = 0
    FASTQ = 1


@dataclass(eq=False, repr=False)
class ListConfigsByKitRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListConfigsByKitResponse(betterproto.Message):
    flow_cell_configs: Dict[str, "ListConfigsByKitResponsePerFlowCell"] = (
        betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    """
    Key: flow cell type (eg: "FLO-MIN107")
     Value: FlowCellConfigs describing configurations available for that flow cell.
    """


@dataclass(eq=False, repr=False)
class ListConfigsByKitResponseConfigList(betterproto.Message):
    configs: List[str] = betterproto.string_field(1)
    """
    List of configuration names, to be used in ``StartBasecallingRequest.configuration``
    """


@dataclass(eq=False, repr=False)
class ListConfigsByKitResponsePerFlowCell(betterproto.Message):
    kit_configs: Dict[str, "ListConfigsByKitResponseConfigList"] = (
        betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    """
    Key: kit name (eg: "SQK-LSK109")
     Value: list of configuration names
    """


@dataclass(eq=False, repr=False)
class StartBasecallingRequest(betterproto.Message):
    name: str = betterproto.string_field(12)
    """User specified name to identify the basecall run."""

    input_reads_directories: List[str] = betterproto.string_field(1)
    """
    Input directories to search for reads to be basecalled.
    
     Currently, only one directory can be specified, but this definition allows for multiple in
     the future without breaking compatibility.
    """

    output_reads_directory: str = betterproto.string_field(2)
    """
    Output directory where called reads will be placed.
    
     Reads will be sorted into subdirectories based on the sequencing run they came from.
    """

    configuration: str = betterproto.string_field(3)
    """The name of the basecalling configuration to use."""

    fast5_out: bool = betterproto.bool_field(4)
    """
    Enable output of .fast5 files containing original raw reads, event data/trace table from
     basecall and basecall result sequence.
    
     This causes .fast5 files to be output in addition to FASTQ files.
    
     DEPRECATED: This option does not have any effect - the basecaller no longer has the ability to write fast5 files.
    """

    compress_fastq: bool = betterproto.bool_field(5)
    """Enable gzip compression of output FASTQ files."""

    disable_events: bool = betterproto.bool_field(6)
    """
    Prevent events / trace tables being written to .fast5 files.
    
     If event tables are not required for downstream processing (eg: for 1d^2) then it is more
     efficient (and produces smaller files) to disable them.
    
     This has no effect if ``fast5_out`` is not enabled.
    """

    recursive: bool = betterproto.bool_field(7)
    """
    Recursively find fast5 files to basecall in the `input_reads_directories`.
    
     If False, only the fast5 files directly in one of the `input_reads_directories` will be
     basecalled. If True, subdirectories of those directories will also be searched recursively.
    """

    barcoding_configuration: "_analysis_configuration__.BarcodingConfiguration" = (
        betterproto.message_field(10)
    )
    """
    Options to control barcoding performed once basecalling reads is complete.
    """

    alignment_configuration: "_analysis_configuration__.AlignmentConfiguration" = (
        betterproto.message_field(11)
    )
    """
    Options to control alignment performed once basecalling reads is complete.
    """

    min_qscore: Optional[float] = betterproto.double_field(15, optional=True)
    """
    Minimum Q-Score for a read to be passed by the basecaller.
    
     Since 6.1.
    """

    enable_read_splitting: bool = betterproto.bool_field(13)
    """
    Enable read splitting in the basecaller
    
     Note: Since 5.9 this option has no effect, the basecaller is responsible for deciding when read splitting should be enabled.
    """

    min_score_read_splitting: Optional[float] = betterproto.message_field(
        14, wraps=betterproto.TYPE_FLOAT
    )
    """
    Override score to use for the basecaller read splitting. If not specified a default value
     is used from the basecaller.
    
     Note: Since 5.9 this option has no effect, the basecaller is responsible for deciding when read splitting should be enabled.
    """


@dataclass(eq=False, repr=False)
class StartBasecallingResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    An identifier for the basecalling run that was started. This can be used to monitor or cancel
     the run.
    """


@dataclass(eq=False, repr=False)
class StartBarcodingRequest(betterproto.Message):
    name: str = betterproto.string_field(11)
    """User specified name to identify the barcoding run."""

    input_reads_directories: List[str] = betterproto.string_field(1)
    """
    Input directories to search for reads to be basecalled.
    
     Currently, only one directory can be specified, but this definition allows for multiple in
     the future without breaking compatibility.
    """

    output_reads_directory: str = betterproto.string_field(2)
    """
    Output directory where called reads will be placed.
    
     Reads will be sorted into subdirectories based on the sequencing run they came from.
    """

    compress_fastq: bool = betterproto.bool_field(4)
    """
    Enable gzip compression of output FASTQ files.
    
     DEPRECATED: This option does not have any effect - the offline barcoding no longer has the ability to compress fastq output.
    """

    recursive: bool = betterproto.bool_field(5)
    """
    Recursively find fast5 files to basecall in the `input_reads_directories`.
    
     If False, only the fast5 files directly in one of the `input_reads_directories` will be
     basecalled. If True, subdirectories of those directories will also be searched recursively.
    """

    barcoding_configuration: "_analysis_configuration__.BarcodingConfiguration" = (
        betterproto.message_field(10)
    )
    """
    Options to control barcoding performed once basecalling reads is complete.
    """

    output_format: "StartBarcodingRequestOutputFormat" = betterproto.enum_field(12)
    """The type of file format to use for the output, default is BAM."""


@dataclass(eq=False, repr=False)
class StartBarcodingResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    An identifier for the basecalling run that was started. This can be used to monitor or cancel
     the run.
    """


@dataclass(eq=False, repr=False)
class StartAlignmentRequest(betterproto.Message):
    name: str = betterproto.string_field(7)
    """User specified name to identify the alignment run."""

    input_reads_directories: List[str] = betterproto.string_field(1)
    """
    Input directories to search for reads to be aligned.
    
     Currently, only one directory can be specified, but this definition allows for multiple in
     the future without breaking compatibility.
    """

    output_reads_directory: str = betterproto.string_field(2)
    """Output directory where aligned reads will be placed."""

    recursive: bool = betterproto.bool_field(4)
    """
    Recursively find fast5 files to align in the `input_reads_directories`.
    
     If False, only the fast5 files directly in one of the `input_reads_directories` will be
     aligned. If True, subdirectories of those directories will also be searched recursively.
    """

    alignment_configuration: "_analysis_configuration__.AlignmentConfiguration" = (
        betterproto.message_field(6)
    )
    """
    Options to control alignment performed once basecalling reads is complete.
    """


@dataclass(eq=False, repr=False)
class StartAlignmentResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    An identifier for the alignment run that was started. This can be used to monitor or cancel
     the run.
    """


@dataclass(eq=False, repr=False)
class StartPostProcessingProtocolRequest(betterproto.Message):
    identifier: str = betterproto.string_field(1)
    """
    identifier value from a protocol returned from list_post_processing_protocols.
    """

    sequencing_protocol_run_id: str = betterproto.string_field(7)
    """
    Optionally specify a sequencing protocol that is linked with this analysis.
    """

    input_fast5_directory: str = betterproto.string_field(2)
    """
    Input directories for the protocol (omit those which the protocol doesn't require).
    """

    input_fastq_directory: str = betterproto.string_field(3)
    input_bam_directory: str = betterproto.string_field(4)
    sample_sheet_path: str = betterproto.string_field(8)
    """Path to the sample sheet output by minknow"""

    output_directory: str = betterproto.string_field(5)
    """Output directory where the analysed output should be written."""

    setting_values: Dict[
        str, "_protocol_settings__.ProtocolSettingProtocolSettingValue"
    ] = betterproto.map_field(6, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    """
    Configured values for display settings for the protocol (see basecaller.list_settings_for_protocol)
     keys missing from the original protocol will cause errors.
    """


@dataclass(eq=False, repr=False)
class StartRequest(betterproto.Message):
    start_basecalling_request: "StartBasecallingRequest" = betterproto.message_field(
        2, group="start_request"
    )
    start_barcoding_request: "StartBarcodingRequest" = betterproto.message_field(
        3, group="start_request"
    )
    start_alignment_request: "StartAlignmentRequest" = betterproto.message_field(
        4, group="start_request"
    )
    start_post_processing_protocol_request: "StartPostProcessingProtocolRequest" = (
        betterproto.message_field(5, group="start_request")
    )
    proxy_request: "_analysis_workflows__.ProxyRequest" = betterproto.message_field(
        6, group="start_request"
    )
    """Since 5.8"""


@dataclass(eq=False, repr=False)
class StartPostProcessingProtocolResponse(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    An identifier for the protocol run that was started. This can be used to monitor or cancel
     the run.
    """


@dataclass(eq=False, repr=False)
class CancelRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    """An identifier as returned from a call to start() or list()."""


@dataclass(eq=False, repr=False)
class CancelResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RunInfo(betterproto.Message):
    id: str = betterproto.string_field(1)
    """The ID of the run, as returned by start()."""

    start_basecalling_request: "StartBasecallingRequest" = betterproto.message_field(
        2, group="start_request_oneof"
    )
    """Set if basecalling reads"""

    start_barcoding_request: "StartBarcodingRequest" = betterproto.message_field(
        11, group="start_request_oneof"
    )
    """Set if barcoding reads"""

    start_alignment_request: "StartAlignmentRequest" = betterproto.message_field(
        12, group="start_request_oneof"
    )
    """Set if aligning reads"""

    start_post_processing_protocol_request: "StartPostProcessingProtocolRequest" = (
        betterproto.message_field(13, group="start_request_oneof")
    )
    """Set if aligning reads"""

    state: "State" = betterproto.enum_field(3)
    """
    What state the run is in.
    
     While the basecalling is running the state field will be ``STATE_RUNNING``.
    """

    errors: List[str] = betterproto.string_field(4)
    """
    If state is STATE_ERROR, this will contain (some of) the errors encountered.
    
     Note that if there are a lot of errors, only some may be returned.
    """

    files_discovered: int = betterproto.int32_field(5)
    """The number of files selected for input."""

    progress_current: int = betterproto.int32_field(6)
    """
    The current basecalling progress (with respect to progress_total).
    
     This is intended to be an estimate of how close to completion the basecalling run is. The
     numbers have no particular meaning other than as a proportion of progress_total.
    
     Note that this only really has useful meaning while state is STATE_RUNNING. On STATE_SUCCESS,
     it will always be the same as progress_total. On STATE_ERROR or STATE_CANCELLED, it may give
     some indication of how far through basecalling was when it failed or was cancelled.
    """

    progress_total: int = betterproto.int32_field(7)
    """
    The maximum value of progress_current.
    
     (progress_current / progress_total) * 100 will give a percentage completion.
    
     If this is 0, it should be interpreted as "unknown progress".
    """

    start_time: datetime = betterproto.message_field(8)
    """When basecalling was started (UTC)."""

    end_time: datetime = betterproto.message_field(9)
    """
    When basecalling ended (UTC).
    
     Unset if basecalling is still running.
    """

    estimated_end_time: datetime = betterproto.message_field(10)
    """
    An estimate for when basecalling will end (UTC).
    
     Unset if basecalling has finished, or if an estimate cannot be calculated
     (eg: because the baescalling software does not support it).
    
     Since 3.6.
    """


@dataclass(eq=False, repr=False)
class GetInfoRequest(betterproto.Message):
    preset: "SelectionPreset" = betterproto.enum_field(1, group="selection")
    """A pre-determined selection of runs."""

    id: str = betterproto.string_field(2, group="selection")
    """An identifier, as returned by start()."""

    list: "GetInfoRequestIdList" = betterproto.message_field(3, group="selection")
    """A list of identifiers, as returned by start()."""


@dataclass(eq=False, repr=False)
class GetInfoRequestIdList(betterproto.Message):
    ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetInfoResponse(betterproto.Message):
    runs: List["RunInfo"] = betterproto.message_field(1)
    """Information about the requested runs."""


@dataclass(eq=False, repr=False)
class ClearInfoRequest(betterproto.Message):
    ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ClearInfoResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class WatchRequest(betterproto.Message):
    send_finished_runs: bool = betterproto.bool_field(1)
    """
    By default, no information will be sent about runs that were already finished when this call
     was made. Setting this to true will cause the state of already-finished runs to be returned.
    """


@dataclass(eq=False, repr=False)
class WatchResponse(betterproto.Message):
    runs: List["RunInfo"] = betterproto.message_field(1)
    """The current state of some of the runs."""


@dataclass(eq=False, repr=False)
class MakeAlignmentIndexRequest(betterproto.Message):
    input_alignment_reference: str = betterproto.string_field(1)
    """Input fasta reference to use for building the index."""

    output_alignment_index: str = betterproto.string_field(2)
    """
    Output file path to write index (mmi file) to.
    
     Must have a ".mmi" extension, and the paths parent directory must exist.
    """


@dataclass(eq=False, repr=False)
class MakeAlignmentIndexResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListPostProcessingProtocolsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class PostProcessingProtocolInfo(betterproto.Message):
    identifier: str = betterproto.string_field(1)
    """System identifier for the protocol"""

    name: str = betterproto.string_field(2)
    """
    Readable name for the protocol (appropriate for use as a key in translation database).
    
     Note that this may not be unique: in particular, the EPI2ME provider lists every version of
     a workflow as a separate post-processing protocol.
    """

    version: str = betterproto.string_field(3)
    """
    Protocol version.
    
     This might not be set for all protocols or all providers.
    """

    description: str = betterproto.string_field(4)
    """A description of the protocol."""

    provider: "PostProcessingProvider" = betterproto.enum_field(5)
    """The source of the post-processing protocol."""


@dataclass(eq=False, repr=False)
class ListPostProcessingProtocolsResponse(betterproto.Message):
    protocols: List["PostProcessingProtocolInfo"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListSettingsForPostProcessingProtocolRequest(betterproto.Message):
    identifier: str = betterproto.string_field(1)
    """
    specify the protocol with a string containing all the protocol's identifying components, eg:
     "SYSTEM:post_processing/artic"
    """


@dataclass(eq=False, repr=False)
class ListSettingsForPostProcessingProtocolResponse(betterproto.Message):
    requires_fast5_input: bool = betterproto.bool_field(1)
    """Does the protocol require fast5 files as input"""

    requires_fastq_input: bool = betterproto.bool_field(2)
    """Does the protocol require fastq files as input"""

    requires_bam_input: bool = betterproto.bool_field(3)
    """Does the protocol require bam files as input"""

    protocol_settings: List["_protocol_settings__.ProtocolSetting"] = (
        betterproto.message_field(4)
    )
    """List of protocol settings used by the post processing protocol"""


@dataclass(eq=False, repr=False)
class UpdateProgressRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    id of the protocol to update (stored in environment variable for python process)
    """

    progress: float = betterproto.float_field(2)
    """Progress indicator, 0-1."""


@dataclass(eq=False, repr=False)
class UpdateProgressResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SendPingRequest(betterproto.Message):
    """Since 5.0"""

    ping_data: str = betterproto.string_field(1)
    """
    The json data to send as a ping.
    
     note: if this string is not a valid json object, an error will be raised.
    """


@dataclass(eq=False, repr=False)
class SendPingResponse(betterproto.Message):
    """Since 5.0"""

    pass


class BasecallerStub(betterproto.ServiceStub):
    async def list_configs_by_kit(
        self,
        list_configs_by_kit_request: "ListConfigsByKitRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListConfigsByKitResponse":
        warnings.warn(
            "Basecaller.list_configs_by_kit is deprecated", DeprecationWarning
        )

        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/list_configs_by_kit",
            list_configs_by_kit_request,
            ListConfigsByKitResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_basecalling(
        self,
        start_basecalling_request: "StartBasecallingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StartBasecallingResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/start_basecalling",
            start_basecalling_request,
            StartBasecallingResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_barcoding(
        self,
        start_barcoding_request: "StartBarcodingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StartBarcodingResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/start_barcoding",
            start_barcoding_request,
            StartBarcodingResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_post_processing_protocol(
        self,
        start_post_processing_protocol_request: "StartPostProcessingProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StartPostProcessingProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/start_post_processing_protocol",
            start_post_processing_protocol_request,
            StartPostProcessingProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_alignment(
        self,
        start_alignment_request: "StartAlignmentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StartAlignmentResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/start_alignment",
            start_alignment_request,
            StartAlignmentResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel(
        self,
        cancel_request: "CancelRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CancelResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/cancel",
            cancel_request,
            CancelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_info(
        self,
        get_info_request: "GetInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetInfoResponse]:
        async for response in self._unary_stream(
            "/minknow_api.basecaller.Basecaller/get_info",
            get_info_request,
            GetInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def clear_info(
        self,
        clear_info_request: "ClearInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ClearInfoResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/clear_info",
            clear_info_request,
            ClearInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def watch(
        self,
        watch_request: "WatchRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[WatchResponse]:
        async for response in self._unary_stream(
            "/minknow_api.basecaller.Basecaller/watch",
            watch_request,
            WatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def make_alignment_index(
        self,
        make_alignment_index_request: "MakeAlignmentIndexRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MakeAlignmentIndexResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/make_alignment_index",
            make_alignment_index_request,
            MakeAlignmentIndexResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_post_processing_protocols(
        self,
        list_post_processing_protocols_request: "ListPostProcessingProtocolsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListPostProcessingProtocolsResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/list_post_processing_protocols",
            list_post_processing_protocols_request,
            ListPostProcessingProtocolsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_settings_for_post_processing_protocol(
        self,
        list_settings_for_post_processing_protocol_request: "ListSettingsForPostProcessingProtocolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListSettingsForPostProcessingProtocolResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/list_settings_for_post_processing_protocol",
            list_settings_for_post_processing_protocol_request,
            ListSettingsForPostProcessingProtocolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_post_processing_protocol_progress(
        self,
        update_progress_request: "UpdateProgressRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateProgressResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/update_post_processing_protocol_progress",
            update_progress_request,
            UpdateProgressResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_ping(
        self,
        send_ping_request: "SendPingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SendPingResponse":
        return await self._unary_unary(
            "/minknow_api.basecaller.Basecaller/send_ping",
            send_ping_request,
            SendPingResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class BasecallerBase(ServiceBase):

    async def list_configs_by_kit(
        self, list_configs_by_kit_request: "ListConfigsByKitRequest"
    ) -> "ListConfigsByKitResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_basecalling(
        self, start_basecalling_request: "StartBasecallingRequest"
    ) -> "StartBasecallingResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_barcoding(
        self, start_barcoding_request: "StartBarcodingRequest"
    ) -> "StartBarcodingResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_post_processing_protocol(
        self,
        start_post_processing_protocol_request: "StartPostProcessingProtocolRequest",
    ) -> "StartPostProcessingProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_alignment(
        self, start_alignment_request: "StartAlignmentRequest"
    ) -> "StartAlignmentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel(self, cancel_request: "CancelRequest") -> "CancelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_info(
        self, get_info_request: "GetInfoRequest"
    ) -> AsyncIterator[GetInfoResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetInfoResponse()

    async def clear_info(
        self, clear_info_request: "ClearInfoRequest"
    ) -> "ClearInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def watch(
        self, watch_request: "WatchRequest"
    ) -> AsyncIterator[WatchResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield WatchResponse()

    async def make_alignment_index(
        self, make_alignment_index_request: "MakeAlignmentIndexRequest"
    ) -> "MakeAlignmentIndexResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_post_processing_protocols(
        self,
        list_post_processing_protocols_request: "ListPostProcessingProtocolsRequest",
    ) -> "ListPostProcessingProtocolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_settings_for_post_processing_protocol(
        self,
        list_settings_for_post_processing_protocol_request: "ListSettingsForPostProcessingProtocolRequest",
    ) -> "ListSettingsForPostProcessingProtocolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_post_processing_protocol_progress(
        self, update_progress_request: "UpdateProgressRequest"
    ) -> "UpdateProgressResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_ping(
        self, send_ping_request: "SendPingRequest"
    ) -> "SendPingResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_list_configs_by_kit(
        self,
        stream: "grpclib.server.Stream[ListConfigsByKitRequest, ListConfigsByKitResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_configs_by_kit(request)
        await stream.send_message(response)

    async def __rpc_start_basecalling(
        self,
        stream: "grpclib.server.Stream[StartBasecallingRequest, StartBasecallingResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_basecalling(request)
        await stream.send_message(response)

    async def __rpc_start_barcoding(
        self,
        stream: "grpclib.server.Stream[StartBarcodingRequest, StartBarcodingResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_barcoding(request)
        await stream.send_message(response)

    async def __rpc_start_post_processing_protocol(
        self,
        stream: "grpclib.server.Stream[StartPostProcessingProtocolRequest, StartPostProcessingProtocolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_post_processing_protocol(request)
        await stream.send_message(response)

    async def __rpc_start_alignment(
        self,
        stream: "grpclib.server.Stream[StartAlignmentRequest, StartAlignmentResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_alignment(request)
        await stream.send_message(response)

    async def __rpc_cancel(
        self, stream: "grpclib.server.Stream[CancelRequest, CancelResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel(request)
        await stream.send_message(response)

    async def __rpc_get_info(
        self, stream: "grpclib.server.Stream[GetInfoRequest, GetInfoResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_info,
            stream,
            request,
        )

    async def __rpc_clear_info(
        self, stream: "grpclib.server.Stream[ClearInfoRequest, ClearInfoResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.clear_info(request)
        await stream.send_message(response)

    async def __rpc_watch(
        self, stream: "grpclib.server.Stream[WatchRequest, WatchResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.watch,
            stream,
            request,
        )

    async def __rpc_make_alignment_index(
        self,
        stream: "grpclib.server.Stream[MakeAlignmentIndexRequest, MakeAlignmentIndexResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.make_alignment_index(request)
        await stream.send_message(response)

    async def __rpc_list_post_processing_protocols(
        self,
        stream: "grpclib.server.Stream[ListPostProcessingProtocolsRequest, ListPostProcessingProtocolsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_post_processing_protocols(request)
        await stream.send_message(response)

    async def __rpc_list_settings_for_post_processing_protocol(
        self,
        stream: "grpclib.server.Stream[ListSettingsForPostProcessingProtocolRequest, ListSettingsForPostProcessingProtocolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_settings_for_post_processing_protocol(request)
        await stream.send_message(response)

    async def __rpc_update_post_processing_protocol_progress(
        self,
        stream: "grpclib.server.Stream[UpdateProgressRequest, UpdateProgressResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_post_processing_protocol_progress(request)
        await stream.send_message(response)

    async def __rpc_send_ping(
        self, stream: "grpclib.server.Stream[SendPingRequest, SendPingResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_ping(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.basecaller.Basecaller/list_configs_by_kit": grpclib.const.Handler(
                self.__rpc_list_configs_by_kit,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListConfigsByKitRequest,
                ListConfigsByKitResponse,
            ),
            "/minknow_api.basecaller.Basecaller/start_basecalling": grpclib.const.Handler(
                self.__rpc_start_basecalling,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartBasecallingRequest,
                StartBasecallingResponse,
            ),
            "/minknow_api.basecaller.Basecaller/start_barcoding": grpclib.const.Handler(
                self.__rpc_start_barcoding,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartBarcodingRequest,
                StartBarcodingResponse,
            ),
            "/minknow_api.basecaller.Basecaller/start_post_processing_protocol": grpclib.const.Handler(
                self.__rpc_start_post_processing_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartPostProcessingProtocolRequest,
                StartPostProcessingProtocolResponse,
            ),
            "/minknow_api.basecaller.Basecaller/start_alignment": grpclib.const.Handler(
                self.__rpc_start_alignment,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartAlignmentRequest,
                StartAlignmentResponse,
            ),
            "/minknow_api.basecaller.Basecaller/cancel": grpclib.const.Handler(
                self.__rpc_cancel,
                grpclib.const.Cardinality.UNARY_UNARY,
                CancelRequest,
                CancelResponse,
            ),
            "/minknow_api.basecaller.Basecaller/get_info": grpclib.const.Handler(
                self.__rpc_get_info,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetInfoRequest,
                GetInfoResponse,
            ),
            "/minknow_api.basecaller.Basecaller/clear_info": grpclib.const.Handler(
                self.__rpc_clear_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                ClearInfoRequest,
                ClearInfoResponse,
            ),
            "/minknow_api.basecaller.Basecaller/watch": grpclib.const.Handler(
                self.__rpc_watch,
                grpclib.const.Cardinality.UNARY_STREAM,
                WatchRequest,
                WatchResponse,
            ),
            "/minknow_api.basecaller.Basecaller/make_alignment_index": grpclib.const.Handler(
                self.__rpc_make_alignment_index,
                grpclib.const.Cardinality.UNARY_UNARY,
                MakeAlignmentIndexRequest,
                MakeAlignmentIndexResponse,
            ),
            "/minknow_api.basecaller.Basecaller/list_post_processing_protocols": grpclib.const.Handler(
                self.__rpc_list_post_processing_protocols,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListPostProcessingProtocolsRequest,
                ListPostProcessingProtocolsResponse,
            ),
            "/minknow_api.basecaller.Basecaller/list_settings_for_post_processing_protocol": grpclib.const.Handler(
                self.__rpc_list_settings_for_post_processing_protocol,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListSettingsForPostProcessingProtocolRequest,
                ListSettingsForPostProcessingProtocolResponse,
            ),
            "/minknow_api.basecaller.Basecaller/update_post_processing_protocol_progress": grpclib.const.Handler(
                self.__rpc_update_post_processing_protocol_progress,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateProgressRequest,
                UpdateProgressResponse,
            ),
            "/minknow_api.basecaller.Basecaller/send_ping": grpclib.const.Handler(
                self.__rpc_send_ping,
                grpclib.const.Cardinality.UNARY_UNARY,
                SendPingRequest,
                SendPingResponse,
            ),
        }
