# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/instance.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    acquisition as _acquisition__,
    device as _device__,
    protocol as _protocol__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class GetVersionInfoResponseDistributionStatus(betterproto.Enum):
    UNKNOWN = 0
    STABLE = 1
    UNSTABLE = 2
    """it was distributed."""

    MODIFIED = 3
    """
    been fully tested, but has not been modified from how it
     was distributed.
    """


class GetVersionInfoResponseInstallationType(betterproto.Enum):
    ONT = 0
    """For internal release. production.proto will be enabled for this type"""

    NC = 1
    """For customer releases"""

    PROD = 2
    """
    For production release. production.proto will be enabled for this type
    """

    Q_RELEASE = 3
    """For Q releases (nanopore long term support release)"""

    OND_RELEASE = 4
    """Oxford Nanopore Diagnostic"""


@dataclass(eq=False, repr=False)
class GetVersionInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetVersionInfoResponse(betterproto.Message):
    minknow: "GetVersionInfoResponseMinknowVersion" = betterproto.message_field(1)
    """
    What minknow version is installed. Split into major, minor and patch versions
     Also includes the full version as a string, which contain the major, minor and patch numbers
     as well as if the version is pre-release version (~pre), whether it is a release candidate (~rc#)
     or whether it is a variant version (i.e. for conferences) (-variant). For non-release builds it also
     includes the hash of the commit it is based on, and whether the working copy is different from that has (-dirty)
    """

    bream: str = betterproto.string_field(2)
    """
    The version of Bream that is installed.
    
     An invalid installation will cause this to return "0.0.0".
    
     Prior to 5.0, this field was called "protocols".
    
     Since 5.0
    """

    distribution_version: str = betterproto.string_field(3)
    """
    Describes the distribution that this MinKNOW installation is part of, usually
     this will be the Metapackage version number/identity, this will be "unknown"
     if the distribution-version hasn't been set. This information is also communicated
     in the Manager's DaemonMessage in daemon.proto
    """

    distribution_status: "GetVersionInfoResponseDistributionStatus" = (
        betterproto.enum_field(4)
    )
    """
    Indicates if the MinKNOW distribution including components such as Bream
     are stable, unstable or have been modified.
    """

    protocol_configuration: str = betterproto.string_field(5)
    """
    The version of the protocol configuration files that is installed.
    
     An invalid installation will cause this to return "0.0.0".
    
     Prior to 5.0, this field was called "configuration".
    
     Since 5.0
    """

    installation_type: "GetVersionInfoResponseInstallationType" = (
        betterproto.enum_field(6)
    )
    """
    The installation type of MinKNOW.
    
     The installation type may affect the available features, or the update process.
    
     Since 4.1
    """

    basecaller_build_version: str = betterproto.string_field(9)
    basecaller_connected_version: str = betterproto.string_field(10)


@dataclass(eq=False, repr=False)
class GetVersionInfoResponseMinknowVersion(betterproto.Message):
    major: int = betterproto.int32_field(1)
    minor: int = betterproto.int32_field(2)
    patch: int = betterproto.int32_field(3)
    full: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class GetOutputDirectoriesRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class OutputDirectories(betterproto.Message):
    output: str = betterproto.string_field(1)
    """
    The base output directory. Anything that is output to files is branched from this directory.
    """

    log: str = betterproto.string_field(2)
    """Directory where logs will be stored."""

    reads: str = betterproto.string_field(3)
    """Base directory where reads will be outputted."""


@dataclass(eq=False, repr=False)
class GetDefaultOutputDirectoriesRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetOutputDirectoryRequest(betterproto.Message):
    path: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class SetOutputDirectoryResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetReadsDirectoryRequest(betterproto.Message):
    path: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class SetReadsDirectoryResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class FilesystemDiskSpaceInfo(betterproto.Message):
    """disk-usage information for one file-system"""

    filesystem_id: str = betterproto.string_field(1)
    """The name of the file-system"""

    bytes_available: int = betterproto.uint64_field(2)
    """How much space is left on the file-system"""

    bytes_capacity: int = betterproto.uint64_field(3)
    """The total capacity of the file-system when empty."""

    what: List[str] = betterproto.string_field(4)
    """
    A list of what MinKNOW stores on this file-system, eg: reads, logs,
     intermediate-files
    """

    bytes_to_stop_cleanly: int = betterproto.uint64_field(5)
    """
    MinKNOW needs this much space to stop an experiment. If bytes_available
     goes below this number, data could be lost!
    """

    bytes_when_alert_issued: int = betterproto.uint64_field(6)
    """
    The amount of space left on the file-system when recommend_alert
     was set true.
    """

    recommend_alert: bool = betterproto.bool_field(7)
    """MinKNOW recommends that you alert someone about the disk-usage"""

    recommend_stop: bool = betterproto.bool_field(8)
    """
    MinKNOW recommends that you stop the experiment due to disk-usage
     concerns
    """

    bytes_per_second: int = betterproto.int64_field(9)
    """
    Rate of change in bytes_available (per second) +'ve numbers indicate
     that bytes_available is decreasing and space is being used
     A value of 0 can indicate that this has not applicable or not available.
    """


@dataclass(eq=False, repr=False)
class GetDiskSpaceInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class StreamDiskSpaceInfoRequest(betterproto.Message):
    period: int = betterproto.uint32_field(1)
    """
    Disk space information will be streamed with this value determining the
     period in seconds between updates.
     A period of 0 is invalid
    """


@dataclass(eq=False, repr=False)
class GetDiskSpaceInfoResponse(betterproto.Message):
    filesystem_disk_space_info: List["FilesystemDiskSpaceInfo"] = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class GetMachineIdRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetMachineIdResponse(betterproto.Message):
    machine_id: str = betterproto.string_field(1)
    """The machine_id MinKNOW uses for this host."""


@dataclass(eq=False, repr=False)
class StreamInstanceActivityRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeviceInfo(betterproto.Message):
    device_state: "_device__.GetDeviceStateResponseDeviceState" = (
        betterproto.enum_field(1)
    )
    """The current state of the device"""

    device_info: "_device__.GetDeviceInfoResponse" = betterproto.message_field(2)
    """
    Information about the connected device (or no content if disconnected see: device_state)
    """


@dataclass(eq=False, repr=False)
class BasecallSpeed(betterproto.Message):
    mean_basecall_speed: float = betterproto.float_field(1)
    """
    Mean basecall speed, in bases per second.
    
     This value is only streamed for acquisitions where basecalling is enabled.
    
     The value reported here is the value stored in last completed basecall boxplot bucket
     Each boxplot bucket covers a duration of `boxplot_time_coverage_in_minutes`
    """


@dataclass(eq=False, repr=False)
class N50(betterproto.Message):
    n50: float = betterproto.float_field(1)
    """
    N50 data, in basecalled bases
    
     This value is only streamed for acquisitions where basecalling is enabled.
    
     The latest value is sent once per minute
    """

    estimated_n50: float = betterproto.float_field(2)
    """
    N50 data, in estimated bases
    
     The latest value is sent once per minute
    """


@dataclass(eq=False, repr=False)
class StreamInstanceActivityResponse(betterproto.Message):
    device_info: "DeviceInfo" = betterproto.message_field(1, group="stream_value")
    """
    Information about whether the device is connected or not, and if it is, gives
     information about the connected device
    """

    flow_cell_info: "_device__.GetFlowCellInfoResponse" = betterproto.message_field(
        2, group="stream_value"
    )
    """
    Information about the currently connected flow cell
    
     Note: if no flow cell is connected this [flow_cell_info.has_flow_cell] will be false
    """

    protocol_run_info: "_protocol__.ProtocolRunInfo" = betterproto.message_field(
        3, group="stream_value"
    )
    """
    Information about the in progress protocol.
    
     Note if no protocol is active this message will not be present.
    """

    acquisition_run_info: "_acquisition__.AcquisitionRunInfo" = (
        betterproto.message_field(4, group="stream_value")
    )
    """
    Information about the current acquisition run
    
     Note if no acquisition is active the message will not be present.
    """

    flow_cell_health: "StreamInstanceActivityResponseFlowCellHealth" = (
        betterproto.message_field(5, group="stream_value")
    )
    """
    Information about the health of the flow cell within the current run
    
     Note: only available if a run is in progress
    """

    yield_summary: "_acquisition__.AcquisitionYieldSummary" = betterproto.message_field(
        6, group="stream_value"
    )
    """
    Acquisition yield information. Describes information such as number of reads,
     what number of those reads have passed or failed basecalling etc. Rate
     limited to 1 second per update
    """

    basecall_speed: "BasecallSpeed" = betterproto.message_field(7, group="stream_value")
    """
    Basecall speed information
     Note: only available if an acquisition with basecalling enabled is in progress
    """

    n50: "N50" = betterproto.message_field(8, group="stream_value")
    """
    n50 information
    
     Contains the n50 value, measured in basecalled bases and estimated bases
    
     Note: basecalled bases only available if an acquisition with basecalling enabled is in progress
    """


@dataclass(eq=False, repr=False)
class StreamInstanceActivityResponseFlowCellHealth(betterproto.Message):
    channel_state_percentages: Dict[str, float] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_FLOAT
    )
    """
    Map between channel state name and a percentage of how much time that state has been active with respect to all other channel states
    
     This is over one minute of time this is calculated over
    """


class InstanceServiceStub(betterproto.ServiceStub):
    async def get_version_info(
        self,
        get_version_info_request: "GetVersionInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetVersionInfoResponse":
        return await self._unary_unary(
            "/minknow_api.instance.InstanceService/get_version_info",
            get_version_info_request,
            GetVersionInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_output_directories(
        self,
        get_output_directories_request: "GetOutputDirectoriesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OutputDirectories":
        return await self._unary_unary(
            "/minknow_api.instance.InstanceService/get_output_directories",
            get_output_directories_request,
            OutputDirectories,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_default_output_directories(
        self,
        get_default_output_directories_request: "GetDefaultOutputDirectoriesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OutputDirectories":
        return await self._unary_unary(
            "/minknow_api.instance.InstanceService/get_default_output_directories",
            get_default_output_directories_request,
            OutputDirectories,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_output_directory(
        self,
        set_output_directory_request: "SetOutputDirectoryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetOutputDirectoryResponse":
        return await self._unary_unary(
            "/minknow_api.instance.InstanceService/set_output_directory",
            set_output_directory_request,
            SetOutputDirectoryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_reads_directory(
        self,
        set_reads_directory_request: "SetReadsDirectoryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetReadsDirectoryResponse":
        return await self._unary_unary(
            "/minknow_api.instance.InstanceService/set_reads_directory",
            set_reads_directory_request,
            SetReadsDirectoryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_disk_space_info(
        self,
        get_disk_space_info_request: "GetDiskSpaceInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDiskSpaceInfoResponse":
        return await self._unary_unary(
            "/minknow_api.instance.InstanceService/get_disk_space_info",
            get_disk_space_info_request,
            GetDiskSpaceInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_disk_space_info(
        self,
        stream_disk_space_info_request: "StreamDiskSpaceInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetDiskSpaceInfoResponse]:
        async for response in self._unary_stream(
            "/minknow_api.instance.InstanceService/stream_disk_space_info",
            stream_disk_space_info_request,
            GetDiskSpaceInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_machine_id(
        self,
        get_machine_id_request: "GetMachineIdRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetMachineIdResponse":
        return await self._unary_unary(
            "/minknow_api.instance.InstanceService/get_machine_id",
            get_machine_id_request,
            GetMachineIdResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_instance_activity(
        self,
        stream_instance_activity_request: "StreamInstanceActivityRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamInstanceActivityResponse]:
        async for response in self._unary_stream(
            "/minknow_api.instance.InstanceService/stream_instance_activity",
            stream_instance_activity_request,
            StreamInstanceActivityResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InstanceServiceBase(ServiceBase):

    async def get_version_info(
        self, get_version_info_request: "GetVersionInfoRequest"
    ) -> "GetVersionInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_output_directories(
        self, get_output_directories_request: "GetOutputDirectoriesRequest"
    ) -> "OutputDirectories":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_default_output_directories(
        self,
        get_default_output_directories_request: "GetDefaultOutputDirectoriesRequest",
    ) -> "OutputDirectories":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_output_directory(
        self, set_output_directory_request: "SetOutputDirectoryRequest"
    ) -> "SetOutputDirectoryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_reads_directory(
        self, set_reads_directory_request: "SetReadsDirectoryRequest"
    ) -> "SetReadsDirectoryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_disk_space_info(
        self, get_disk_space_info_request: "GetDiskSpaceInfoRequest"
    ) -> "GetDiskSpaceInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_disk_space_info(
        self, stream_disk_space_info_request: "StreamDiskSpaceInfoRequest"
    ) -> AsyncIterator[GetDiskSpaceInfoResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetDiskSpaceInfoResponse()

    async def get_machine_id(
        self, get_machine_id_request: "GetMachineIdRequest"
    ) -> "GetMachineIdResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_instance_activity(
        self, stream_instance_activity_request: "StreamInstanceActivityRequest"
    ) -> AsyncIterator[StreamInstanceActivityResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamInstanceActivityResponse()

    async def __rpc_get_version_info(
        self,
        stream: "grpclib.server.Stream[GetVersionInfoRequest, GetVersionInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_version_info(request)
        await stream.send_message(response)

    async def __rpc_get_output_directories(
        self,
        stream: "grpclib.server.Stream[GetOutputDirectoriesRequest, OutputDirectories]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_output_directories(request)
        await stream.send_message(response)

    async def __rpc_get_default_output_directories(
        self,
        stream: "grpclib.server.Stream[GetDefaultOutputDirectoriesRequest, OutputDirectories]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_default_output_directories(request)
        await stream.send_message(response)

    async def __rpc_set_output_directory(
        self,
        stream: "grpclib.server.Stream[SetOutputDirectoryRequest, SetOutputDirectoryResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_output_directory(request)
        await stream.send_message(response)

    async def __rpc_set_reads_directory(
        self,
        stream: "grpclib.server.Stream[SetReadsDirectoryRequest, SetReadsDirectoryResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_reads_directory(request)
        await stream.send_message(response)

    async def __rpc_get_disk_space_info(
        self,
        stream: "grpclib.server.Stream[GetDiskSpaceInfoRequest, GetDiskSpaceInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_disk_space_info(request)
        await stream.send_message(response)

    async def __rpc_stream_disk_space_info(
        self,
        stream: "grpclib.server.Stream[StreamDiskSpaceInfoRequest, GetDiskSpaceInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_disk_space_info,
            stream,
            request,
        )

    async def __rpc_get_machine_id(
        self, stream: "grpclib.server.Stream[GetMachineIdRequest, GetMachineIdResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_machine_id(request)
        await stream.send_message(response)

    async def __rpc_stream_instance_activity(
        self,
        stream: "grpclib.server.Stream[StreamInstanceActivityRequest, StreamInstanceActivityResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_instance_activity,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.instance.InstanceService/get_version_info": grpclib.const.Handler(
                self.__rpc_get_version_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetVersionInfoRequest,
                GetVersionInfoResponse,
            ),
            "/minknow_api.instance.InstanceService/get_output_directories": grpclib.const.Handler(
                self.__rpc_get_output_directories,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetOutputDirectoriesRequest,
                OutputDirectories,
            ),
            "/minknow_api.instance.InstanceService/get_default_output_directories": grpclib.const.Handler(
                self.__rpc_get_default_output_directories,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDefaultOutputDirectoriesRequest,
                OutputDirectories,
            ),
            "/minknow_api.instance.InstanceService/set_output_directory": grpclib.const.Handler(
                self.__rpc_set_output_directory,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetOutputDirectoryRequest,
                SetOutputDirectoryResponse,
            ),
            "/minknow_api.instance.InstanceService/set_reads_directory": grpclib.const.Handler(
                self.__rpc_set_reads_directory,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetReadsDirectoryRequest,
                SetReadsDirectoryResponse,
            ),
            "/minknow_api.instance.InstanceService/get_disk_space_info": grpclib.const.Handler(
                self.__rpc_get_disk_space_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDiskSpaceInfoRequest,
                GetDiskSpaceInfoResponse,
            ),
            "/minknow_api.instance.InstanceService/stream_disk_space_info": grpclib.const.Handler(
                self.__rpc_stream_disk_space_info,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamDiskSpaceInfoRequest,
                GetDiskSpaceInfoResponse,
            ),
            "/minknow_api.instance.InstanceService/get_machine_id": grpclib.const.Handler(
                self.__rpc_get_machine_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetMachineIdRequest,
                GetMachineIdResponse,
            ),
            "/minknow_api.instance.InstanceService/stream_instance_activity": grpclib.const.Handler(
                self.__rpc_stream_instance_activity,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamInstanceActivityRequest,
                StreamInstanceActivityResponse,
            ),
        }
