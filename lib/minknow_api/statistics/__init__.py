# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/statistics.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import acquisition as _acquisition__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ReadLengthType(betterproto.Enum):
    MinknowEvents = 0
    """
    MinKNOW events are measured as reads are being read, and are available very soon after
     the read finishes
    """

    EstimatedBases = 1
    """
    Estimated bases are calculated from MinKNOW events, based on an approximate
     events-to-bases relationship.  Estimated bases become available at the same time as
     MinknowEvents become available.
    """

    BasecalledBases = 2
    """
    Basecalled bases are the number of bases reported by live base-calling.  This requires
     that live basecalling is enabled.  As basecalling takes time to complete, these values
     will update after the MinknowEvents or EstimatedBases histograms update.
    """


class BucketValueType(betterproto.Enum):
    """The data accumulated in read length histogram buckets"""

    ReadCounts = 0
    """
    Histogram buckets contain the total number of reads with lengths that fall within the
     histogram bucket range
    """

    ReadLengths = 1
    """
    Histogram buckets contain the total number of events or basecalled bases contained
     within reads that fall within the histogram bucket range
    
     The units (events, estimated bases, basecalled bases) is determined by the
     `read_length_type` setting.
    """


class ReadEndReason(betterproto.Enum):
    All = 0
    Unknown = 1
    Partial = 2
    MuxChange = 3
    UnblockMuxChange = 4
    SignalPositive = 5
    SignalNegative = 6
    DataServiceUnblockMuxChange = 7


class QScoreHistogramBucketValueType(betterproto.Enum):
    QScore_ReadCounts = 0
    """
    Histogram buckets contain the total number of reads with q-scores that fall within the
     histogram bucket range
    """

    QScore_BasecalledBases = 1
    """
    Histogram buckets contain the total number of basecalled bases contained within reads
     that have an average q-score that falls within the histogram bucket range
    
     Note that all bases for a given read are added to the bucket that corresponds to the average
     q-score for that read -- bases are not added to buckets depending on their individual
     q-scores
    """


class QAccuracyHistogramBucketValueType(betterproto.Enum):
    QAccuracy_ReadCounts = 0
    """
    Histogram buckets contain the total number of reads with q-accuracy that fall within the
     histogram bucket range
    """

    QAccuracy_BasecalledBases = 1
    """
    Histogram buckets contain the total number of basecalled bases contained within reads
     that have an average q-accuracy that falls within the histogram bucket range
    
     Note that all bases for a given read are added to the bucket that corresponds to the average
     q-accuracy for that read -- bases are not added to buckets depending on their individual
     q-accuracy
    """


class QScoreHistogramKeyReadType(betterproto.Enum):
    All = 0
    """
    If duplex basecalling is not enabled, equivalent to `Simplex`
     If duplex basecalling is enabled, the sum of `Simplex` and `Duplex`
    """

    Simplex = 1
    """
    All simplex data
    
     When duplex basecalling is enabled, this contains reads/bases from both:
     - Simplex reads
     - Template and complement reads (which are subsequently combined into duplex reads)
    """

    Duplex = 2
    """
    Duplex data
     Only available if duplex basecalling is enabled
    """


class QScoreHistogramKeyBasecallStatus(betterproto.Enum):
    Any = 0
    Skipped = 1
    Failed = 2
    Passed = 3


class QAccuracyHistogramKeyReadType(betterproto.Enum):
    All = 0
    """
    If duplex basecalling is not enabled, equivalent to `Simplex`
     If duplex basecalling is enabled, the sum of `Simplex` and `Duplex`
    """

    Simplex = 1
    """
    All simplex data
    
     When duplex basecalling is enabled, this contains reads/bases from both:
     - Simplex reads
     - Template and complement reads (which are subsequently combined into duplex reads)
    """

    Duplex = 2
    """
    Duplex data
     Only available if duplex basecalling is enabled
    """


class QAccuracyHistogramKeyBasecallStatus(betterproto.Enum):
    Any = 0
    Skipped = 1
    Failed = 2
    Passed = 3


class StreamBoxplotRequestBoxplotType(betterproto.Enum):
    QSCORE = 0
    """
    Qscore of reads from the basecaller.
    
     Only available if basecalling
    """

    BASES_PER_SECOND = 1
    """
    Number of bases per second the data is moving through the sequencer.
    
     Only available if basecalling.
    """

    ACCURACY = 2
    """
    Accuracy of reads aligned to provided reference.
    
     Accuracy is measured in percent 0-100.
    
     Only available if alignment is enabled.
    """


@dataclass(eq=False, repr=False)
class DataSelection(betterproto.Message):
    """
    Specify a desired data selection.

     Units for values are as specified in the corresponding Request

     The actual data selection used may differ from the desired one.  They are adjusted in the
     following sequence:

      1. All values are set equal to the corresponding desired value.
      2. Negative `start` or `end` values are fixed up by adding the current maximum value to the
         specified value
          - Negative start and end values are only supported for certain requests; typically they are
            supported for time-series data
          - If, after adding the current bucket count, the `start` value is still negative, then the
            start value is adjusted to `0`
          - If, after adding the current bucket count, the `end` value is still negative, or is zero,
            then the data selection is empty
          - If data collection is still ongoing, then the current bucket count may change between rpc
            calls as more data is collected.
      3. Values which are not set, or which are set at `0`, are then adjusted to a default value:
          - `start` and `step` will be set to the minimum valid value
          - `end` will be set to the maximum valid value
      4. Values which are outside of the valid range are clamped to the nearest valid value:
          - Values less than minimum valid value will be set equal to the minimum valid value
          - Values greater than the maximum valid value will be set equal to the maximum valid value
      5. Finally, all values are 'rounded' to a nearby valid value
          - `start` and `step` will be rounded down to the first valid value less than or equal to
            their current values
          - `end` will be rounded up to the first valid value that is greater than or equal to its
            current value
          - This means that the range that is specified after rounding includes the range that was
            specified prior to rounding

     If (`end` - `start`) is not an exact integer multiple of `step`, then the final bucket will cover
     a smaller range than that specified by `step`.

     Note also that the maximum valid start and end value may not be known if data collection is still
     ongoing -- for example, the maximum valid time for time series data.  If this is the case, then
     the maximum valid value will be determined when the experiment ends, and values in use will be
     adjusted accordingly.
    """

    start: int = betterproto.int64_field(1)
    step: int = betterproto.uint64_field(2)
    end: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class FloatDataSelection(betterproto.Message):
    """
    Specify a desired data selection, using floating point values

     The actual data selection used may differ from the desired one.  They are adjusted in the
     following sequence:

      1. The selection is set equal to the desired selection
      2. Any selection value that is not set is adjusted to its default value:
          - `start` and `step` will be set to the minimum valid value
          - `end` will be set to the maximum valid value
      3. Values which are outside of the valid range are clamped to the nearest valid value:
          - Values less than minimum valid value will be set equal to the minimum valid value
          - Values greater than the maximum valid value will be set equal to the maximum valid value
      4. Finally, all values are 'rounded' to a nearby valid value
          - `start` and `step` will be rounded down to the first valid value less than or equal to
            their current values
          - `end` will be rounded up to the first valid value that is greater than or equal to its
            current value
          - This means that the range that is specified after rounding includes the range that was
            specified prior to rounding
    """

    start: Optional[float] = betterproto.float_field(1, optional=True)
    step: Optional[float] = betterproto.float_field(2, optional=True)
    end: Optional[float] = betterproto.float_field(3, optional=True)


@dataclass(eq=False, repr=False)
class StreamDutyTimeRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""

    data_selection: "DataSelection" = betterproto.message_field(2)
    """
    The desired data selection.
    
     The units for all values are `seconds since the start of the experiment`.
    """


@dataclass(eq=False, repr=False)
class StreamDutyTimeResponse(betterproto.Message):
    bucket_ranges: List["StreamDutyTimeResponseBucketRange"] = (
        betterproto.message_field(1)
    )
    """The range covered by each entry in state_times"""

    channel_states: Dict[str, "StreamDutyTimeResponseChannelStateData"] = (
        betterproto.map_field(2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    """
    Map between channel state names, and a list of bucketed duty time data
    """


@dataclass(eq=False, repr=False)
class StreamDutyTimeResponseBucketRange(betterproto.Message):
    start: int = betterproto.uint32_field(1)
    """
    The range covered by a bucket
     Values are in seconds
    
     The range [start, end) is half open (i.e. the start value is included, the end value is
     not).
    """

    end: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class StreamDutyTimeResponseChannelStateData(betterproto.Message):
    state_times: List[int] = betterproto.uint64_field(1)
    """
    How much time (in samples) spent in this channel state, for each bucket
    """


@dataclass(eq=False, repr=False)
class ReadLengthHistogramKey(betterproto.Message):
    read_end_reason: "ReadEndReason" = betterproto.enum_field(1)
    """
    Only return data for the given ReadEndReason.
    
     Special values:
       - Specify `ReadEndReason::All` to return data for all read end reasons
    
     If unspecified all read end reasons are returned.
    """


@dataclass(eq=False, repr=False)
class ReadLengthHistogramSplit(betterproto.Message):
    read_end_reason: bool = betterproto.bool_field(1)
    """Split returned data by read_end_reason"""


@dataclass(eq=False, repr=False)
class StreamReadLengthHistogramRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """
    The `acquisition_run_id` of the acquisition to obtain data for
    
     If this is set to the `acquisition_run_id` of an acquisition which is in-progress, then
     updates containing the latest histogram data for that acquisition will be streamed regularly
     until that acquisition finishes (see `poll_time_seconds` below)
    
     Otherwise, if this is set to the `acquisition_run_id` of an acquisition which is finished,
     and for which final histogram data is available, then the final histogram data for that
     acquisition will be returned.  Final histogram data is available until it is cleared.
    
     Otherwise, if this parameter is not set, or is set to a value which is neither the
     `acquisition_run_id` of an acquisition which is in-progress, nor the `acquisition_run_id` of
     an acquisition for which final histogram data is available, then this call will fail with the
     status `INVALID_ARGUMENT`.
    """

    poll_time_seconds: int = betterproto.uint32_field(2)
    """
    How often to return new histogram data, in seconds
    
     If not specified, or set to `0`, then the poll time will be set to 60 seconds
    
     If data is being returned for an acquisition which is in progress, then one update will be
     sent when the call is first performed, then subsequently every `poll_time` after that, and
     then finally once again when the acquisition finishes.
    
     Otherwise, if final histogram data is being returned for an acquisition that has already
     finished, this parameter has no effect.  The final histogram data will be returned, and the
     call will complete.
    """

    read_length_type: "ReadLengthType" = betterproto.enum_field(3)
    """
    The source of the read lengths in the histogram
    
     If MinKNOW is unable to supply data from the requested source (e.g. if the user requests
     BasecalledBases, but basecalling is not enabled), then this call will fail with the status
     `FAILED_PRECONDITION`.
    
     See `ReadLengthType` for further information about the available options.
    """

    data_selection: "DataSelection" = betterproto.message_field(4)
    """
    The desired read length range which histograms should cover.
     Units are as set in `read_length_type`, above.
    """

    bucket_value_type: "BucketValueType" = betterproto.enum_field(5)
    """
    What data to accumulate in the read length histogram buckets
    
     See `BucketValueType` for further information about the available options.
    """

    discard_outlier_percent: float = betterproto.float_field(6)
    """
    If set greater than zero then discard some percent of data at the upper end of the source
     data before producing histograms and N50 values.
    
     This is intended to assist in the case where a small number of outliers with very long read
     lengths cause the histogram axes and N50 to be skewed.
    
     Defaults to 0 - no data discarded.
     Values should be specified in percent - a value of 0.05 will cause the top 5% of the data
     to be discarded before producing outputs.
    
     For histograms, the data discarded depends on the bucket_value_type.  If `ReadCounts`, then
     a percentage of the total number of reads reads will be discarded; if `ReadLengths` then a
     percentage of the total read lengths will be discarded.
    
     For the N50 value, `discard_outlier_percent` always causes a percentage of the total
     read lengths to be discarded (since it is always calculated from read length data)
    """

    filtering: List["ReadLengthHistogramKey"] = betterproto.message_field(7)
    """Define filtering parameters for streamed data."""

    split: "ReadLengthHistogramSplit" = betterproto.message_field(8)
    """Define how results are split for returned data."""


@dataclass(eq=False, repr=False)
class StreamReadLengthHistogramResponse(betterproto.Message):
    read_length_type: "ReadLengthType" = betterproto.enum_field(1)
    """
    The data source for the histograms
    
     Also specifies the units for `data_selection` and `n50`
    
     See `ReadLengthType` for further information about the possible options.
    """

    bucket_ranges: List["StreamReadLengthHistogramResponseBucketRange"] = (
        betterproto.message_field(2)
    )
    """The range covered by each bucket in the histogram data"""

    source_data_end: int = betterproto.uint64_field(5)
    """
    The right hand edge of the last source bucket which contains data
    
     Measured across all source data, after excluding the reads specified by
     `discard_outlier_percent` in the stream request.
    """

    bucket_value_type: "BucketValueType" = betterproto.enum_field(3)
    """
    The data accumulated in the read length histogram buckets
    
     See `BucketValueType` for further information about the possible options.
    """

    histogram_data: List["StreamReadLengthHistogramResponseReadLengthHistogramData"] = (
        betterproto.message_field(4)
    )
    """The histogram data"""


@dataclass(eq=False, repr=False)
class StreamReadLengthHistogramResponseBucketRange(betterproto.Message):
    start: int = betterproto.uint64_field(1)
    """
    The range covered by a bucket
     Units are as set in `read_length_type`, above
    
     The range [start, end) is half open (i.e. the start value is included, the end value is
     not).
    """

    end: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class StreamReadLengthHistogramResponseReadLengthHistogramData(betterproto.Message):
    filtering: List["ReadLengthHistogramKey"] = betterproto.message_field(3)
    """The filtering parameters which contributed to this bucket."""

    bucket_values: List[int] = betterproto.uint64_field(1)
    """
    Counts for each histogram bucket
    
     Units are as specified in `read_length_type`
     The range covered by each bucket is as in `bucket_ranges`
     The type of data accumulated in each bucket is given by `bucket_value_type`
    """

    n50: float = betterproto.float_field(2)
    """
    The N50 value for the read length data for the selected `read_length_type` and
     `read_end_reasons`.
    
     Units are as specified by `read_length_type`.
    
     Measured across all source data, after excluding the reads specified by
     `discard_outlier_percent` in the stream request.
    """


@dataclass(eq=False, repr=False)
class ReadLengthN50Request(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The `acquisition_run_id` of the acquisition to obtain data for"""


@dataclass(eq=False, repr=False)
class ReadLengthN50Response(betterproto.Message):
    n50_data: "ReadLengthN50ResponseReadN50Data" = betterproto.message_field(1)
    """The N50 return data"""


@dataclass(eq=False, repr=False)
class ReadLengthN50ResponseReadN50Data(betterproto.Message):
    estimated_n50: float = betterproto.float_field(1)
    """
    The estimated N50 value in bases
    
     This is always set
    """

    basecalled_n50: float = betterproto.float_field(2)
    """
    The basecalled N50 value
    
     If the acquisition did/does not have live basecalling enabled, this will be 0.0
    """


@dataclass(eq=False, repr=False)
class GetReadLengthTypesRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""


@dataclass(eq=False, repr=False)
class GetReadLengthTypesResponse(betterproto.Message):
    available_types: List["ReadLengthType"] = betterproto.enum_field(1)
    """
    Array of the types of bucket for which a histogram is currently available
    """


@dataclass(eq=False, repr=False)
class QScoreHistogramKey(betterproto.Message):
    read_type: "QScoreHistogramKeyReadType" = betterproto.enum_field(1)
    call_status: "QScoreHistogramKeyBasecallStatus" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class StreamQScoreHistogramRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """
    The `acquisition_run_id` of the acquisition to obtain data for
    
     If this is set to the `acquisition_run_id` of an acquisition which is in-progress, then
     updates containing the latest histogram data for that acquisition will be streamed regularly
     until that acquisition finishes (see `poll_time_seconds` below)
    
     Otherwise, if this is set to the `acquisition_run_id` of an acquisition which is finished,
     and for which final histogram data is available, then the final histogram data for that
     acquisition will be returned.  Final histogram data is available until it is cleared.
    
     Otherwise, if this parameter is not set, or is set to a value which is neither the
     `acquisition_run_id` of an acquisition which is in-progress, nor the `acquisition_run_id` of
     an acquisition for which final histogram data is available, then this call will fail with the
     status `INVALID_ARGUMENT`.
    """

    poll_time_seconds: int = betterproto.uint32_field(2)
    """
    How often to return new histogram data, in seconds
    
     If not specified, or set to `0`, then the poll time will be set to 60 seconds
    
     If data is being returned for an acquisition which is in progress, then one update will be
     sent when the call is first performed, then subsequently every `poll_time` after that, and
     then finally once again when the acquisition finishes.
    
     Otherwise, if final histogram data is being returned for an acquisition that has already
     finished, this parameter has no effect.  The final histogram data will be returned, and the
     call will complete.
    """

    data_selection: "FloatDataSelection" = betterproto.message_field(3)
    """The desired q score range which histograms should cover."""

    bucket_value_type: "QScoreHistogramBucketValueType" = betterproto.enum_field(4)
    """
    What data to accumulate in the histogram buckets
    
     See `QScoreHistogramBucketValueType` for further information about the available options.
    """


@dataclass(eq=False, repr=False)
class StreamQScoreHistogramResponse(betterproto.Message):
    bucket_value_type: "QScoreHistogramBucketValueType" = betterproto.enum_field(1)
    """
    The data accumulated in the histogram buckets
    
     See `QScoreHistogramBucketValueType` for further information about the possible options.
    """

    bucket_ranges: List["StreamQScoreHistogramResponseBucketRange"] = (
        betterproto.message_field(2)
    )
    """The range covered by each bucket in the histogram data"""

    source_data_range: "StreamQScoreHistogramResponseBucketRange" = (
        betterproto.message_field(3)
    )
    """The range covered by non-empty buckets in the source data"""

    histogram_data: List["StreamQScoreHistogramResponseQScoreHistogramData"] = (
        betterproto.message_field(4)
    )
    """
    The histogram data
    
     If duplex basecalling is not enabled, then Simplex histogram data will be returned
     If duplex basecalling is enabled, then Simplex, Duplex and "All" (i.e. overall) histogram
     data will be returned
    """


@dataclass(eq=False, repr=False)
class StreamQScoreHistogramResponseBucketRange(betterproto.Message):
    start: float = betterproto.float_field(1)
    """
    The range covered by a bucket
    
     The range [start, end) is half open (i.e. the start value is included, the end value is
     not).
    """

    end: float = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class StreamQScoreHistogramResponseQScoreHistogramData(betterproto.Message):
    filtering: List["QScoreHistogramKey"] = betterproto.message_field(1)
    """The filtering parameters which contributed to this bucket."""

    bucket_values: List[int] = betterproto.uint64_field(2)
    """
    Counts for each histogram bucket
    
     Units and type of accumulated values are as specified in `bucket_value_type`
     The range covered by each bucket is as in `bucket_ranges`
    """

    modal_q_score: float = betterproto.float_field(3)
    """The modal q score, calculated using the `bucket_value_type`"""


@dataclass(eq=False, repr=False)
class QAccuracyHistogramKey(betterproto.Message):
    read_type: "QAccuracyHistogramKeyReadType" = betterproto.enum_field(1)
    call_status: "QAccuracyHistogramKeyBasecallStatus" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class StreamQAccuracyHistogramRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """
    The `acquisition_run_id` of the acquisition to obtain data for
    
     If this is set to the `acquisition_run_id` of an acquisition which is in-progress, then
     updates containing the latest histogram data for that acquisition will be streamed regularly
     until that acquisition finishes (see `poll_time_seconds` below)
    
     Otherwise, if this is set to the `acquisition_run_id` of an acquisition which is finished,
     and for which final histogram data is available, then the final histogram data for that
     acquisition will be returned.  Final histogram data is available until it is cleared.
    
     Otherwise, if this parameter is not set, or is set to a value which is neither the
     `acquisition_run_id` of an acquisition which is in-progress, nor the `acquisition_run_id` of
     an acquisition for which final histogram data is available, then this call will fail with the
     status `INVALID_ARGUMENT`.
    """

    poll_time_seconds: int = betterproto.uint32_field(2)
    """
    How often to return new histogram data, in seconds
    
     If not specified, or set to `0`, then the poll time will be set to 60 seconds
    
     If data is being returned for an acquisition which is in progress, then one update will be
     sent when the call is first performed, then subsequently every `poll_time` after that, and
     then finally once again when the acquisition finishes.
    
     Otherwise, if final histogram data is being returned for an acquisition that has already
     finished, this parameter has no effect.  The final histogram data will be returned, and the
     call will complete.
    """

    data_selection: "FloatDataSelection" = betterproto.message_field(3)
    """The desired q accuracy range which histograms should cover."""

    bucket_value_type: "QAccuracyHistogramBucketValueType" = betterproto.enum_field(4)
    """
    What data to accumulate in the histogram buckets
    
     See `QAccuracyHistogramBucketValueType` for further information about the available options.
    """


@dataclass(eq=False, repr=False)
class StreamQAccuracyHistogramResponse(betterproto.Message):
    bucket_value_type: "QAccuracyHistogramBucketValueType" = betterproto.enum_field(1)
    """
    The data accumulated in the histogram buckets
    
     See `QAccuracyHistogramBucketValueType` for further information about the possible options.
    """

    bucket_ranges: List["StreamQAccuracyHistogramResponseBucketRange"] = (
        betterproto.message_field(2)
    )
    """The range covered by each bucket in the histogram data"""

    source_data_range: "StreamQAccuracyHistogramResponseBucketRange" = (
        betterproto.message_field(3)
    )
    """The range covered by non-empty buckets in the source data"""

    histogram_data: List["StreamQAccuracyHistogramResponseQAccuracyHistogramData"] = (
        betterproto.message_field(4)
    )
    """
    The histogram data
    
     If duplex basecalling is not enabled, then Simplex histogram data will be returned
     If duplex basecalling is enabled, then Simplex, Duplex and "All" (i.e. overall) histogram
     data will be returned
    """


@dataclass(eq=False, repr=False)
class StreamQAccuracyHistogramResponseBucketRange(betterproto.Message):
    start: float = betterproto.float_field(1)
    """
    The range covered by a bucket
    
     The range [start, end) is half open (i.e. the start value is included, the end value is
     not).
    """

    end: float = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class StreamQAccuracyHistogramResponseQAccuracyHistogramData(betterproto.Message):
    filtering: List["QAccuracyHistogramKey"] = betterproto.message_field(1)
    """The filtering parameters which contributed to this bucket."""

    bucket_values: List[int] = betterproto.uint64_field(2)
    """
    Counts for each histogram bucket
    
     Units and type of accumulated values are as specified in `bucket_value_type`
     The range covered by each bucket is as in `bucket_ranges`
    """

    modal_q_accuracy: float = betterproto.float_field(3)
    """The modal q accuracy, calculated using the `bucket_value_type`"""


@dataclass(eq=False, repr=False)
class AcquisitionOutputKey(betterproto.Message):
    barcode_name: str = betterproto.string_field(1)
    """
    Only return data for the given barcode.
    
     Special values:
       - Specify "unclassified" for data which does not have a barcode.
       - Specify "classified" for all data which has a barcode.
    
     If unspecified all barcodes are returned.
    """

    alignment_reference: str = betterproto.string_field(2)
    """
    Only return data for the given alignment reference.
    
     Special values:
       - Specify "unaligned" for data which does not align to a reference
       - Specify "aligned" for all data which aligns to a reference
    
     If unspecified all alignment targets are returned.
    """

    alignment_bed_file_region: str = betterproto.string_field(3)
    """
    Only return data for the given target region.
    
     Target regions are defined in bed files.
    
     The region is a string which identifies an entry in the bed file.
    
     Special values:
       - Specify "offtarget" for data which does not have a bed region.
       - Specify "ontarget" for all data which has a bed region.
    
     If unspecified all alignment regions are returned.
    """

    alignment_bed_file_region_name: str = betterproto.string_field(8)
    """
    An alias to `alignment_bed_file_region`
    
     An optional name can be used to identify a target region in the bed file
    """

    lamp_barcode_id: str = betterproto.string_field(4)
    """
    Only return data for the given lamp barcode.
    
     Special values:
       - Specify "unclassified" for data which does not have a lamp barcode.
       - Specify "classified" for all data which has a lamp barcode.
    
     If unspecified all lamp barcodes are returned.
    
     DEPRECATED 6.0: Lamp support has been removed and this option will always be ignored.
    """

    lamp_target_id: str = betterproto.string_field(5)
    """
    Only return data for the given lamp target.
    
     Special values:
       - Specify "unclassified" for data which does not have a lamp target.
       - Specify "classified" for all data which has a lamp target.
     Using barcode terms here as lamp is part of barcoding pipeline
    
     If unspecified all lamp target are returned.
    
     DEPRECATED 6.0: Lamp support has been removed and this option will always be ignored.
    """

    barcode_alias: str = betterproto.string_field(6)
    """The barcode alias corresponding to the `barcode_name`"""

    read_end_reason: "ReadEndReason" = betterproto.enum_field(7)
    """
    Only return data for the given ReadEndReason.
    
     Special values:
       - Specify `ReadEndReason::All` to return data for all read end reasons
    
     If unspecified all read end reasons are returned.
    """


@dataclass(eq=False, repr=False)
class AcquisitionOutputSplit(betterproto.Message):
    barcode_name: bool = betterproto.bool_field(1)
    """Split data for every individual barcode."""

    alignment_reference: bool = betterproto.bool_field(2)
    """
    Split data for each individual alignment reference.
    
     References are defined in alignment references.
    """

    alignment_bed_file_region: bool = betterproto.bool_field(3)
    """
    Split data for each target region.
    
     Target regions are defined in bed files.
    """

    lamp_barcode_id: bool = betterproto.bool_field(4)
    """
    Split data for each lamp barcode id.
    
     Lamp barcodes are defined by the active lamp kit.
    
     DEPRECATED 6.0: Lamp support has been removed and this option will always be ignored.
    """

    lamp_target_id: bool = betterproto.bool_field(5)
    """
    Split data for each lamp targets id.
    
     Lamp targets are defined by the active lamp kit.
    
     DEPRECATED 6.0: Lamp support has been removed and this option will always be ignored.
    """

    read_end_reason: bool = betterproto.bool_field(6)
    """Split returned data by read_end_reason"""


@dataclass(eq=False, repr=False)
class StreamAcquisitionOutputRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""

    data_selection: "DataSelection" = betterproto.message_field(2)
    """
    The desired data selection.
    
     The units for all values are `seconds since the start of the experiment`.
    """

    filtering: List["AcquisitionOutputKey"] = betterproto.message_field(3)
    """Define filtering parameters for streamed data."""

    split: "AcquisitionOutputSplit" = betterproto.message_field(4)
    """Define how results are split for returned data."""


@dataclass(eq=False, repr=False)
class AcquisitionOutputSnapshot(betterproto.Message):
    """
    A snapshot of acquisition output data, for a given set of filtering criteria.
    """

    seconds: int = betterproto.uint32_field(1)
    """
    The time the snapshot was collected, in seconds.
    
     Represents the number of seconds since the start of the experiment
     Will usually stream in minute chunks, so will first see 60, then 120 etc
    """

    yield_summary: "_acquisition__.AcquisitionYieldSummary" = betterproto.message_field(
        2
    )
    """The yield summary data."""


@dataclass(eq=False, repr=False)
class StreamAcquisitionOutputResponse(betterproto.Message):
    snapshots: List["StreamAcquisitionOutputResponseFilteredSnapshots"] = (
        betterproto.message_field(1)
    )
    """Snapshots split by requested filtering parameters."""


@dataclass(eq=False, repr=False)
class StreamAcquisitionOutputResponseFilteredSnapshots(betterproto.Message):
    filtering: List["AcquisitionOutputKey"] = betterproto.message_field(1)
    """The filtering parameters which contributed to this bucket."""

    snapshots: List["AcquisitionOutputSnapshot"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class StreamWriterOutputRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""

    data_selection: "DataSelection" = betterproto.message_field(2)
    """
    The desired data selection.
    
     The units for all values are `seconds since the start of the experiment`.
    """


@dataclass(eq=False, repr=False)
class WriterOutputSnapshot(betterproto.Message):
    """A snapshot of writer data."""

    seconds: int = betterproto.uint32_field(1)
    """
    The time the snapshot was collected, in seconds.
    
     Represents the number of seconds since the start of the experiment
     Will usually stream in minute chunks, so will first see 60, then 120 etc
    """

    writer_output: "_acquisition__.AcquisitionWriterSummary" = (
        betterproto.message_field(2)
    )
    """The writer data for this bucket."""


@dataclass(eq=False, repr=False)
class StreamWriterOutputResponse(betterproto.Message):
    snapshots: List["WriterOutputSnapshot"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StreamEncounteredAcquisitionOutputKeysRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""


@dataclass(eq=False, repr=False)
class StreamEncounteredAcquisitionOutputKeysResponse(betterproto.Message):
    acquisition_output_keys: List["AcquisitionOutputKey"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StreamTemperatureRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""

    data_selection: "DataSelection" = betterproto.message_field(2)
    """
    The desired data selection.
    
     The units for all values are `seconds since the start of the experiment`.
    """


@dataclass(eq=False, repr=False)
class TemperaturePacket(betterproto.Message):
    minion: "TemperaturePacketMinIonTemperature" = betterproto.message_field(
        1, group="temperature"
    )
    promethion: "TemperaturePacketPromethIonTemperature" = betterproto.message_field(
        2, group="temperature"
    )
    pebble: "TemperaturePacketPebbleTemperature" = betterproto.message_field(
        4, group="temperature"
    )
    target_temperature: "TemperaturePacketRange" = betterproto.message_field(3)
    """
    The range is based on the requested target temperature and tolerance.
    
     For example, if the target temperature is 35, and the tolerance is 1
     then target temperatures will return as 34(min) and 36(max).
    """


@dataclass(eq=False, repr=False)
class TemperaturePacketRange(betterproto.Message):
    """Represents a range of values."""

    minimum: float = betterproto.float_field(1)
    maximum: float = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class TemperaturePacketMinIonTemperature(betterproto.Message):
    """Packet of temperatures appropriate for a MinION."""

    asic_temperature: float = betterproto.double_field(1)
    """Temperature as measured by the probe inside the asic."""

    heatsink_temperature: float = betterproto.double_field(2)
    """Temperature as measured by the probe in the minion heatsink."""


@dataclass(eq=False, repr=False)
class TemperaturePacketPromethIonTemperature(betterproto.Message):
    """Packet of temperatures appropriate for a PromethION."""

    flowcell_temperature: float = betterproto.double_field(1)
    """Temperature as measured by thermistor TH2 on the P-Chip."""

    chamber_temperature: float = betterproto.double_field(2)
    """
    Mean of 12 pixel-blocks temperatures measured with sensors in the ASIC.
    """


@dataclass(eq=False, repr=False)
class TemperaturePacketPebbleTemperature(betterproto.Message):
    """Packet of temperatures appropriate for a Pebble."""

    asic_temperature: float = betterproto.double_field(1)
    """Temperature as measured by probe inside the ASIC."""

    instrument_temperature: float = betterproto.double_field(2)
    """Temperature as measured by thermistor on the instrument."""


@dataclass(eq=False, repr=False)
class StreamTemperatureResponse(betterproto.Message):
    temperatures: List["TemperaturePacket"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BiasVoltagePacket(betterproto.Message):
    acquisition_index: int = betterproto.uint64_field(1)
    bias_voltage: float = betterproto.double_field(2)
    time_seconds: int = betterproto.uint64_field(3)


@dataclass(eq=False, repr=False)
class StreamBiasVoltagesRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""


@dataclass(eq=False, repr=False)
class StreamBiasVoltagesResponse(betterproto.Message):
    bias_voltages: List["BiasVoltagePacket"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StreamBoxplotRequest(betterproto.Message):
    acquisition_run_id: str = betterproto.string_field(1)
    """The acquisition id of the experiment."""

    data_type: "StreamBoxplotRequestBoxplotType" = betterproto.enum_field(2)
    """Type of boxplot data to return."""

    dataset_width: int = betterproto.uint32_field(3)
    """
    Defines, in minutes, the width of each dataset.
     This is how much time should each dataset (boxplot) cover. Note that MinKNOW stores
     all stats at a default granularity (specified in the config file, i.e. 10 min in MinKNOW 3.2).
     This dataset_width HAS to be a multiple of the default granularity!
    
     Note:
     When multiple buckets are aggregated into a single dataset, the resulting dataset will
     contain the average of the aggregated quantiles (with the exception of min/max)! This is not the
     same as using a larger granularity in MinKNOW configs - the values that MinKNOW stores
     are the true quantiles. Averaging quantiles will give a rough approximation, but not a quantile.
     If the finest granularity is not required, we strongly suggest changing the time coverage in the config,
     not the dataset_width in the rpc.
    """

    poll_time: int = betterproto.uint32_field(4)
    """
    How often to return messages in this stream, specified in seconds. Note that this stream will
     return results regardless of the stats updates (because it always returns all the datasets).
     poll_time should be larger than the basecalled stats update rate in MinKNOW -
     please see basecalled_stats_refresh_rate_seconds in the configs
     (set to 1 second in MinKNOW 3.2).
    
     If unspecified, defaults to 1 minute.
    """


@dataclass(eq=False, repr=False)
class BoxplotResponse(betterproto.Message):
    datasets: List["BoxplotResponseBoxplotDataset"] = betterproto.message_field(1)
    """
    Result boxplots are stored in this array. This is an overview of the stored data
     from the START of the acquisition period. This includes ALL the basecalled stats
     from MinKNOW, not just updates since previous calls!
    """


@dataclass(eq=False, repr=False)
class BoxplotResponseBoxplotDataset(betterproto.Message):
    min: float = betterproto.float_field(1)
    """Minimum value for any point in the dataset."""

    q25: float = betterproto.float_field(2)
    """25th quartile value for all points in the dataset."""

    q50: float = betterproto.float_field(3)
    """50th quartile or median value for all points in the dataset."""

    q75: float = betterproto.float_field(4)
    """75th quartile value for all points in the dataset."""

    max: float = betterproto.float_field(5)
    """Maximum value for any point in the dataset."""

    count: int = betterproto.uint64_field(6)
    """Number of items in this box plot's stats."""

    lower_full_width_half_maximum: float = betterproto.float_field(7)
    """
    Estimated lower value where there is half the data compared to the mode.
     provides some estimate on the sharpness of the mode peak.
    """

    mode: float = betterproto.float_field(8)
    """Estimated mode for the dataset."""

    upper_full_width_half_maximum: float = betterproto.float_field(9)
    """
    Estimated upper value where there is half the data compared to the mode.
     provides some estimate on the sharpness of the mode peak.
    """


class StatisticsServiceStub(betterproto.ServiceStub):
    async def stream_duty_time(
        self,
        stream_duty_time_request: "StreamDutyTimeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamDutyTimeResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_duty_time",
            stream_duty_time_request,
            StreamDutyTimeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_acquisition_output(
        self,
        stream_acquisition_output_request: "StreamAcquisitionOutputRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamAcquisitionOutputResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_acquisition_output",
            stream_acquisition_output_request,
            StreamAcquisitionOutputResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_writer_output(
        self,
        stream_writer_output_request: "StreamWriterOutputRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamWriterOutputResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_writer_output",
            stream_writer_output_request,
            StreamWriterOutputResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_encountered_acquisition_output_keys(
        self,
        stream_encountered_acquisition_output_keys_request: "StreamEncounteredAcquisitionOutputKeysRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamEncounteredAcquisitionOutputKeysResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_encountered_acquisition_output_keys",
            stream_encountered_acquisition_output_keys_request,
            StreamEncounteredAcquisitionOutputKeysResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_temperature(
        self,
        stream_temperature_request: "StreamTemperatureRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamTemperatureResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_temperature",
            stream_temperature_request,
            StreamTemperatureResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_bias_voltages(
        self,
        stream_bias_voltages_request: "StreamBiasVoltagesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamBiasVoltagesResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_bias_voltages",
            stream_bias_voltages_request,
            StreamBiasVoltagesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_read_length_histogram(
        self,
        stream_read_length_histogram_request: "StreamReadLengthHistogramRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamReadLengthHistogramResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_read_length_histogram",
            stream_read_length_histogram_request,
            StreamReadLengthHistogramResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def read_length_n50(
        self,
        read_length_n50_request: "ReadLengthN50Request",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ReadLengthN50Response":
        return await self._unary_unary(
            "/minknow_api.statistics.StatisticsService/read_length_n50",
            read_length_n50_request,
            ReadLengthN50Response,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_read_length_types(
        self,
        get_read_length_types_request: "GetReadLengthTypesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetReadLengthTypesResponse":
        return await self._unary_unary(
            "/minknow_api.statistics.StatisticsService/get_read_length_types",
            get_read_length_types_request,
            GetReadLengthTypesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_q_score_histogram(
        self,
        stream_q_score_histogram_request: "StreamQScoreHistogramRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamQScoreHistogramResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_q_score_histogram",
            stream_q_score_histogram_request,
            StreamQScoreHistogramResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_q_accuracy_histogram(
        self,
        stream_q_accuracy_histogram_request: "StreamQAccuracyHistogramRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamQAccuracyHistogramResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_q_accuracy_histogram",
            stream_q_accuracy_histogram_request,
            StreamQAccuracyHistogramResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_basecall_boxplots(
        self,
        stream_boxplot_request: "StreamBoxplotRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[BoxplotResponse]:
        async for response in self._unary_stream(
            "/minknow_api.statistics.StatisticsService/stream_basecall_boxplots",
            stream_boxplot_request,
            BoxplotResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class StatisticsServiceBase(ServiceBase):

    async def stream_duty_time(
        self, stream_duty_time_request: "StreamDutyTimeRequest"
    ) -> AsyncIterator[StreamDutyTimeResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamDutyTimeResponse()

    async def stream_acquisition_output(
        self, stream_acquisition_output_request: "StreamAcquisitionOutputRequest"
    ) -> AsyncIterator[StreamAcquisitionOutputResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamAcquisitionOutputResponse()

    async def stream_writer_output(
        self, stream_writer_output_request: "StreamWriterOutputRequest"
    ) -> AsyncIterator[StreamWriterOutputResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamWriterOutputResponse()

    async def stream_encountered_acquisition_output_keys(
        self,
        stream_encountered_acquisition_output_keys_request: "StreamEncounteredAcquisitionOutputKeysRequest",
    ) -> AsyncIterator[StreamEncounteredAcquisitionOutputKeysResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamEncounteredAcquisitionOutputKeysResponse()

    async def stream_temperature(
        self, stream_temperature_request: "StreamTemperatureRequest"
    ) -> AsyncIterator[StreamTemperatureResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamTemperatureResponse()

    async def stream_bias_voltages(
        self, stream_bias_voltages_request: "StreamBiasVoltagesRequest"
    ) -> AsyncIterator[StreamBiasVoltagesResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamBiasVoltagesResponse()

    async def stream_read_length_histogram(
        self, stream_read_length_histogram_request: "StreamReadLengthHistogramRequest"
    ) -> AsyncIterator[StreamReadLengthHistogramResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamReadLengthHistogramResponse()

    async def read_length_n50(
        self, read_length_n50_request: "ReadLengthN50Request"
    ) -> "ReadLengthN50Response":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_read_length_types(
        self, get_read_length_types_request: "GetReadLengthTypesRequest"
    ) -> "GetReadLengthTypesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_q_score_histogram(
        self, stream_q_score_histogram_request: "StreamQScoreHistogramRequest"
    ) -> AsyncIterator[StreamQScoreHistogramResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamQScoreHistogramResponse()

    async def stream_q_accuracy_histogram(
        self, stream_q_accuracy_histogram_request: "StreamQAccuracyHistogramRequest"
    ) -> AsyncIterator[StreamQAccuracyHistogramResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamQAccuracyHistogramResponse()

    async def stream_basecall_boxplots(
        self, stream_boxplot_request: "StreamBoxplotRequest"
    ) -> AsyncIterator[BoxplotResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield BoxplotResponse()

    async def __rpc_stream_duty_time(
        self,
        stream: "grpclib.server.Stream[StreamDutyTimeRequest, StreamDutyTimeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_duty_time,
            stream,
            request,
        )

    async def __rpc_stream_acquisition_output(
        self,
        stream: "grpclib.server.Stream[StreamAcquisitionOutputRequest, StreamAcquisitionOutputResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_acquisition_output,
            stream,
            request,
        )

    async def __rpc_stream_writer_output(
        self,
        stream: "grpclib.server.Stream[StreamWriterOutputRequest, StreamWriterOutputResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_writer_output,
            stream,
            request,
        )

    async def __rpc_stream_encountered_acquisition_output_keys(
        self,
        stream: "grpclib.server.Stream[StreamEncounteredAcquisitionOutputKeysRequest, StreamEncounteredAcquisitionOutputKeysResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_encountered_acquisition_output_keys,
            stream,
            request,
        )

    async def __rpc_stream_temperature(
        self,
        stream: "grpclib.server.Stream[StreamTemperatureRequest, StreamTemperatureResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_temperature,
            stream,
            request,
        )

    async def __rpc_stream_bias_voltages(
        self,
        stream: "grpclib.server.Stream[StreamBiasVoltagesRequest, StreamBiasVoltagesResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_bias_voltages,
            stream,
            request,
        )

    async def __rpc_stream_read_length_histogram(
        self,
        stream: "grpclib.server.Stream[StreamReadLengthHistogramRequest, StreamReadLengthHistogramResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_read_length_histogram,
            stream,
            request,
        )

    async def __rpc_read_length_n50(
        self,
        stream: "grpclib.server.Stream[ReadLengthN50Request, ReadLengthN50Response]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.read_length_n50(request)
        await stream.send_message(response)

    async def __rpc_get_read_length_types(
        self,
        stream: "grpclib.server.Stream[GetReadLengthTypesRequest, GetReadLengthTypesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_read_length_types(request)
        await stream.send_message(response)

    async def __rpc_stream_q_score_histogram(
        self,
        stream: "grpclib.server.Stream[StreamQScoreHistogramRequest, StreamQScoreHistogramResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_q_score_histogram,
            stream,
            request,
        )

    async def __rpc_stream_q_accuracy_histogram(
        self,
        stream: "grpclib.server.Stream[StreamQAccuracyHistogramRequest, StreamQAccuracyHistogramResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_q_accuracy_histogram,
            stream,
            request,
        )

    async def __rpc_stream_basecall_boxplots(
        self, stream: "grpclib.server.Stream[StreamBoxplotRequest, BoxplotResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_basecall_boxplots,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.statistics.StatisticsService/stream_duty_time": grpclib.const.Handler(
                self.__rpc_stream_duty_time,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamDutyTimeRequest,
                StreamDutyTimeResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_acquisition_output": grpclib.const.Handler(
                self.__rpc_stream_acquisition_output,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamAcquisitionOutputRequest,
                StreamAcquisitionOutputResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_writer_output": grpclib.const.Handler(
                self.__rpc_stream_writer_output,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamWriterOutputRequest,
                StreamWriterOutputResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_encountered_acquisition_output_keys": grpclib.const.Handler(
                self.__rpc_stream_encountered_acquisition_output_keys,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamEncounteredAcquisitionOutputKeysRequest,
                StreamEncounteredAcquisitionOutputKeysResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_temperature": grpclib.const.Handler(
                self.__rpc_stream_temperature,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamTemperatureRequest,
                StreamTemperatureResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_bias_voltages": grpclib.const.Handler(
                self.__rpc_stream_bias_voltages,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamBiasVoltagesRequest,
                StreamBiasVoltagesResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_read_length_histogram": grpclib.const.Handler(
                self.__rpc_stream_read_length_histogram,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamReadLengthHistogramRequest,
                StreamReadLengthHistogramResponse,
            ),
            "/minknow_api.statistics.StatisticsService/read_length_n50": grpclib.const.Handler(
                self.__rpc_read_length_n50,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReadLengthN50Request,
                ReadLengthN50Response,
            ),
            "/minknow_api.statistics.StatisticsService/get_read_length_types": grpclib.const.Handler(
                self.__rpc_get_read_length_types,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetReadLengthTypesRequest,
                GetReadLengthTypesResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_q_score_histogram": grpclib.const.Handler(
                self.__rpc_stream_q_score_histogram,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamQScoreHistogramRequest,
                StreamQScoreHistogramResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_q_accuracy_histogram": grpclib.const.Handler(
                self.__rpc_stream_q_accuracy_histogram,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamQAccuracyHistogramRequest,
                StreamQAccuracyHistogramResponse,
            ),
            "/minknow_api.statistics.StatisticsService/stream_basecall_boxplots": grpclib.const.Handler(
                self.__rpc_stream_basecall_boxplots,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamBoxplotRequest,
                BoxplotResponse,
            ),
        }
