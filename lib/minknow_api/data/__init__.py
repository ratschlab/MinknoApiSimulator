# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/data.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import timedelta
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    device as _device__,
    statistics as _statistics__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class GetDataTypesResponseDataTypeType(betterproto.Enum):
    SIGNED_INTEGER = 0
    UNSIGNED_INTEGER = 1
    FLOATING_POINT = 2


class GetLiveReadsRequestRawDataType(betterproto.Enum):
    KEEP_LAST = 0
    """
    Don't change the previously specified setting for raw data sent with live reads
     note: If sent when there is no last setting, NONE is assumed.
    """

    NONE = 1
    """No raw data required for live reads"""

    CALIBRATED = 2
    """Calibrated raw data should be sent to the user with each read"""

    UNCALIBRATED = 3
    """Uncalibrated data should be sent to the user with each read"""


class GetLiveReadsResponseActionResponseResponse(betterproto.Enum):
    SUCCESS = 0
    FAILED_READ_FINISHED = 1
    FAILED_READ_TOO_LONG = 2


class RecordAdaptiveSamplingInformationRequestObjective(betterproto.Enum):
    OTHER = 0
    BARCODE_BALANCE = 1
    ENRICH = 2
    DEPLETE = 3


class GetReadStatisticsRequestReadSplit(betterproto.Enum):
    """
    Whether to aggregate statistics on a read chunk or complete read basis.

     This will affect both durations (which will be the durations of read chunks or complete reads)
     and classification aggregation (which will be based on the read chunk classification or the
     complete read classification).
    """

    CHUNK = 0
    COMPLETED_READ = 1


@dataclass(eq=False, repr=False)
class GetChannelStatesRequest(betterproto.Message):
    first_channel: int = betterproto.uint32_field(1)
    """
    The first channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    last_channel: int = betterproto.uint32_field(2)
    """
    The last channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    use_channel_states_ids: Optional[bool] = betterproto.message_field(
        3, wraps=betterproto.TYPE_BOOL
    )
    """
    If this is true, the returned messages will contain the
     channel state id as opposed to the name. By default,
     the response will contain channel states names.
    """

    wait_for_processing: bool = betterproto.bool_field(4)
    """
    If `wait_for_processing` is true, then get_channel_states will wait until minknow starts
     acquiring data instead of returning with an error
    
     Defaults to false
    """

    heartbeat: timedelta = betterproto.message_field(5)
    """
    Ensure the stream sends a message at least this often.
    
     There will usually be multiple channel updates a second, but in some circumstances (eg: a
     flow cell with no sample loaded) there can be long periods of time without updates.
    
     Setting this value will ensure that if this period of time passes without there being any
     channel state changes to report, an empty message will be sent. This can be useful to force a
     minimum wakeup interval in the client code.
    """


@dataclass(eq=False, repr=False)
class GetChannelStatesResponse(betterproto.Message):
    channel_states: List["GetChannelStatesResponseChannelStateData"] = (
        betterproto.message_field(1)
    )
    """
    The streamed data for all channels will be appended to this vector.
     After the request is made, all the channel state changes are streamed through
     this array. This is implemented in the idea of a sparse array because we can have
     channels that remain in the same state for a long time.
    """


@dataclass(eq=False, repr=False)
class GetChannelStatesResponseChannelStateData(betterproto.Message):
    channel: int = betterproto.uint32_field(1)
    """
    Represents the channel number, indexed from one. (i.e. what channel did the
     channel state change happened on)
    """

    state_id: int = betterproto.uint32_field(2, group="state")
    state_name: str = betterproto.string_field(3, group="state")
    acquisition_raw_index: int = betterproto.uint64_field(4)
    """
    Indices of when the channel state was first seen.
     For example, if a request is done half way through the experiment,
     the first message will contain the current state on the requested
     channels. The acquisition/analysis index of these would be from
     when the channel states were set. These are exactly the same numbers
     we see in the bulk file, in the 'states' table
    """

    analysis_raw_index: int = betterproto.uint64_field(5)
    trigger_time: int = betterproto.uint64_field(7)
    config: "_device__.ReturnedChannelConfiguration" = betterproto.message_field(6)
    """Channel config (mux state) the channel state was determined on."""


@dataclass(eq=False, repr=False)
class GetDataTypesRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetDataTypesResponse(betterproto.Message):
    uncalibrated_signal: "GetDataTypesResponseDataType" = betterproto.message_field(1)
    """
    The format of the uncalibrated (ADC) signal data returned by get_raw_signal_bytes().
    
     In the current release, this will describe 16-bit little-endian integers.
    """

    calibrated_signal: "GetDataTypesResponseDataType" = betterproto.message_field(2)
    """
    The format of the calibrated (picoamp) signal data returned by get_raw_signal_bytes().
    
     In the current release, this will describe 32-bit IEEE 754 floating point values.
    """

    bias_voltages: "GetDataTypesResponseDataType" = betterproto.message_field(3)
    """
    The format of the bias voltage data returned by get_raw_signal_bytes().
    
     In the current release, this will describe 16-bit little-endian integers.
    """


@dataclass(eq=False, repr=False)
class GetDataTypesResponseDataType(betterproto.Message):
    type: "GetDataTypesResponseDataTypeType" = betterproto.enum_field(1)
    """The basic type of the data item."""

    big_endian: bool = betterproto.bool_field(2)
    """
    Whether the type is big-endian (high-byte first).
    
     For numeric data types, if this is not set, they are little-endian (low-byte first).
    """

    size: int = betterproto.uint32_field(3)
    """The size of the data type in bytes."""


@dataclass(eq=False, repr=False)
class GetSignalBytesRequest(betterproto.Message):
    seconds: float = betterproto.float_field(1, group="length")
    """
    The amount of data to return in seconds.
    
     The number of samples returned will be just enough to cover this period of time. Cannot
     be specified at the same time as ``samples``.
    """

    samples: int = betterproto.uint32_field(2, group="length")
    """
    The amount of data to return in samples.
    
     The result will contain exactly this many samples. If this is not possible, the call will
     fail. Cannot be specified at the same time as ``seconds``.
    """

    first_channel: int = betterproto.uint32_field(3)
    """
    The first channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    last_channel: int = betterproto.uint32_field(4)
    """
    The last channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    include_channel_configs: bool = betterproto.bool_field(5)
    """Whether to include channel configuration settings."""

    include_bias_voltages: bool = betterproto.bool_field(6)
    """Whether to include bias voltage information."""

    calibrated_data: bool = betterproto.bool_field(7)
    """Whether the data should be calibrated."""

    return_when_listening: bool = betterproto.bool_field(8)
    """
    When this value is set to true, then an empty message will be sent back
     to the client to indicate that the backend has acknowledged the request,
     and that any calls made that will affect the signal after that initial
     response will be reflected in the next messages
    """


@dataclass(eq=False, repr=False)
class GetSignalBytesResponse(betterproto.Message):
    samples_since_start: int = betterproto.uint64_field(1)
    """
    The number of samples collected before the first sample included in this response.
    
     This gives the position of the first data point on each channel in the overall stream of data
     being acquired from the device (since this period of data acquisition was started).
    """

    seconds_since_start: float = betterproto.double_field(2)
    """
    The number of seconds elapsed since data acquisition started.
    
     This is the same as ``samples_since_start``, but expressed in seconds.
    """

    skipped_channels: int = betterproto.uint32_field(3)
    """
    The number of channels omitted at the start of the ``channels`` array.
    """

    channels: List["GetSignalBytesResponseChannelData"] = betterproto.message_field(4)
    """
    The signal for each requested channel.
    
     Note that ``skipped_channels`` must be used to determine which channels are given here, as
     not all channels will be included in every message. The channels that are provided are
     contiguous and in order, with the first channel being ``first_channel + skipped_channels``
     (where ``first_channel`` is from the request message).
    """

    bias_voltages: bytes = betterproto.bytes_field(5)
    """
    The bias voltages set for each sample.
    
     If bias voltages were requested, this will provide voltage data, one voltage per sample. Note
     that not every message may include bias_voltages (they will generally be included when
     ``skipped_channels`` is 0, but that is not guaranteed).
    
     The get_data_types() RPC call should be used to determine the format of the data.
    """


@dataclass(eq=False, repr=False)
class GetSignalBytesResponseChannelConfigChange(betterproto.Message):
    config: "_device__.ReturnedChannelConfiguration" = betterproto.message_field(1)
    """The new channel configuration."""

    offset: int = betterproto.uint64_field(2)
    """The offset in the returned data where the change was applied."""


@dataclass(eq=False, repr=False)
class GetSignalBytesResponseChannelData(betterproto.Message):
    data: bytes = betterproto.bytes_field(1)
    """
    The signal data.
    
     This is the byte representation of a C-style array of values. Values are stored in order
     and adjacent to each other.
    
     The type of the elements will depend on whether calibrated data was chosen. The
     get_data_types() RPC call should be used to determine the precise format of the data, but
     in general terms, uncalibrated data will be signed integers and calibrated data will be
     floating-point numbers.
    
     Returning the data in this format allows it to be efficiently processed in dynamic
     languages that can pass the data straight down to a native runtime. For example, in
     Python, this data can be interpreted directly into a numpy array using numpy.fromstring().
    
     Calibrated data is in picoamps. Uncalibrated data is the raw values output by the
     device's ADC (analogue-digital converter).
    """

    config_changes: List["GetSignalBytesResponseChannelConfigChange"] = (
        betterproto.message_field(3)
    )
    """
    The configuration changes on the channel during data collection.
    
     If channel configuration changes were requested, this will contain all the channel
     configuration changes that affect the returned data. This will include at least one
     element, with offset 0, that describes the configuration at the time the first sample was
     taken.
    
     Note that the offset is the zero-based index into the adc or picoamps list.
    
     The changes will be ordered by offset.
    """


@dataclass(eq=False, repr=False)
class GetSignalMinMaxRequest(betterproto.Message):
    first_channel: int = betterproto.uint32_field(3)
    """
    The first channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    last_channel: int = betterproto.uint32_field(4)
    """
    The last channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    window_size: int = betterproto.uint32_field(5)
    """
    The size of window to summarise.
    
     A value of zero will be rejected; there is no default.
    """

    calibrated_data: bool = betterproto.bool_field(7)
    """Whether the data should be calibrated."""


@dataclass(eq=False, repr=False)
class GetSignalMinMaxResponse(betterproto.Message):
    samples_since_start: int = betterproto.uint64_field(1)
    """
    The number of samples collected before the first sample included in this response.
    
     This gives the position of the first data point on each channel in the overall stream of data
     being acquired from the device (since this period of data acquisition was started).
    """

    seconds_since_start: float = betterproto.double_field(2)
    """
    The number of seconds elapsed since data acquisition started.
    
     This is the same as ``samples_since_start``, but expressed in seconds.
    """

    skipped_channels: int = betterproto.uint32_field(3)
    """
    The number of channels omitted at the start of the ``channels`` array.
    """

    channels: List["GetSignalMinMaxResponseChannelData"] = betterproto.message_field(4)
    """
    The window bounds for each requested channel.
    
     Note that ``skipped_channels`` must be used to determine which channels are given here, as
     not all channels will be included in every message. The channels that are provided are
     contiguous and in order, with the first channel being ``first_channel + skipped_channels``
     (where ``first_channel`` is from the request message).
    """


@dataclass(eq=False, repr=False)
class GetSignalMinMaxResponseChannelData(betterproto.Message):
    calibrated_minima: List[float] = betterproto.float_field(1)
    """
    The minimum value for each window.
    
     The type of the elements will depend on whether calibrated data was chosen.
     Uncalibrated data will be signed integers and calibrated data will be
     floating-point numbers.
    
     It would be nice to use the "oneof" enum-like type to
     capture this, but you can't have repeated members in a oneof, and nor can
     you have a repeated oneof field.  We can simply include message fields for both
     types of data, as all fields are optional in proto3.  We will rely on the
     code that constructs this message to guarantee that we don't try and put both
     types of data into the same message.
    
     Calibrated data is in picoamps. Uncalibrated data is the raw values output by the
     device's ADC (analogue-digital converter).
    
     This is guaranteed to be the same size as the respective foo_maxima field.
    """

    raw_minima: List[int] = betterproto.int32_field(2)
    calibrated_maxima: List[float] = betterproto.float_field(3)
    """
    The maximum value for each window.
    
     See comments for the "minima" fields above for details of calibrated and
     uncalibrated data.
    
     This is guaranteed to be the same size as the respective foo_minima field.
    """

    raw_maxima: List[int] = betterproto.int32_field(4)


@dataclass(eq=False, repr=False)
class GetLiveReadsRequest(betterproto.Message):
    setup: "GetLiveReadsRequestStreamSetup" = betterproto.message_field(
        1, group="request"
    )
    """
    Read setup request, initialises channel numbers and type of data returned.
    
     note: Must be specified in the first message sent to MinKNOW. Once MinKNOW
     has the first setup message reads are sent to the caller as requested.
     The user can then resend a setup message as frequently as they need to in order
     to reconfigure live reads - for example by changing if raw data is sent with
     reads or not.
    """

    actions: "GetLiveReadsRequestActions" = betterproto.message_field(
        2, group="request"
    )
    """
    Actions to take given data returned to the user - can only be sent once the setup
     message above has been sent.
    """


@dataclass(eq=False, repr=False)
class GetLiveReadsRequestUnblockAction(betterproto.Message):
    duration: float = betterproto.double_field(1)
    """Duration of unblock in seconds."""


@dataclass(eq=False, repr=False)
class GetLiveReadsRequestStopFurtherData(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetLiveReadsRequestAction(betterproto.Message):
    action_id: str = betterproto.string_field(1)
    channel: int = betterproto.uint32_field(2)
    """Channel name to unblock"""

    id: str = betterproto.string_field(3, group="read")
    unblock: "GetLiveReadsRequestUnblockAction" = betterproto.message_field(
        5, group="action"
    )
    """Unblock a read and skip further data from this read."""

    stop_further_data: "GetLiveReadsRequestStopFurtherData" = betterproto.message_field(
        6, group="action"
    )
    """Skip further data from this read, doesn't affect the read data."""


@dataclass(eq=False, repr=False)
class GetLiveReadsRequestStreamSetup(betterproto.Message):
    first_channel: int = betterproto.uint32_field(1)
    """
    The first channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    last_channel: int = betterproto.uint32_field(2)
    """
    The last channel (inclusive) to return data for.
    
     Note that channel numbering starts at 1.
    """

    raw_data_type: "GetLiveReadsRequestRawDataType" = betterproto.enum_field(3)
    """Specify the type of raw data to retrieve"""

    sample_minimum_chunk_size: int = betterproto.uint64_field(4)
    """Minimum chunk size read data is returned in."""

    max_unblock_read_length_samples: int = betterproto.uint64_field(
        5, group="max_unblock_read_length"
    )
    """
    Maximum read length MinKNOW will attempt to unblock (in samples).
    
     A value of 0 will cause minknow to unblock reads of any length.
    """

    max_unblock_read_length_seconds: float = betterproto.double_field(
        6, group="max_unblock_read_length"
    )
    """
    Maximum read length MinKNOW will attempt to unblock (in seconds).
    
     A value of 0.0 will cause minknow to unblock reads of any length.
    """

    accepted_first_chunk_classifications: List[int] = betterproto.int32_field(7)
    """
    A set of classification identifiers which the client is interested in.
     If a read starts with a classification not listed here the read is never sent to the client.
    """


@dataclass(eq=False, repr=False)
class GetLiveReadsRequestActions(betterproto.Message):
    actions: List["GetLiveReadsRequestAction"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class GetLiveReadsResponse(betterproto.Message):
    """
    NOTE that the read metrics below are tracked from the receipt of the first StreamSetup message.
     It is advised that the first StreamSetup be sent close to the experiment start time for
     maximum accuracy.
    """

    samples_since_start: int = betterproto.uint64_field(1)
    """
    The number of samples collected before the first sample included in this response.
    
     This gives the position of the first data point on each channel in the overall stream of data
     being acquired from the device (since this period of data acquisition was started).
    """

    seconds_since_start: float = betterproto.double_field(2)
    """
    The number of seconds elapsed since data acquisition started.
    
     This is the same as ``samples_since_start``, but expressed in seconds.
    """

    channels: Dict[int, "GetLiveReadsResponseReadData"] = betterproto.map_field(
        4, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    """
    In progress reads for the requested channels.
    
     Sparsely populated as not all channels have new/incomplete reads.
    """

    action_responses: List["GetLiveReadsResponseActionResponse"] = (
        betterproto.message_field(5)
    )
    """
    List of responses to requested actions, informing the caller of results to requested
     unblocks or discards of data.
    """


@dataclass(eq=False, repr=False)
class GetLiveReadsResponseReadData(betterproto.Message):
    id: str = betterproto.string_field(1)
    """The id of this read, this id is unique for every read ever produced."""

    start_sample: int = betterproto.uint64_field(3)
    """Absolute start point of this read"""

    chunk_start_sample: int = betterproto.uint64_field(4)
    """Absolute start point through the experiment of this chunk"""

    chunk_length: int = betterproto.uint64_field(5)
    """Length of the chunk in samples"""

    chunk_classifications: List[int] = betterproto.int32_field(6)
    """
    All Classifications given to intermediate chunks by analysis
    
     See analysis_configuration.get_read_classifications for how to map these integers to names.
    """

    raw_data: bytes = betterproto.bytes_field(7)
    """
    Any raw data selected by the request
    
     The type of the elements will depend on whether calibrated data was chosen. The
     get_data_types() RPC call should be used to determine the precise format of the data, but
     in general terms, uncalibrated data will be signed integers and calibrated data will be
     floating-point numbers.
    """

    median_before: float = betterproto.float_field(8)
    """
    The median of the read previous to this read.
     intended to allow querying of the approximate level of this read, compared to the last.
    
     For example, a user could try to verify this is a strand be ensuring the median of the
     current read is lower than the median_before level.
    """

    median: float = betterproto.float_field(9)
    """
    The media pA level of this read from all aggregated read chunks so far.
    """

    previous_read_classification: int = betterproto.int32_field(10)
    """The classification of the chunk prior to this read starting."""

    previous_read_end_reason: "_statistics__.ReadEndReason" = betterproto.enum_field(11)
    """The classification of the chunk prior to this read starting."""


@dataclass(eq=False, repr=False)
class GetLiveReadsResponseActionResponse(betterproto.Message):
    action_id: str = betterproto.string_field(1)
    response: "GetLiveReadsResponseActionResponseResponse" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class ResetChannelStatesRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ResetChannelStatesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RecordAdaptiveSamplingInformationRequest(betterproto.Message):
    objective: "RecordAdaptiveSamplingInformationRequestObjective" = (
        betterproto.enum_field(1, group="information")
    )
    """
    The reason for applying the adaptive sampling technique. This must be recorded during
     the acquisition period in which adaptive sampling is applied.
    """

    end_reason: str = betterproto.string_field(2, group="information")
    """
    The reason why the adaptive sampling script ended. This string will be truncated to
     80 characters.
    """


@dataclass(eq=False, repr=False)
class RecordAdaptiveSamplingInformationResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetReadStatisticsRequest(betterproto.Message):
    channels: List[int] = betterproto.uint32_field(1)
    """List of channels required, indexed from 1."""

    seconds: float = betterproto.float_field(2, group="duration")
    samples: int = betterproto.uint64_field(3, group="duration")
    read_split: "GetReadStatisticsRequestReadSplit" = betterproto.enum_field(4)
    no_current_statistics: bool = betterproto.bool_field(5)
    """
    Disable current_statistics results in returned data.
    
     Intended for use when the consumer doesn't need specific fields
     allowing the implementation to be more efficient.
    """

    no_chunk_statistics: bool = betterproto.bool_field(6)
    """
    Disable chunk_statistics results in returned data.
    
     Intended for use when the consumer doesn't need specific fields
     allowing the implementation to be more efficient.
    """

    required_classifications: List[str] = betterproto.string_field(7)
    """
    Specify classifications which the user wants information about.
    
     The default behaviour (when empty) is to return information on all classifications.
    
     Specifying which classifications the user needs information about may allow
     the implementation to be more efficient.
    """


@dataclass(eq=False, repr=False)
class GetReadStatisticsResponse(betterproto.Message):
    channels: List["GetReadStatisticsResponsePerChannelData"] = (
        betterproto.message_field(1)
    )
    """Data for each requested channel, in the same order as requested."""

    samples_since_start: int = betterproto.uint64_field(2)
    """
    The number of samples collected before the first sample included in this response.
    
     This gives the position of the first data point which all channels share in the calculated
     statistics. Each individual channel may have samples from read chunks previous to this sample
     due to read boundaries not being consistent across channels.
    """

    seconds_since_start: float = betterproto.double_field(3)
    """
    The number of seconds elapsed before the first sample included in this response.
    
     This is the same as ``samples_since_start``, but expressed in seconds.
    """


@dataclass(eq=False, repr=False)
class GetReadStatisticsResponseStatistics(betterproto.Message):
    min: float = betterproto.double_field(1)
    max: float = betterproto.double_field(2)
    mean: float = betterproto.double_field(3)
    s_d: float = betterproto.double_field(4)
    median: float = betterproto.double_field(6)
    q_5: float = betterproto.double_field(7)
    q_10: float = betterproto.double_field(8)
    q_25: float = betterproto.double_field(9)
    q_75: float = betterproto.double_field(10)
    q_90: float = betterproto.double_field(11)
    q_95: float = betterproto.double_field(12)


@dataclass(eq=False, repr=False)
class GetReadStatisticsResponseChunkStatistics(betterproto.Message):
    median_sd: float = betterproto.double_field(1)
    """
    Aggregated median_sd value from all classified reads.
     Computed as median(median_sd[...])
    """

    median: float = betterproto.double_field(2)
    """
    Aggregated median_sd value from all classified reads.
    
     Computed as median(median[...])
    """

    range: float = betterproto.double_field(3)
    """
    Aggregated range value from all classified reads.
    
     Computed as median(q90[...] - q10[...])
    """


@dataclass(eq=False, repr=False)
class GetReadStatisticsResponsePerClassificationData(betterproto.Message):
    duration_statistics: "GetReadStatisticsResponseStatistics" = (
        betterproto.message_field(1)
    )
    """
    Statistics of read (chunk) durations. These will be in the same units as the requested
     duration (if you ask for X seconds of data, you will get durations back in seconds, but if
     you ask for X samples of data, you will get durations back in samples).
    
     NB: statistics may be estimates.
    """

    current_statistics: "GetReadStatisticsResponseStatistics" = (
        betterproto.message_field(2)
    )
    """
    Statistics for all current (signal) values for all reads under this
     channel/configuration/classification combination.
    
     NB: Statistics are calculated from raw data.
    """

    chunk_statistics: "GetReadStatisticsResponseChunkStatistics" = (
        betterproto.message_field(6)
    )
    """
    Statistics generated from the analysed read chunks (or complete reads), rather
     than the raw signal.
    """

    samples_duration: int = betterproto.uint64_field(4)
    """
    The number of samples seen with this classification on this channel in this channel
     configuration.
    """

    seconds_duration: float = betterproto.double_field(5)
    """
    The number of seconds spent in this classification on this channel in this channel
     configuration.
    
     This is the same as ``samples_duration``, but expressed in seconds.
    """


@dataclass(eq=False, repr=False)
class GetReadStatisticsResponsePerConfigurationData(betterproto.Message):
    channel_configuration: "_device__.ReturnedChannelConfiguration" = (
        betterproto.message_field(1)
    )
    """
    The channel configuration active during the reads these statistics were gathered for.
    """

    classifications: Dict[str, "GetReadStatisticsResponsePerClassificationData"] = (
        betterproto.map_field(2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    """
    Map from classification names to statistics about read (chunks) with that classification.
    """

    incomplete: "GetReadStatisticsResponsePerClassificationData" = (
        betterproto.message_field(3)
    )
    """
    If statistics about complete reads were requested, this field may contain data for a final,
     incomplete read (whose classification is therefore unknown).
    
     This field will not be set if read chunks were requested, or if the data capture happened to
     end at a complete read boundary.
    """


@dataclass(eq=False, repr=False)
class GetReadStatisticsResponsePerChannelData(betterproto.Message):
    configurations: List["GetReadStatisticsResponsePerConfigurationData"] = (
        betterproto.message_field(6)
    )
    """
    Data for each channel configuration seen on this channel.
    
     Note that each channel configuration will only appear once in this list, and this list is
     *not* in any way ordered by time. The only reason it is not a map is because of restrictions
     on map key types.
    """

    samples_since_start: int = betterproto.uint64_field(2)
    """The number of samples collected before this channel's first sample."""

    seconds_since_start: float = betterproto.double_field(3)
    """
    The number of seconds elapsed since data acquisition started.
    
     This is the same as ``samples_since_start``, but expressed in seconds.
    """

    samples_duration: int = betterproto.uint64_field(4)
    """The number of samples collected for this channel."""

    seconds_duration: float = betterproto.double_field(5)
    """
    The number of seconds of data captured for this session.
    
     This is the same as ``samples_duration``, but expressed in seconds.
    """


@dataclass(eq=False, repr=False)
class LockChannelStatesRequest(betterproto.Message):
    channels: List[int] = betterproto.uint64_field(1)
    """
    The channels that we want to 'deactivate' = set them to the given state until we re-activate them
     with unlock_channel_states
     If the channels are already deactivated, it will update the state to the new forced state given (if different).
     Channels are indexed from 1.
    """

    state_name: str = betterproto.string_field(2)
    """
    Channel state name as specified in the channel state configuration.
     It HAS to be different to 'unclassified', which denotes that the channel is active, but had not met
     any successful criteria yet.
    """


@dataclass(eq=False, repr=False)
class LockChannelStatesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class UnlockChannelStatesRequest(betterproto.Message):
    channels: List[int] = betterproto.uint64_field(1)
    """
    The channels to activate (active = they will be considered for channel state evaluation in the future).
     Channels are indexed from 1.
    """


@dataclass(eq=False, repr=False)
class UnlockChannelStatesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponse(betterproto.Message):
    complete_read_info: "GetExperimentYieldInfoResponseCompleteReadInfo" = (
        betterproto.message_field(1)
    )
    acquisition_info: "GetExperimentYieldInfoResponseAcquisitionInfo" = (
        betterproto.message_field(2)
    )
    analyser_info: "GetExperimentYieldInfoResponseAnalyserInfo" = (
        betterproto.message_field(3)
    )
    bulk_info: "GetExperimentYieldInfoResponseBulkInfo" = betterproto.message_field(4)
    hdf_writer_info: "GetExperimentYieldInfoResponseHdfWriterInfo" = (
        betterproto.message_field(5)
    )
    basecaller_statistics: "GetExperimentYieldInfoResponseBasecallStatistics" = (
        betterproto.message_field(6)
    )
    hdf_multi_read_writing_statisitics: (
        "GetExperimentYieldInfoResponseHdfMultiReadWritingStatistics"
    ) = betterproto.message_field(7)
    fastq_read_writing_statistics: (
        "GetExperimentYieldInfoResponseFastqReadWritingStatistics"
    ) = betterproto.message_field(8)
    protobuf_read_writing_statistics: (
        "GetExperimentYieldInfoResponseProtobufReadWritingStatistics"
    ) = betterproto.message_field(9)
    file_operation_queue_progress: (
        "GetExperimentYieldInfoResponseFileOperationQueueProgress"
    ) = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseCompleteReadInfo(betterproto.Message):
    pending_chunks: int = betterproto.uint64_field(1)
    pending_memory_reads: int = betterproto.uint64_field(2)
    pending_disk_reads: int = betterproto.uint64_field(15)
    pending_multi_disk_reads: int = betterproto.uint64_field(3)
    pending_skipped_reads: int = betterproto.uint64_field(4)
    pending_force_skipped_reads: int = betterproto.uint64_field(5)
    processed_memory_reads: int = betterproto.uint64_field(6)
    processed_disk_reads: int = betterproto.uint64_field(7)
    processed_skipped_reads: int = betterproto.uint64_field(8)
    processed_force_skipped_reads: int = betterproto.uint64_field(9)
    stored_reads_bytes_memory: int = betterproto.uint64_field(10)
    stored_read_supporting_bytes_memory: int = betterproto.uint64_field(16)
    stored_reads_bytes_disk: int = betterproto.uint64_field(11)
    discarded_error_bytes: int = betterproto.uint64_field(12)
    channels_writing_to_disk: int = betterproto.uint64_field(13)
    channels_writing_to_disk_tmp: int = betterproto.uint64_field(14)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseAcquisitionInfo(betterproto.Message):
    raw_per_channel: int = betterproto.uint64_field(1)
    frame_discontinuities: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseAnalyserInfo(betterproto.Message):
    raw_per_channel: int = betterproto.uint64_field(1)
    total_selected_raw: int = betterproto.uint64_field(2)
    total_selected_events: int = betterproto.uint64_field(3)
    total_events: int = betterproto.uint64_field(4)
    total_read_chunks: int = betterproto.uint64_field(5)
    completed_selected_reads_count: int = betterproto.uint64_field(6)
    completed_unselected_reads_count: int = betterproto.uint64_field(7)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseBulkInfo(betterproto.Message):
    total_raw: int = betterproto.uint64_field(1)
    total_events: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseHdfWriterInfo(betterproto.Message):
    pending_compressions: int = betterproto.uint64_field(1)
    pending_writes: int = betterproto.uint64_field(2)
    pending_hdf_tasks: int = betterproto.uint64_field(3)
    completed_writes: int = betterproto.uint64_field(4)
    dataset_bytes_data_in_flight: int = betterproto.uint64_field(5)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseBasecallStatistics(betterproto.Message):
    reads_in_progress: int = betterproto.uint64_field(1)
    reads_processed: int = betterproto.uint64_field(2)
    reads_skipped: int = betterproto.uint64_field(3)
    reads_force_skipped: int = betterproto.uint64_field(4)
    reads_failed_calling_filtered: int = betterproto.uint64_field(5)
    reads_failed_calling: int = betterproto.uint64_field(6)
    reads_called: int = betterproto.uint64_field(7)
    samples_called: int = betterproto.uint64_field(8)
    samples_skipped: int = betterproto.uint64_field(9)
    bases_passed_called: int = betterproto.uint64_field(10)
    bases_failed_called: int = betterproto.uint64_field(12)
    events_called: int = betterproto.uint64_field(11)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseHdfMultiReadWritingStatistics(betterproto.Message):
    reads_written: int = betterproto.uint64_field(1)
    passed_reads_written: int = betterproto.uint64_field(2)
    failed_reads_written: int = betterproto.uint64_field(3)
    force_skipped_reads_written: int = betterproto.uint64_field(4)
    raw_bytes_written: int = betterproto.uint64_field(5)
    fastq_bytes_written: int = betterproto.uint64_field(6)
    basecall_events_bytes_written: int = betterproto.uint64_field(7)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseFastqReadWritingStatistics(betterproto.Message):
    passed_reads_written: int = betterproto.uint64_field(1)
    skipped_reads: int = betterproto.uint64_field(2)
    forced_skipped: int = betterproto.uint64_field(3)
    failed_reads_written: int = betterproto.uint64_field(4)
    failed_reads_discarded: int = betterproto.uint64_field(5)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseProtobufReadWritingStatistics(betterproto.Message):
    read_chunks_written: int = betterproto.uint64_field(1)
    read_chunks_discarded: int = betterproto.uint64_field(2)
    reads_written: int = betterproto.uint64_field(3)
    reads_discarded: int = betterproto.uint64_field(4)


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseFileOperationQueueProgress(betterproto.Message):
    pending_operations: int = betterproto.uint64_field(1)
    complete_successful_operations: int = betterproto.uint64_field(2)
    complete_failed_operations: int = betterproto.uint64_field(3)
    bytes_to_move_posted: int = betterproto.uint64_field(4)
    bytes_to_move_failed: int = betterproto.uint64_field(5)
    bytes_to_move_completed: int = betterproto.uint64_field(6)
    fast5: "GetExperimentYieldInfoResponseFileOperationQueueProgressFileTypeInfo" = (
        betterproto.message_field(7)
    )
    fastq: "GetExperimentYieldInfoResponseFileOperationQueueProgressFileTypeInfo" = (
        betterproto.message_field(8)
    )


@dataclass(eq=False, repr=False)
class GetExperimentYieldInfoResponseFileOperationQueueProgressFileTypeInfo(
    betterproto.Message
):
    files_moved_successfully: int = betterproto.uint64_field(1)
    files_moved_to_fallback: int = betterproto.uint64_field(2)
    files_failed_to_move: int = betterproto.uint64_field(3)


class DataServiceStub(betterproto.ServiceStub):
    async def get_channel_states(
        self,
        get_channel_states_request: "GetChannelStatesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetChannelStatesResponse]:
        async for response in self._unary_stream(
            "/minknow_api.data.DataService/get_channel_states",
            get_channel_states_request,
            GetChannelStatesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_data_types(
        self,
        get_data_types_request: "GetDataTypesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDataTypesResponse":
        return await self._unary_unary(
            "/minknow_api.data.DataService/get_data_types",
            get_data_types_request,
            GetDataTypesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_signal_bytes(
        self,
        get_signal_bytes_request: "GetSignalBytesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetSignalBytesResponse]:
        async for response in self._unary_stream(
            "/minknow_api.data.DataService/get_signal_bytes",
            get_signal_bytes_request,
            GetSignalBytesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_signal_min_max(
        self,
        get_signal_min_max_request: "GetSignalMinMaxRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetSignalMinMaxResponse]:
        async for response in self._unary_stream(
            "/minknow_api.data.DataService/get_signal_min_max",
            get_signal_min_max_request,
            GetSignalMinMaxResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def reset_channel_states(
        self,
        reset_channel_states_request: "ResetChannelStatesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ResetChannelStatesResponse":
        return await self._unary_unary(
            "/minknow_api.data.DataService/reset_channel_states",
            reset_channel_states_request,
            ResetChannelStatesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def lock_channel_states(
        self,
        lock_channel_states_request: "LockChannelStatesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "LockChannelStatesResponse":
        return await self._unary_unary(
            "/minknow_api.data.DataService/lock_channel_states",
            lock_channel_states_request,
            LockChannelStatesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def unlock_channel_states(
        self,
        unlock_channel_states_request: "UnlockChannelStatesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UnlockChannelStatesResponse":
        return await self._unary_unary(
            "/minknow_api.data.DataService/unlock_channel_states",
            unlock_channel_states_request,
            UnlockChannelStatesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_live_reads(
        self,
        get_live_reads_request_iterator: Union[
            AsyncIterable[GetLiveReadsRequest], Iterable[GetLiveReadsRequest]
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[GetLiveReadsResponse]:
        async for response in self._stream_stream(
            "/minknow_api.data.DataService/get_live_reads",
            get_live_reads_request_iterator,
            GetLiveReadsRequest,
            GetLiveReadsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def record_adaptive_sampling_information(
        self,
        record_adaptive_sampling_information_request: "RecordAdaptiveSamplingInformationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RecordAdaptiveSamplingInformationResponse":
        return await self._unary_unary(
            "/minknow_api.data.DataService/record_adaptive_sampling_information",
            record_adaptive_sampling_information_request,
            RecordAdaptiveSamplingInformationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_read_statistics(
        self,
        get_read_statistics_request: "GetReadStatisticsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetReadStatisticsResponse":
        return await self._unary_unary(
            "/minknow_api.data.DataService/get_read_statistics",
            get_read_statistics_request,
            GetReadStatisticsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_experiment_yield_info(
        self,
        get_experiment_yield_info_request: "GetExperimentYieldInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetExperimentYieldInfoResponse":
        return await self._unary_unary(
            "/minknow_api.data.DataService/get_experiment_yield_info",
            get_experiment_yield_info_request,
            GetExperimentYieldInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class DataServiceBase(ServiceBase):

    async def get_channel_states(
        self, get_channel_states_request: "GetChannelStatesRequest"
    ) -> AsyncIterator[GetChannelStatesResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetChannelStatesResponse()

    async def get_data_types(
        self, get_data_types_request: "GetDataTypesRequest"
    ) -> "GetDataTypesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_signal_bytes(
        self, get_signal_bytes_request: "GetSignalBytesRequest"
    ) -> AsyncIterator[GetSignalBytesResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetSignalBytesResponse()

    async def get_signal_min_max(
        self, get_signal_min_max_request: "GetSignalMinMaxRequest"
    ) -> AsyncIterator[GetSignalMinMaxResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetSignalMinMaxResponse()

    async def reset_channel_states(
        self, reset_channel_states_request: "ResetChannelStatesRequest"
    ) -> "ResetChannelStatesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def lock_channel_states(
        self, lock_channel_states_request: "LockChannelStatesRequest"
    ) -> "LockChannelStatesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def unlock_channel_states(
        self, unlock_channel_states_request: "UnlockChannelStatesRequest"
    ) -> "UnlockChannelStatesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_live_reads(
        self, get_live_reads_request_iterator: AsyncIterator[GetLiveReadsRequest]
    ) -> AsyncIterator[GetLiveReadsResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetLiveReadsResponse()

    async def record_adaptive_sampling_information(
        self,
        record_adaptive_sampling_information_request: "RecordAdaptiveSamplingInformationRequest",
    ) -> "RecordAdaptiveSamplingInformationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_read_statistics(
        self, get_read_statistics_request: "GetReadStatisticsRequest"
    ) -> "GetReadStatisticsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_experiment_yield_info(
        self, get_experiment_yield_info_request: "GetExperimentYieldInfoRequest"
    ) -> "GetExperimentYieldInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_channel_states(
        self,
        stream: "grpclib.server.Stream[GetChannelStatesRequest, GetChannelStatesResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_channel_states,
            stream,
            request,
        )

    async def __rpc_get_data_types(
        self, stream: "grpclib.server.Stream[GetDataTypesRequest, GetDataTypesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_data_types(request)
        await stream.send_message(response)

    async def __rpc_get_signal_bytes(
        self,
        stream: "grpclib.server.Stream[GetSignalBytesRequest, GetSignalBytesResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_signal_bytes,
            stream,
            request,
        )

    async def __rpc_get_signal_min_max(
        self,
        stream: "grpclib.server.Stream[GetSignalMinMaxRequest, GetSignalMinMaxResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_signal_min_max,
            stream,
            request,
        )

    async def __rpc_reset_channel_states(
        self,
        stream: "grpclib.server.Stream[ResetChannelStatesRequest, ResetChannelStatesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.reset_channel_states(request)
        await stream.send_message(response)

    async def __rpc_lock_channel_states(
        self,
        stream: "grpclib.server.Stream[LockChannelStatesRequest, LockChannelStatesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.lock_channel_states(request)
        await stream.send_message(response)

    async def __rpc_unlock_channel_states(
        self,
        stream: "grpclib.server.Stream[UnlockChannelStatesRequest, UnlockChannelStatesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.unlock_channel_states(request)
        await stream.send_message(response)

    async def __rpc_get_live_reads(
        self, stream: "grpclib.server.Stream[GetLiveReadsRequest, GetLiveReadsResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.get_live_reads,
            stream,
            request,
        )

    async def __rpc_record_adaptive_sampling_information(
        self,
        stream: "grpclib.server.Stream[RecordAdaptiveSamplingInformationRequest, RecordAdaptiveSamplingInformationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.record_adaptive_sampling_information(request)
        await stream.send_message(response)

    async def __rpc_get_read_statistics(
        self,
        stream: "grpclib.server.Stream[GetReadStatisticsRequest, GetReadStatisticsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_read_statistics(request)
        await stream.send_message(response)

    async def __rpc_get_experiment_yield_info(
        self,
        stream: "grpclib.server.Stream[GetExperimentYieldInfoRequest, GetExperimentYieldInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_experiment_yield_info(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.data.DataService/get_channel_states": grpclib.const.Handler(
                self.__rpc_get_channel_states,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetChannelStatesRequest,
                GetChannelStatesResponse,
            ),
            "/minknow_api.data.DataService/get_data_types": grpclib.const.Handler(
                self.__rpc_get_data_types,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDataTypesRequest,
                GetDataTypesResponse,
            ),
            "/minknow_api.data.DataService/get_signal_bytes": grpclib.const.Handler(
                self.__rpc_get_signal_bytes,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetSignalBytesRequest,
                GetSignalBytesResponse,
            ),
            "/minknow_api.data.DataService/get_signal_min_max": grpclib.const.Handler(
                self.__rpc_get_signal_min_max,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetSignalMinMaxRequest,
                GetSignalMinMaxResponse,
            ),
            "/minknow_api.data.DataService/reset_channel_states": grpclib.const.Handler(
                self.__rpc_reset_channel_states,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResetChannelStatesRequest,
                ResetChannelStatesResponse,
            ),
            "/minknow_api.data.DataService/lock_channel_states": grpclib.const.Handler(
                self.__rpc_lock_channel_states,
                grpclib.const.Cardinality.UNARY_UNARY,
                LockChannelStatesRequest,
                LockChannelStatesResponse,
            ),
            "/minknow_api.data.DataService/unlock_channel_states": grpclib.const.Handler(
                self.__rpc_unlock_channel_states,
                grpclib.const.Cardinality.UNARY_UNARY,
                UnlockChannelStatesRequest,
                UnlockChannelStatesResponse,
            ),
            "/minknow_api.data.DataService/get_live_reads": grpclib.const.Handler(
                self.__rpc_get_live_reads,
                grpclib.const.Cardinality.STREAM_STREAM,
                GetLiveReadsRequest,
                GetLiveReadsResponse,
            ),
            "/minknow_api.data.DataService/record_adaptive_sampling_information": grpclib.const.Handler(
                self.__rpc_record_adaptive_sampling_information,
                grpclib.const.Cardinality.UNARY_UNARY,
                RecordAdaptiveSamplingInformationRequest,
                RecordAdaptiveSamplingInformationResponse,
            ),
            "/minknow_api.data.DataService/get_read_statistics": grpclib.const.Handler(
                self.__rpc_get_read_statistics,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetReadStatisticsRequest,
                GetReadStatisticsResponse,
            ),
            "/minknow_api.data.DataService/get_experiment_yield_info": grpclib.const.Handler(
                self.__rpc_get_experiment_yield_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetExperimentYieldInfoRequest,
                GetExperimentYieldInfoResponse,
            ),
        }
