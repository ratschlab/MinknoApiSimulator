# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/acquisition.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import run_until as _run_until__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class MinknowStatus(betterproto.Enum):
    ERROR_STATUS = 0
    """
    ERROR_STATUS occurs when there is an error during a transition from one state to another.
     Minknow will try to revert into the READY state to try to stabalise itself, but there is no guarantee of
     that succeeding
    """

    READY = 1
    """READY occurs when minknow is ready for a new experiment to start."""

    STARTING = 2
    """
    STARTING occurs when minknow has received a call for an experiment to start and is setting up the environment
     for data acquisition to begin
    """

    PROCESSING = 3
    """PROCESSING occurs when minknow is reading data from the device."""

    FINISHING = 4
    """
    FINISHING occurs when data acquisition has stopped (either from a explicit rpc request or the experiment naturally ended)
     and data is still being processed (basecalling is still in catchup and processing reads).
    """


class Option(betterproto.Enum):
    """An on/off setting where MinKNOW can be allowed to choose a default."""

    AUTO = 0
    """Allow MinKNOW to choose the default it believes is appropriate."""

    DISABLE = 1
    """Prevent the behaviour being controlled."""

    FORCE = 2
    """Force the behaviour being controlled."""


class Purpose(betterproto.Enum):
    _ = 0
    """
    No specific purpose listed.
    
     Reports and sequencing metrics will be disabled by default. No modifications will be made to
     the analysis configuration.
    """

    SEQUENCING = 2
    """
    Indicates that the acquisition is for sequencing.
    
     This will enable reports and sequencing metrics by default.
    """

    CALIBRATION = 3
    """
    Indicates that the acquisition is for calibration.
    
     This will disable the entire analysis pipeline and all file output.
    """


class AcquisitionState(betterproto.Enum):
    ACQUISITION_STARTING = 0
    """The acquisition period is starting up."""

    ACQUISITION_RUNNING = 1
    """The acquisition period is still running."""

    ACQUISITION_FINISHING = 2
    """
    The acquisition period is finishing:
     ie. finishing processing and saving
     data produced during the run.
    """

    ACQUISITION_COMPLETED = 3
    """
    The acquisition period finished on its own and
     did not report an error.
    """

    ACQUISITION_PAUSED = 4
    """
    The acquisition period is paused.
     that is, no data transfer occurring.
    """


class AcquisitionStopReason(betterproto.Enum):
    STOPPED_NOT_SET = 0
    """
    The acquisition has not yet stopped.
     Or the stop reason is unknown
    """

    STOPPED_USER_REQUESTED = 1
    """The user called the stop rpc."""

    STOPPED_NO_DISK_SPACE = 2
    """MinKNOW detected disk space was low and ended acquisition."""

    STOPPED_DEVICE_STOPPED_ACQUISITION = 3
    """The device stopped acquisition as it was unable to read data."""

    STOPPED_STARTING_ANOTHER_RUN = 4
    """Another acquisition run was requested, so the old one was stopped."""

    STOPPED_PROTOCOL_ENDED = 5
    """The protocol ended, causing the acquisition to stop."""

    STOPPED_DEVICE_ERROR = 6
    """The device or asic was disconnected, causing the run to stop."""

    STOPPED_BAD_TEMPERATURE = 7
    """
    The temperature was out of a safe range (either got extremely hot or was too
     far from the set-point for a certain amount of time)
    """

    STOPPED_SHUTDOWN = 8
    """
    MinKNOW (or the sequencing device) was shut down, turned off or crashed.
    """

    STOPPED_INTERNAL_ERROR = 9
    """
    An internal error occurred in MinKNOW, causing acquisition to stop (or fail to start).
    """


class StartupState(betterproto.Enum):
    STARTUP_UNKNOWN = 0
    STARTUP_BUILDING_PIPELINE = 2
    """Building the analysis pipeline objects."""

    STARTUP_INITIALISING_BASECALLER = 3
    """Waiting for the basecaller to load any required data/references."""

    STARTUP_INITIALISING_BASECALLER_ALIGNMENT = 4
    """Waiting for the basecaller to load alignment specific data files."""

    STARTUP_INITIALISING_DATA_WRITERS = 5
    """Setting up data writers for outputting reads/files."""

    STARTUP_INITIALISING_INTERMEDIATE_DATA_STORAGE = 6
    """Initialising storage for in flight reads."""

    STARTUP_INITIALISING_STATISTICS = 7
    """Initialising storage for run statistics."""


class FinishingState(betterproto.Enum):
    FINISHING_UNKNOWN = 0
    """The default state for acquisition"""

    FINISHING_PROCESSING_DEVICE_SIGNAL = 1
    """The acquisition is processing raw signal into reads"""

    FINISHING_BASECALLING_READS = 2
    """Processed reads are being basecalled"""

    FINISHING_SAVING_DATA = 3
    """Data is being written to disk (or copied to network storage)"""


class StopRequestDataAction(betterproto.Enum):
    STOP_DEFAULT = 0
    """
    The current default is set to FINISH_PROCESSING, but is subject to change
    """

    STOP_KEEP_ALL_DATA = 1
    """
    STOP_KEEP_ALL_DATA tells minknow to stop basecalling catchup, but keep all of the read files
     Any reads that have not been successfully/unsuccessfully basecalled will be classed as 'skipped'
    """

    STOP_FINISH_PROCESSING = 2
    """
    FINISH_PROCESSING will allow basecalling to continue catchup until all of the reads have been basecalled
    """


class SetSignalReaderRequestSignalReaderType(betterproto.Enum):
    """Available signal reader types"""

    HDF5 = 0
    PLAYBACK = 0
    DEVICE = 1


class SetSignalReaderRequestSourceFileMode(betterproto.Enum):
    UNSPECIFIED = 0
    SINGLE_RUN = 1
    LOOP = 2


@dataclass(eq=False, repr=False)
class StartRequest(betterproto.Message):
    """Protobuf messages for input/output of RPC calls"""

    dont_wait_for_device_ready: bool = betterproto.bool_field(2)
    """
    Prevent waiting until the device is ready before starting acquisition.
    
     Defaults to false.
    
     By default, MinKNOW will block in the start() call for the device and flow cell to be ready
     for acquisition (which may take several seconds after plugging in the flow cell on some
     devices). Setting this option will cause the call to return with an error if the device is
     not already prepared to acquire data.
    
     Since 1.14
    """

    generate_report: "Option" = betterproto.enum_field(3)
    """
    Generate duty time and throughput reports.
    
     Note that this setting will be ignored (and no reports will be generated) if no protocol is
     running at the time acquisition is started.
    
     The default setting (AUTO) will only generate reports if purpose is set to SEQUENCING.
    
     Since 3.0
    """

    send_sequencing_read_metrics: "Option" = betterproto.enum_field(4)
    """
    Whether sequencing read metrics should be reported to Oxford Nanopore.
    
     These are performance metrics that are used to improve the sequencing technology. They do not
     include any actual sequencing data, only statistics about read lengths, duty time and similar
     generic performance information.
    
     The default setting (AUTO) will only send metrics if purpose is set to SEQUENCING.
    
     Since 3.0
    """

    send_basecalling_metrics: "Option" = betterproto.enum_field(5)
    """
    Whether basecalling metrics should be reported to Oxford Nanopore.
    
     These are performance metrics that are used to improve the sequencing technology. They do not
     include any actual sequencing data, only statistics about basecalling performance.
    
     The default setting (AUTO) will only send metrics if purpose is set to SEQUENCING.
    
     NB: this setting is ignored if live basecalling is not enabled, since there will be no
     metrics to send.
    
     Since 3.2
    """

    purpose: "Purpose" = betterproto.enum_field(6)
    """
    Specify the purpose of this acquisition period.
    
     This affects various defaults (see the Purpose enum documentation for more details). It may
     also affect how the user interface presents the state of the protocol.
    
     Since 3.2
    """

    analysis: "Option" = betterproto.enum_field(7)
    """
    Perform analysis for this acquisition period.
    
     If this is disabled, no reads, no events, no channel states and no basecalls will be
     generated. Any RPCs that depend on any of these will fail. No reads-based files will be
     produced at all, regardless of any other settings.
    
     This is mostly useful for calibration (although you should normally use the purpose field
     rather than setting this explicitly).
    
     The default setting (AUTO) will use the persistent setting from the analysis_configuraiton
     service, unless the purpose is set to CALIBRATION.
    
     Since 3.2
    """

    file_output: "Option" = betterproto.enum_field(8)
    """
    Allow file output for this acquisition period.
    
     If this is disabled, the file output settings will be ignored for this acquisition period,
     and no data files will be produced. Note that reports are NOT managed by this setting.
    
     Note that setting this to FORCE will simply make file output respect the bulk and read writer
     configurations. If each file output type is disabled, you will still get no file output.
    
     This is mostly useful for calibration (although you should normally use the purpose field
     rather than setting this explicitly).
    
     The default setting (AUTO) will only suppress file output if purpose is set to CALIBRATION.
    
     Since 3.2
    """

    generate_final_summary: "Option" = betterproto.enum_field(9)
    """
    Write a final_summary.txt file.
    
     If file_output is disabled, the final_summary.txt file will not be written regardless of
     this setting.
    
     The default setting (AUTO) will only enable writing a final_summary.txt file if the purpose
     is set to SEQUENCING.
    
     Since 3.5 (NB: in 3.3 and 3.4, final_summary.txt was always written out if file_output was
     enabled).
    """


@dataclass(eq=False, repr=False)
class StartResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    Globally-unique identifier generated when the acquisition is started.
    
     This is guaranteed to unique, including aross sequencing devices.
    """


@dataclass(eq=False, repr=False)
class StopRequest(betterproto.Message):
    data_action_on_stop: "StopRequestDataAction" = betterproto.enum_field(1)
    wait_until_ready: bool = betterproto.bool_field(2)
    """
    Defaults to false
     If false will return as soon as minknow enters the FINISHING state.
     If true then returns as soon as minknow enters the READY state.
    """

    keep_power_on: bool = betterproto.bool_field(3)
    """
    Force the MinION/GridION ASIC power to be kept on after the current acquisition finishes
    
     Keeping the ASIC power on has two main effects:
    
          - The flow-cell will remain at the correct operating temperature between acquisitions;
            this allows following acquisition to be started more quickly.
    
          - MinION/GridION flow cells may be damaged if they are removed or plugged in while the
            ASIC power is turned on.
    
     Therefore, this option should be set to `true` if and only if another acquisition will be
     performed using the same flow-cell, soon after the acquisition that is being stopped.
     Otherwise it should be set to `false` (or left unset) to prevent potential damage to
     MinION/GridION flow-cells.
    
     If this option is set to `false` (or is left unset), then the application configuration
     determines whether the power will be left on when the acquisition finishes -- see the
     `powered_when_idle` and `flongle_powered_when_idle` configuration options for further
     details.
    
     This option has no effect on PromethIONs.
    
     Since 1.15.2
    """


@dataclass(eq=False, repr=False)
class StopResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class WatchForStatusChangeRequest(betterproto.Message):
    stop: bool = betterproto.bool_field(1)


@dataclass(eq=False, repr=False)
class WatchForStatusChangeResponse(betterproto.Message):
    status: "MinknowStatus" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class CurrentStatusRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CurrentStatusResponse(betterproto.Message):
    status: "MinknowStatus" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class GetProgressRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetProgressResponse(betterproto.Message):
    raw_per_channel: "GetProgressResponseRawPerChannel" = betterproto.message_field(1)
    """
    The amount of raw data (per channel) that has been acquired and
     processed.
    """


@dataclass(eq=False, repr=False)
class GetProgressResponseRawPerChannel(betterproto.Message):
    acquired: int = betterproto.uint64_field(1)
    """Number of samples (per channel) acquired from the device."""

    processed: int = betterproto.uint64_field(2)
    """
    Number of samples (per channel) passed to the analysis pipeline
     for processing.
    
     This can be compared to acquired to see how far behind the analysis
     is lagging.
    """


@dataclass(eq=False, repr=False)
class GetAcquisitionRunInfoRequest(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """The acquisition period to get information about."""


@dataclass(eq=False, repr=False)
class AcquisitionYieldSummary(betterproto.Message):
    read_count: int = betterproto.int64_field(1)
    """
    Number of reads selected by analysis as good reads.
    
     The reads in this counter are completed, but not necessarily on disk yet.
    """

    fraction_basecalled: float = betterproto.float_field(20)
    """
    This is the fraction of whole reads that the base-caller has finished
     with. The value should be in the range [0.0, 1.0]
    
     When base-calling is enabled, it can be added to fraction_skipped and
     multiplied by 100 to give the percentage of reads processed and by
     implication, the percentage of reads the user is waiting for the
     base-caller to process.
    
     Since 5.0
    """

    fraction_skipped: float = betterproto.float_field(21)
    """
    This is the fraction of whole reads that have been skipped. The value
     should be in the range [0.0, 1.0]
    
     Since 5.0
    """

    basecalled_pass_read_count: int = betterproto.int64_field(3)
    """
    Number of basecalls successfully produced. Note that one read may produce _multiple_ basecalls.
     Therefore the sum of this field, 'basecalled_fail_read_count', and 'basecalled_skipped_read_count'
     should be greater than or equal to 'read_count'.
    """

    basecalled_fail_read_count: int = betterproto.int64_field(4)
    """Number of reads which have failed to basecall."""

    basecalled_skipped_read_count: int = betterproto.int64_field(10)
    """Number of reads which have been skipped"""

    basecalled_pass_bases: int = betterproto.int64_field(5)
    """Number of bases which have been called and classed as pass."""

    basecalled_fail_bases: int = betterproto.int64_field(18)
    """Number of bases which have been called and were classed as fail."""

    basecalled_pass_reads_split: "AcquisitionYieldSummaryTotalsPerDuplexCategory" = (
        betterproto.message_field(22)
    )
    """
    How many of the basecalled reads so far have been classified by the basecaller as...
    """

    basecalled_fail_reads_split: "AcquisitionYieldSummaryTotalsPerDuplexCategory" = (
        betterproto.message_field(23)
    )
    basecalled_pass_bases_split: "AcquisitionYieldSummaryTotalsPerDuplexCategory" = (
        betterproto.message_field(24)
    )
    """As above, but counted in bases rather than basecalls."""

    basecalled_fail_bases_split: "AcquisitionYieldSummaryTotalsPerDuplexCategory" = (
        betterproto.message_field(25)
    )
    basecalled_samples: int = betterproto.int64_field(6)
    """Number of raw samples which have been called."""

    selected_raw_samples: int = betterproto.int64_field(7)
    """
    Number of minknow raw samples which have been selected
     for writing to disk as reads.
    """

    selected_events: int = betterproto.int64_field(8)
    """
    Number of minknow events which have been selected
     for writing to disk as reads.
    """

    estimated_selected_bases: int = betterproto.int64_field(9)
    """
    Estimated number of bases MinKNOW has selected for writing.
     This is estimated based on already called bases and samples.
    """

    alignment_matches: int = betterproto.int64_field(14)
    """
    Number of bases which have matched target reference.
    
     Only specified when running live alignment.
    
     Since 4.0
    """

    alignment_mismatches: int = betterproto.int64_field(15)
    """
    Number of bases which have not matched target reference.
    
     Only specified when running live alignment.
    
     Since 4.0
    """

    alignment_insertions: int = betterproto.int64_field(16)
    """
    Number of bases which were inserted into
     alignments that matched the reference.
    
     Only specified when running live alignment.
    
     Since 4.0
    """

    alignment_deletions: int = betterproto.int64_field(17)
    """
    Number of bases which were deleted from
     alignments that matched the reference.
    
     Only specified when running live alignment.
    
     Since 4.0
    """

    alignment_coverage: float = betterproto.float_field(19)
    """
    Number of bases that match the target reference(s) expressed as a
     fraction of the total size of the target reference(s).
    
     eg: For a specified alignment-targets with 2000 and 3000 bases, if
     "alignment_matches" is 2500, then "alignment_coverage" will be 0.5
    
     Since 4.3
    """


@dataclass(eq=False, repr=False)
class AcquisitionYieldSummaryTotalsPerDuplexCategory(betterproto.Message):
    """
    Note: If duplex isn't enabled, all reads and basecalls will be classed as 'simplex' and the 'duplex' fields will be 0.
    """

    simplex: int = betterproto.int64_field(1)
    duplex_template: int = betterproto.int64_field(2)
    duplex_complement: int = betterproto.int64_field(3)
    duplex_combined: int = betterproto.int64_field(4)


@dataclass(eq=False, repr=False)
class AcquisitionWriterSummary(betterproto.Message):
    bytes_to_write_produced: int = betterproto.int64_field(2)
    """
    Number of bytes which minknow needs to write in order to
     finish the experiment.
    """

    bytes_to_write_failed: int = betterproto.int64_field(3)
    """
    Number of bytes which minknow has failed to write to final location.
     These reads are instead contained in the fallback/tmp locations.
    """

    bytes_to_write_completed: int = betterproto.int64_field(4)
    """Number of bytes which minknow has written to final location."""


@dataclass(eq=False, repr=False)
class ChannelStateInfo(betterproto.Message):
    groups: List["ChannelStateInfoGroup"] = betterproto.message_field(1)
    """
    The groups of channel states.
    
     The groups are ordered according to the "order" attribute of the group style in the channel
     states configuration.
    """


@dataclass(eq=False, repr=False)
class ChannelStateInfoStyle(betterproto.Message):
    label: str = betterproto.string_field(1)
    """
    The human-readable name to display when rendering this channel state or group.
    """

    description: str = betterproto.string_field(2)
    """
    A sentence describing the meaning of the channel state or group.
    
     This can be used as a tooltip, for example.
    """

    colour: str = betterproto.string_field(3)
    """
    The colour to use when rendering this channel state or group.
    
     This is a six-digit hex string describing an RGB colour (eg: "ff00ff" for purple).
    """


@dataclass(eq=False, repr=False)
class ChannelStateInfoChannelState(betterproto.Message):
    id: int = betterproto.uint32_field(1)
    """
    The numeric identifier of the state.
    
     This is what is reported in any other APIs that return a channel state ID.
    """

    name: str = betterproto.string_field(2)
    """
    The internal name of the state.
    
     This is what is reported in any other APIs that return a channel state name.
    """

    style: "ChannelStateInfoStyle" = betterproto.message_field(3)
    """
    How to render the channel state in a graphical user interface.
    
     Note that the style may be missing from some channel states (such as the ones that are
     built in to MinKNOW).
    """

    global_order: int = betterproto.uint32_field(4)
    """
    An order ranking for the channel states when they are ungrouped.
    
     This can be used to order the channel states after merging the groups.
    """


@dataclass(eq=False, repr=False)
class ChannelStateInfoGroup(betterproto.Message):
    name: str = betterproto.string_field(1)
    """The name of the group."""

    style: "ChannelStateInfoStyle" = betterproto.message_field(2)
    """
    How to render the group in a graphical user interface.
    
     Note that the style may be missing from some groups (such as the ones that are built in
     to MinKNOW).
    """

    states: List["ChannelStateInfoChannelState"] = betterproto.message_field(3)
    """
    The channel states contained in the group.
    
     The groups are ordered according to the "order" attribute of the channel state style in
     the channel states configuration.
    """


@dataclass(eq=False, repr=False)
class AcquisitionConfigSummary(betterproto.Message):
    purpose: "Purpose" = betterproto.enum_field(21)
    """The purpose, as supplied to `acquisition.start()`"""

    basecalling_enabled: bool = betterproto.bool_field(1)
    """Was basecalling enabled for the run."""

    basecalling_config_filename: str = betterproto.string_field(16)
    """Basecalling configuration filename (if basecalling enabled)"""

    basecalling_model_version: str = betterproto.string_field(24)
    """
    Basecalling model version (empty if basecalling not enabled)
     Since 6.0
    """

    duplex_enabled: bool = betterproto.bool_field(23)
    """
    Was the experiment a duplex basecalling experiment (false if basecalling is disabled)
    """

    barcoding_enabled: bool = betterproto.bool_field(13)
    """Is barcoding enabled for the run"""

    barcoding_kits: List[str] = betterproto.string_field(17)
    """/ Barcoding kit(s) used (if barcoding enabled)"""

    alignment_enabled: bool = betterproto.bool_field(14)
    """Is alignment enabled for the run"""

    alignment_reference_files: List[str] = betterproto.string_field(18)
    """Alignment reference file(s) used (if alignment enabled)"""

    alignment_bed_file: str = betterproto.string_field(19)
    """bed file used (if alignment enabled, and bed file specified)"""

    lamp_enabled: bool = betterproto.bool_field(15)
    """
    Is lamp enabled for the run
    
     DEPRECATED 6.0: Lamp support has been removed and this value will always be false.
    """

    lamp_kit: str = betterproto.string_field(20)
    """
    The LAMP kit used (if LAMP enabled)
    
     DEPRECATED 6.0: Lamp support has been removed and this value will always be empty.
    """

    reads_directory: str = betterproto.string_field(2)
    """
    Root directory reads were written to for the run.
    
     Empty if no reads were enabled.
    """

    reads_fallback_directories: List[str] = betterproto.string_field(3)
    """
    Directories reads are written to if the reads_directory is on the network
     and writes to it fail.
    
     Empty if no reads were enabled.
    """

    fast5_reads_enabled: bool = betterproto.bool_field(4)
    """Determine if fast5 reads were enabled for the run."""

    fastq_reads_enabled: bool = betterproto.bool_field(5)
    """Determine if fastq reads were enabled for the run."""

    pod5_reads_enabled: bool = betterproto.bool_field(22)
    """Determine if pod5 reads were enabled for the run."""

    bulk_file_path: str = betterproto.string_field(7)
    """
    The path of the bulk file for the run.
    
     Empty if no reads were enabled.
    """

    bulk_file_enabled: bool = betterproto.bool_field(8)
    """Find if the bulk writer was enabled for a run."""

    channel_state_info: "ChannelStateInfo" = betterproto.message_field(9)
    """Channel state styling information"""

    events_to_base_ratio: float = betterproto.float_field(10)
    """Number of bases per event"""

    sample_rate: int = betterproto.uint32_field(11)
    """
    Sample rate for the acquisition.
    
     Since 3.3
    """

    channel_count: int = betterproto.uint32_field(12)
    """
    Channel count used in the acquisition.
    
     Since 3.3
    """


@dataclass(eq=False, repr=False)
class MuxScanMetadata(betterproto.Message):
    """
    Provides information about how mux scans are configured.

     This primarily information to help present mux scan results to the user (see `MuxScanResult`).
    """

    auto_mux_scan_period_hours: float = betterproto.float_field(1)
    """How frequently automatic scans are scheduled to occur."""

    category_groups: List["MuxScanMetadataCategoryGroup"] = betterproto.message_field(2)
    """
    Presentation information for categories.
    
     Describes the preferred way to present mux scan categories to users. Groups should be
     presented in the order of this list.
    """


@dataclass(eq=False, repr=False)
class MuxScanMetadataStyle(betterproto.Message):
    """Presentation information for a category or group."""

    label: str = betterproto.string_field(1)
    """
    The human-readable name to display when rendering this category or group.
    """

    description: str = betterproto.string_field(2)
    """
    A sentence describing the meaning of the category or group.
    
     This can be used as a tooltip, for example.
    """

    colour: str = betterproto.string_field(3)
    """
    The colour to use when rendering this category or group.
    
     This is a six-digit hex string describing an RGB colour (eg: "ff0000" for red).
    """


@dataclass(eq=False, repr=False)
class MuxScanMetadataCategory(betterproto.Message):
    """A category that a channel mux can be assigned."""

    name: str = betterproto.string_field(1)
    """
    Name of the category.
    
     This is the value that will be in the `MuxScanResult.counts` field.
    
     The user should not be shown this. Instead, `style.label` should be displayed.
    """

    style: "MuxScanMetadataStyle" = betterproto.message_field(2)
    """How to render the category in a graphical user interface."""

    global_order: int = betterproto.uint32_field(3)
    """
    An order ranking for the category when displaying them without using groups.
    """


@dataclass(eq=False, repr=False)
class MuxScanMetadataCategoryGroup(betterproto.Message):
    name: str = betterproto.string_field(1)
    """The name of the group."""

    style: "MuxScanMetadataStyle" = betterproto.message_field(2)
    """How to render the group in a graphical user interface."""

    category: List["MuxScanMetadataCategory"] = betterproto.message_field(3)
    """
    The categories contained in the group.
    
     Within this group, categories should be presented in the order of this list.
    """


@dataclass(eq=False, repr=False)
class MuxScanResult(betterproto.Message):
    """
    A report of the states of channel muxes (wells) across the flow cell.

     Every channel mux (well) is assigned to a specific category describing its state (for example, is
     it expected to produce good results, and if not why not?). This is a report of how many channel
     muxes are in each category.
    """

    counts: Dict[str, int] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_UINT32
    )
    """
    How many channel muxes are in each category.
    
     The sum of all the values in this map should be the number of channels multiplied by the
     number of muxes on each channel (eg: 512x4=2048 on a MinION Mk1B without a flongle adapter).
    
     eg. 'sequencing': 1500
    """

    mux_scan_timestamp: int = betterproto.uint64_field(2)
    """
    When this mux scan result was added (Seconds since the start of the acquisition).
    """


@dataclass(eq=False, repr=False)
class BreamInfo(betterproto.Message):
    """
    Information provided by Bream.

     Note that this is provided by the protocol, and some protocols may choose not to provide this.
    """

    mux_scan_metadata: "MuxScanMetadata" = betterproto.message_field(1)
    """Presentation information for mux scan results."""

    mux_scan_results: List["MuxScanResult"] = betterproto.message_field(2)
    """Mux scan results."""

    target_translocation_speed: "BreamInfoRange" = betterproto.message_field(3)
    """
    The ideal translocation speed range.
    
     This can be used to provide context for speed graphs (see the statistics RPCs), showing what
     range is considered "good".
    """

    target_q_score: "BreamInfoRange" = betterproto.message_field(4)
    """
    The ideal quality (Q) score range.
    
     This can be used to provide context for q-score graphs (see the statistics RPCs), showing
     what range is considered "good".
    """

    target_temperature: "BreamInfoRange" = betterproto.message_field(5)
    """
    The ideal temperature range.
    
     This can be used to provide context for temperature (see the statistics RPCs), showing
     what range is considered "good".
    
     Note that a protocol may request a different temperature range than this (eg: it might
     request a tighter range, or it may adjust the temperature it is requesting throughout the
     run). This intended only to provide context when presenting data to users.
    """


@dataclass(eq=False, repr=False)
class BreamInfoRange(betterproto.Message):
    """Represents a range of values."""

    minimum: float = betterproto.double_field(1)
    maximum: float = betterproto.double_field(2)


@dataclass(eq=False, repr=False)
class TargetRunUntilCriteria(betterproto.Message):
    pause_criteria: "_run_until__.CriteriaValues" = betterproto.message_field(1)
    stop_criteria: "_run_until__.CriteriaValues" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AcquisitionRunInfo(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    The unique identifier assigned to this acquisition run.
    
     This is guaranteed to be made of ASCII characters, and at
     most 40 characters. It is globally unique across all
     acquisitions on all MinKNOW instances.
    """

    startup_state: "StartupState" = betterproto.enum_field(12)
    """Current startup task (or STARTUP_UNKNOWN if not starting up)."""

    startup_state_estimated_end: datetime = betterproto.message_field(13)
    """
    Estimated time for current startup state to end.
    
     In some cases this field is left unset, to indicate no estimation.
    """

    startup_state_estimated_percent_complete: float = betterproto.float_field(14)
    """
    Estimate startup state completion percent (0 - 1).
    
     In some cases this field is left at 0, indicating no estimation.
    """

    state: "AcquisitionState" = betterproto.enum_field(2)
    """Indicates the current state of the acquisition."""

    finishing_state: "FinishingState" = betterproto.enum_field(10)
    """
    If the experiment is finishing, an extra piece of state
     describing the current finishing state.
    """

    finishing_state_percent_complete: float = betterproto.float_field(17)
    """
    Progress through the current finishing state, ranges from 0 - 1.
    
     This will increase from 0 -> 1 for each individual finishing state, then reset.
    """

    stop_reason: "AcquisitionStopReason" = betterproto.enum_field(3)
    """The reason the acquisition period was ended."""

    start_time: datetime = betterproto.message_field(4)
    """When the acquisition period was started (UTC)."""

    data_read_start_time: datetime = betterproto.message_field(5)
    """
    When MinKNOW began acquiring data (UTC).
    
     Unset if the acquisition is still starting up.
    """

    data_read_end_time: datetime = betterproto.message_field(6)
    """
    When the MinKNOW stopped acquiring data (UTC).
    
     Unset if the acquisition is still acquiring.
    """

    end_time: datetime = betterproto.message_field(7)
    """
    When the acquisition terminated (UTC).
    
     Unset if the acquisition period is still running.
    """

    yield_summary: "AcquisitionYieldSummary" = betterproto.message_field(8)
    """
    Summary of acquisition yields.
    
     Since 1.12
    """

    config_summary: "AcquisitionConfigSummary" = betterproto.message_field(9)
    """
    Summary of the configuration settings for a run.
    
     Since 1.14
    """

    writer_summary: "AcquisitionWriterSummary" = betterproto.message_field(11)
    """
    Summary of writer yields.
    
     Since 4.0
    """

    bream_info: "BreamInfo" = betterproto.message_field(15)
    """Set information provided by the Bream toolkit."""

    target_run_until_criteria: "TargetRunUntilCriteria" = betterproto.message_field(16)
    """
    Target Run-Until Criteria, used to determine when the acquisition should be paused
     or stopped.
    
     Since 5.3
    """


@dataclass(eq=False, repr=False)
class ListAcquisitionRunsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListAcquisitionRunsResponse(betterproto.Message):
    run_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetCurrentAcquisitionRunRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class WatchCurrentAcquisitionRunRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetSignalReaderRequest(betterproto.Message):
    reader: "SetSignalReaderRequestSignalReaderType" = betterproto.enum_field(1)
    """The type of signal reader to use"""

    hdf_source: str = betterproto.string_field(2)
    """
    The following settings are optional, and only used when setting the reader to hdf5
    """

    hdf_mode: "SetSignalReaderRequestSourceFileMode" = betterproto.enum_field(3)
    sample_rate_scale_factor: float = betterproto.float_field(4)


@dataclass(eq=False, repr=False)
class SetSignalReaderResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetSignalReaderRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetSignalReaderResponse(betterproto.Message):
    reader: "SetSignalReaderRequestSignalReaderType" = betterproto.enum_field(1)
    """The type of signal reader to use"""

    playback_source: str = betterproto.string_field(2)
    """The following is only set if the signal reader is a playback source."""

    playback_mode: "SetSignalReaderRequestSourceFileMode" = betterproto.enum_field(3)
    sample_rate_scale_factor: float = betterproto.float_field(4)


@dataclass(eq=False, repr=False)
class SetBreamInfoRequest(betterproto.Message):
    info: "BreamInfo" = betterproto.message_field(1)
    """
    The information to set.
    
     Note that, other than treating the top-level fields independently (see the other flags on
     this request), MinKNOW Core will not do anything special to the data. In particular, the
     caller must fill in the `mux_scan_timestamp` field in `MuxScanResult` messages.
    """

    overwrite_unset_fields: bool = betterproto.bool_field(2)
    """
    If any `BreamInfo` fields were set in a previous call, but are unset in the `info` field of
     this call, then use the old value for them.
    
     For example, to just update the mux_scan_metadata field, use a BreamInfo object with only the
     `mux_scan_metadata` field set, and leave this as False. To clear the entire BreamInfo
     structure, leave `info` empty and set this to True.
    """


@dataclass(eq=False, repr=False)
class SetBreamInfoResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class AppendMuxScanResultResponse(betterproto.Message):
    pass


class AcquisitionServiceStub(betterproto.ServiceStub):
    async def start(
        self,
        start_request: "StartRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StartResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/start",
            start_request,
            StartResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stop(
        self,
        stop_request: "StopRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StopResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/stop",
            stop_request,
            StopResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def watch_for_status_change(
        self,
        watch_for_status_change_request_iterator: Union[
            AsyncIterable[WatchForStatusChangeRequest],
            Iterable[WatchForStatusChangeRequest],
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[WatchForStatusChangeResponse]:
        async for response in self._stream_stream(
            "/minknow_api.acquisition.AcquisitionService/watch_for_status_change",
            watch_for_status_change_request_iterator,
            WatchForStatusChangeRequest,
            WatchForStatusChangeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def watch_current_acquisition_run(
        self,
        watch_current_acquisition_run_request: "WatchCurrentAcquisitionRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[AcquisitionRunInfo]:
        async for response in self._unary_stream(
            "/minknow_api.acquisition.AcquisitionService/watch_current_acquisition_run",
            watch_current_acquisition_run_request,
            AcquisitionRunInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def current_status(
        self,
        current_status_request: "CurrentStatusRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CurrentStatusResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/current_status",
            current_status_request,
            CurrentStatusResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_progress(
        self,
        get_progress_request: "GetProgressRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetProgressResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/get_progress",
            get_progress_request,
            GetProgressResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_acquisition_info(
        self,
        get_acquisition_run_info_request: "GetAcquisitionRunInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AcquisitionRunInfo":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/get_acquisition_info",
            get_acquisition_run_info_request,
            AcquisitionRunInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_acquisition_runs(
        self,
        list_acquisition_runs_request: "ListAcquisitionRunsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListAcquisitionRunsResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/list_acquisition_runs",
            list_acquisition_runs_request,
            ListAcquisitionRunsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_current_acquisition_run(
        self,
        get_current_acquisition_run_request: "GetCurrentAcquisitionRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AcquisitionRunInfo":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/get_current_acquisition_run",
            get_current_acquisition_run_request,
            AcquisitionRunInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_signal_reader(
        self,
        set_signal_reader_request: "SetSignalReaderRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetSignalReaderResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/set_signal_reader",
            set_signal_reader_request,
            SetSignalReaderResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_signal_reader(
        self,
        get_signal_reader_request: "GetSignalReaderRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetSignalReaderResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/get_signal_reader",
            get_signal_reader_request,
            GetSignalReaderResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_bream_info(
        self,
        set_bream_info_request: "SetBreamInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetBreamInfoResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/set_bream_info",
            set_bream_info_request,
            SetBreamInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def append_mux_scan_result(
        self,
        mux_scan_result: "MuxScanResult",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AppendMuxScanResultResponse":
        return await self._unary_unary(
            "/minknow_api.acquisition.AcquisitionService/append_mux_scan_result",
            mux_scan_result,
            AppendMuxScanResultResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class AcquisitionServiceBase(ServiceBase):

    async def start(self, start_request: "StartRequest") -> "StartResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stop(self, stop_request: "StopRequest") -> "StopResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def watch_for_status_change(
        self,
        watch_for_status_change_request_iterator: AsyncIterator[
            WatchForStatusChangeRequest
        ],
    ) -> AsyncIterator[WatchForStatusChangeResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield WatchForStatusChangeResponse()

    async def watch_current_acquisition_run(
        self, watch_current_acquisition_run_request: "WatchCurrentAcquisitionRunRequest"
    ) -> AsyncIterator[AcquisitionRunInfo]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AcquisitionRunInfo()

    async def current_status(
        self, current_status_request: "CurrentStatusRequest"
    ) -> "CurrentStatusResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_progress(
        self, get_progress_request: "GetProgressRequest"
    ) -> "GetProgressResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_acquisition_info(
        self, get_acquisition_run_info_request: "GetAcquisitionRunInfoRequest"
    ) -> "AcquisitionRunInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_acquisition_runs(
        self, list_acquisition_runs_request: "ListAcquisitionRunsRequest"
    ) -> "ListAcquisitionRunsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_current_acquisition_run(
        self, get_current_acquisition_run_request: "GetCurrentAcquisitionRunRequest"
    ) -> "AcquisitionRunInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_signal_reader(
        self, set_signal_reader_request: "SetSignalReaderRequest"
    ) -> "SetSignalReaderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_signal_reader(
        self, get_signal_reader_request: "GetSignalReaderRequest"
    ) -> "GetSignalReaderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_bream_info(
        self, set_bream_info_request: "SetBreamInfoRequest"
    ) -> "SetBreamInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def append_mux_scan_result(
        self, mux_scan_result: "MuxScanResult"
    ) -> "AppendMuxScanResultResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_start(
        self, stream: "grpclib.server.Stream[StartRequest, StartResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.start(request)
        await stream.send_message(response)

    async def __rpc_stop(
        self, stream: "grpclib.server.Stream[StopRequest, StopResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.stop(request)
        await stream.send_message(response)

    async def __rpc_watch_for_status_change(
        self,
        stream: "grpclib.server.Stream[WatchForStatusChangeRequest, WatchForStatusChangeResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.watch_for_status_change,
            stream,
            request,
        )

    async def __rpc_watch_current_acquisition_run(
        self,
        stream: "grpclib.server.Stream[WatchCurrentAcquisitionRunRequest, AcquisitionRunInfo]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.watch_current_acquisition_run,
            stream,
            request,
        )

    async def __rpc_current_status(
        self,
        stream: "grpclib.server.Stream[CurrentStatusRequest, CurrentStatusResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.current_status(request)
        await stream.send_message(response)

    async def __rpc_get_progress(
        self, stream: "grpclib.server.Stream[GetProgressRequest, GetProgressResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_progress(request)
        await stream.send_message(response)

    async def __rpc_get_acquisition_info(
        self,
        stream: "grpclib.server.Stream[GetAcquisitionRunInfoRequest, AcquisitionRunInfo]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_acquisition_info(request)
        await stream.send_message(response)

    async def __rpc_list_acquisition_runs(
        self,
        stream: "grpclib.server.Stream[ListAcquisitionRunsRequest, ListAcquisitionRunsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_acquisition_runs(request)
        await stream.send_message(response)

    async def __rpc_get_current_acquisition_run(
        self,
        stream: "grpclib.server.Stream[GetCurrentAcquisitionRunRequest, AcquisitionRunInfo]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_current_acquisition_run(request)
        await stream.send_message(response)

    async def __rpc_set_signal_reader(
        self,
        stream: "grpclib.server.Stream[SetSignalReaderRequest, SetSignalReaderResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_signal_reader(request)
        await stream.send_message(response)

    async def __rpc_get_signal_reader(
        self,
        stream: "grpclib.server.Stream[GetSignalReaderRequest, GetSignalReaderResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_signal_reader(request)
        await stream.send_message(response)

    async def __rpc_set_bream_info(
        self, stream: "grpclib.server.Stream[SetBreamInfoRequest, SetBreamInfoResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_bream_info(request)
        await stream.send_message(response)

    async def __rpc_append_mux_scan_result(
        self,
        stream: "grpclib.server.Stream[MuxScanResult, AppendMuxScanResultResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.append_mux_scan_result(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/minknow_api.acquisition.AcquisitionService/start": grpclib.const.Handler(
                self.__rpc_start,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartRequest,
                StartResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/stop": grpclib.const.Handler(
                self.__rpc_stop,
                grpclib.const.Cardinality.UNARY_UNARY,
                StopRequest,
                StopResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/watch_for_status_change": grpclib.const.Handler(
                self.__rpc_watch_for_status_change,
                grpclib.const.Cardinality.STREAM_STREAM,
                WatchForStatusChangeRequest,
                WatchForStatusChangeResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/watch_current_acquisition_run": grpclib.const.Handler(
                self.__rpc_watch_current_acquisition_run,
                grpclib.const.Cardinality.UNARY_STREAM,
                WatchCurrentAcquisitionRunRequest,
                AcquisitionRunInfo,
            ),
            "/minknow_api.acquisition.AcquisitionService/current_status": grpclib.const.Handler(
                self.__rpc_current_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                CurrentStatusRequest,
                CurrentStatusResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/get_progress": grpclib.const.Handler(
                self.__rpc_get_progress,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetProgressRequest,
                GetProgressResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/get_acquisition_info": grpclib.const.Handler(
                self.__rpc_get_acquisition_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetAcquisitionRunInfoRequest,
                AcquisitionRunInfo,
            ),
            "/minknow_api.acquisition.AcquisitionService/list_acquisition_runs": grpclib.const.Handler(
                self.__rpc_list_acquisition_runs,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListAcquisitionRunsRequest,
                ListAcquisitionRunsResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/get_current_acquisition_run": grpclib.const.Handler(
                self.__rpc_get_current_acquisition_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetCurrentAcquisitionRunRequest,
                AcquisitionRunInfo,
            ),
            "/minknow_api.acquisition.AcquisitionService/set_signal_reader": grpclib.const.Handler(
                self.__rpc_set_signal_reader,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetSignalReaderRequest,
                SetSignalReaderResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/get_signal_reader": grpclib.const.Handler(
                self.__rpc_get_signal_reader,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSignalReaderRequest,
                GetSignalReaderResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/set_bream_info": grpclib.const.Handler(
                self.__rpc_set_bream_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetBreamInfoRequest,
                SetBreamInfoResponse,
            ),
            "/minknow_api.acquisition.AcquisitionService/append_mux_scan_result": grpclib.const.Handler(
                self.__rpc_append_mux_scan_result,
                grpclib.const.Cardinality.UNARY_UNARY,
                MuxScanResult,
                AppendMuxScanResultResponse,
            ),
        }
