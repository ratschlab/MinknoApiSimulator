# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: minknow_api/protocol_settings.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import List

import betterproto

from .. import analysis_configuration as _analysis_configuration__


class ProtocolIdentifierComponentsLocation(betterproto.Enum):
    ANY = 0
    SYSTEM_SCRIPTS = 1
    USER_SCRIPTS = 2


class ProtocolSettingCategory(betterproto.Enum):
    OTHER = 0
    RUN_OPTIONS = 1
    BASECALLING = 2
    OUTPUT = 3


class ProtocolSettingUnit(betterproto.Enum):
    UNITLESS = 0
    UTF8_STRING = 1
    """strings"""

    ASCII_STRING = 2
    PATH = 3
    URL = 4
    PRIVATE_STRING = 5
    CHOICE = 6
    MULTI_CHOICE = 7
    SECOND = 8
    """numbers"""

    HOUR = 9
    BASE = 10
    KBASE = 11
    MBASE = 12
    GBASE = 13
    MILLIVOLT = 14


class ProtocolSettingVisibility(betterproto.Enum):
    EDITABLE = 0
    """User can change this, a default may be provided"""

    HIDDEN = 1
    """Don't show this to the user, it's not relevant to this protocol"""

    FIXED = 2
    """User shouldn't change this from the default"""

    REQUIRED = 3
    """User must set this, no sensible default can be provided"""


class ProtocolSettingConstraintCondition(betterproto.Enum):
    EQUAL = 0
    NOT_EQUAL = 1
    GT_EQ = 2
    GT = 3
    LT_EQ = 4
    LT = 5
    IN = 6
    NOT_IN = 7
    ENDS_WITH = 8
    STARTS_WITH = 9


@dataclass(eq=False, repr=False)
class ProtocolIdentifierComponents(betterproto.Message):
    location: "ProtocolIdentifierComponentsLocation" = betterproto.enum_field(1)
    """If not specified, will default to "ANY"""

    experiment_type: str = betterproto.string_field(2)
    """
    one of "custom", "sequencing", "control", "ctc", "platform qc" or "flowcell_plugin"
    """

    name: str = betterproto.string_field(3)
    """
    Name (or path) of the protocol, without the .toml extension eg: "sequencing/sequencing_MIN106_DNA" this is relative to the
     system or user protocol directory
    """

    flow_cell_product_code: str = betterproto.string_field(4)
    """eg: "FLO-MIN106"""

    kit: str = betterproto.string_field(5)
    """eg: "SQK-RPB004"""


@dataclass(eq=False, repr=False)
class ProtocolSetting(betterproto.Message):
    category: "ProtocolSettingCategory" = betterproto.enum_field(1)
    identifier: str = betterproto.string_field(2)
    """
    Identifier is the unique primary-key for referring to protocol-settings,
     dependencies refer to other settings via their identifier.
    """

    display_name: str = betterproto.string_field(3)
    help: str = betterproto.string_field(16)
    """
    Optional additional help text for a setting that may be shown to the user if required.
    """

    unit: "ProtocolSettingUnit" = betterproto.enum_field(5)
    default_value: "ProtocolSettingProtocolSettingValue" = betterproto.message_field(6)
    constraints: List["ProtocolSettingConstraint"] = betterproto.message_field(7)
    """
    All constraints must be met if this setting is to be considered valid
    """

    dependencies: List["ProtocolSettingDependency"] = betterproto.message_field(8)
    """
    If any of the dependencies matches it's constraints, this setting should
     adopt the level of visibility specified in "visibility". If none of the
     dependencies match their constraints, then "visibility" should be ignored
     and the option should be hidden from the user.
    
     Some dependencies may be specified multiple times, but with mutually
     exclusive constraints, for example if the setting controls data compression
     level, where there is a compression_algorithm setting specified by a string
     that can have the values "X", "Y" or "None". The setting may be dependent
     on compression_algorithm equals "X" or compression_algorithm equals "Y".
     If the compression_algorithm is "None" then none of the dependency constraints
     will be met and the setting should be hidden. A typical arrangement of fields
     in this case would be:
     Dependency {
       identifier: "compression_algorithm",
       Constraint {
         condition : EQUAL,
         value: "X"
       }
     }
     Dependency {
       identifier: "compression_algorithm",
       Constraint {
         condition : EQUAL,
         value: "Y"
       }
     }
     When a dependency is specified with multiple constraints they must all be
     met before the dependency is considered satisfied, for example some other
     setting may be dependent on compression_level being in a range (0,10] :
      Dependency {
       identifier: "compression_level",
       Constraint {
         condition : GT,
         value: 0
       },
       Constraint {
         condition : LT_EQ,
         value: 10
       }
     }
    """

    visibility: "ProtocolSettingVisibility" = betterproto.enum_field(9)
    """
    If any of the dependencies match their constraints, this level of visibility
     should be adopted. It should also be adopted if no dependencies are specified.
    """

    choices: List[str] = betterproto.string_field(17)
    """when unit is CHOICE, this defines the acceptable choices."""


@dataclass(eq=False, repr=False)
class ProtocolSettingProtocolSettingValue(betterproto.Message):
    string_value: str = betterproto.string_field(1, group="protocol_setting_value")
    float_value: float = betterproto.double_field(2, group="protocol_setting_value")
    integer_value: int = betterproto.int64_field(3, group="protocol_setting_value")
    bool_value: bool = betterproto.bool_field(4, group="protocol_setting_value")
    channels_value: (
        "_analysis_configuration__.WriterConfigurationChannelConfiguration"
    ) = betterproto.message_field(5, group="protocol_setting_value")
    multi_string_value: "ProtocolSettingProtocolSettingValueMultiString" = (
        betterproto.message_field(6, group="protocol_setting_value")
    )


@dataclass(eq=False, repr=False)
class ProtocolSettingProtocolSettingValueMultiString(betterproto.Message):
    values: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ProtocolSettingConstraint(betterproto.Message):
    condition: "ProtocolSettingConstraintCondition" = betterproto.enum_field(1)
    value: "ProtocolSettingProtocolSettingValue" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ProtocolSettingDependency(betterproto.Message):
    identifier: str = betterproto.string_field(1)
    constraints: List["ProtocolSettingConstraint"] = betterproto.message_field(2)
